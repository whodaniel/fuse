


==============================================
FILE: ./src/vscode-extension/.vscode/launch.json
==============================================

{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Run Extension",
      "type": "extensionHost",
      "request": "launch",
      "args": [
        "--extensionDevelopmentPath=${workspaceFolder}"
      ],
      "outFiles": [
        "${workspaceFolder}/out/**/*.js"
      ],
      "preLaunchTask": "npm: watch"
    },
    {
      "name": "Extension in Current Window",
      "type": "extensionHost",
      "request": "launch",
      "args": [
        "--extensionDevelopmentPath=${workspaceFolder}",
        "--disable-extension-debugging"
      ],
      "outFiles": [
        "${workspaceFolder}/out/**/*.js"
      ],
      "preLaunchTask": "npm: compile"
    }
  ]
}



==============================================
FILE: ./src/vscode-extension/.vscode/tasks.json
==============================================

{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "npm",
      "script": "watch",
      "problemMatcher": "$tsc-watch",
      "isBackground": true,
      "presentation": {
        "reveal": "never"
      },
      "group": {
        "kind": "build",
        "isDefault": true
      }
    },
    {
      "label": "Compile and Reload Window",
      "type": "shell",
      "command": "npm run compile && echo 'Compilation complete. Now reload your window with Command Palette > Developer: Reload Window'",
      "group": "build",
      "presentation": {
        "reveal": "always",
        "panel": "new"
      }
    }
  ]
}



==============================================
FILE: ./src/vscode-extension/.vscodeignore
==============================================




==============================================
FILE: ./src/vscode-extension/COMMAND-PALETTE-GUIDE.md
==============================================

# Using VS Code Command Palette with The New Fuse

## Opening the Command Palette

### Keyboard Shortcut (Recommended)
- **macOS**: `Cmd+Shift+P` (⌘⇧P)
- **Windows/Linux**: `Ctrl+Shift+P`

### Menu Option
1. Click on **View** in the menu bar
2. Select **Command Palette**

## Using The New Fuse Commands

After opening the Command Palette, you can:

1. Type `The New Fuse` to see all available commands from our extension
2. Type specific command names like:
   - `Open Communication Hub`
   - `Start AI Collaboration`
   - `Discover AI Agents`

## Quick Access to Common Commands

The fastest way to access key features is by using the status bar items:

- Click the `$(rocket) The New Fuse` icon in the status bar to open the main UI
- Click the `$(hubot) AI Collaboration` icon to start AI collaboration
- Click the `$(code) AI Coding Team` icon to start collaborative coding

## Opening the Master Command Center

For a complete visual dashboard of all available commands:

1. Open the Command Palette (`Cmd+Shift+P` or `Ctrl+Shift+P`)
2. Type `Open Master Command Center`
3. Press Enter to open the comprehensive command dashboard



==============================================
FILE: ./src/vscode-extension/COMMAND-REFERENCE.md
==============================================

# The New Fuse Command Reference

## Available VS Code Commands

All commands can be accessed via the Command Palette (Cmd+Shift+P or Ctrl+Shift+P):

### Core Commands
- `thefuse.helloWorld` - Basic hello world test
- `thefuse.startAICollab` - Start AI Collaboration

### MCP Commands
- `thefuse.mcp.initialize` - Initialize MCP Integration
- `thefuse.mcp.showTools` - Show MCP Tools
- `thefuse.mcp.testTool` - Test a specific MCP Tool
- `thefuse.mcp.askAgent` - Ask Agent a question using MCP Tools

### Verification Commands
- `thefuse.verification.initialize` - Initialize a verification agent
- `thefuse.verification.verifyClaim` - Verify a claim using a verification agent
- `thefuse.verification.setLevel` - Change the verification level of a verification agent

The verification agent uses LLM-based fact-checking in production mode and simulated verification in development mode. It supports caching of verification results and event-based communication with other components.

## Quick Troubleshooting

If commands don't appear in the Command Palette:
1. Make sure the extension is running in development mode:

   ```bash
   ./launch-vscode.sh
   ```

2. Check the output panel for any errors:
   - View > Output
   - Select "The New Fuse" from the dropdown

3. Try reloading the window:
   - Command Palette > Developer: Reload Window



==============================================
FILE: ./src/vscode-extension/LICENSE
==============================================




==============================================
FILE: ./src/vscode-extension/QUICK-START.md
==============================================

# The New Fuse - Quick Start Guide

## Trying the Inter-Extension Communication Now

1. **Open a new VS Code window** with the extension loaded:
   ```
   node launch-extension.js
   ```
   Or press F5 if you have the `.vscode/launch.json` configured.

2. **Open the example code file**:
   ```
   ./test/example-code.ts
   ```

3. **Try AI Collaboration features**:

   a. **Collaborative Code Analysis**:
      - Select the `findDuplicates` function in the example code
      - Right-click and select "Analyze Code Problem" from the context menu
      - Enter a problem description like "This function is inefficient and needs optimization"
      - Watch as multiple AI agents analyze the code from different perspectives

   b. **Collaborative Coding Task**:
      - Click the "$(code) AI Coding Team" button in the status bar
      - Enter a requirement like "Create a binary search tree implementation in TypeScript"
      - Select "TypeScript" as the language
      - Watch as different AI roles (Architect, Implementer, Tester, etc.) work together

   c. **Inter-Extension Communication**:
      - Open Command Palette (Ctrl+Shift+P or Cmd+Shift+P)
      - Type "Send Message via File Protocol"
      - Select a recipient (agent), enter an action and payload
      - The message will be sent through the file-based communication channel

   d. **Collaborative Completion**:
      - Click the "$(team) Collab: Off" button in the status bar to toggle on
      - Start typing code and see how completions are coordinated between agents

4. **View Available Agents**:
   - Open Command Palette
   - Type "Show AI Agents"
   - See which AI extensions have been detected

## Troubleshooting

- If you don't see AI agents in the list, try running "Discover AI Agents" from the command palette
- If the status bar icons aren't visible, try restarting VS Code with the extension loaded
- Check the "AI Coder Collaboration" and "Collaborative Completion" output channels for logs



==============================================
FILE: ./src/vscode-extension/README.md
==============================================

# The New Fuse VSCode Extension

The New Fuse is an advanced AI assistant with a Copilot-like chat interface for coding, workflow automation, and agent coordination. This VSCode extension provides a comprehensive set of tools for AI-assisted development.

## Features

### Multiple Operational Modes

The New Fuse offers five specialized operational modes, each tailored to different development needs:

- **Orchestrator Mode**: Coordinates multiple AI agents working together on complex tasks
- **Debug Mode**: Provides detailed inspection of agent-to-agent message traffic and tool execution
- **Ask Mode**: Offers a simplified interface for direct queries to specific agents
- **Architect Mode**: Specialized for system design and planning tasks
- **Code Mode**: Focused on code generation, refactoring, and optimization

### Inter-AI Communication

- **Multiple Communication Protocols**:
  - Workspace State Protocol: For extensions in the same VS Code window
  - File Protocol: For cross-window and cross-session communication
  - Command Protocol: For direct, synchronous messaging
  - Message Control Protocol (MCP): For standardized AI agent interactions
- **AI Collaboration**: Coordinate multiple AI agents to work together on tasks
- **Collaborative Code Completion**: Combine suggestions from multiple sources
- **Master Command Center**: Unified interface to control all AI communication
- **AI Coder Integration**: Support specialized AI roles (Architect, Implementer, Tester, etc.)

### MCP Integration

The extension integrates with the Model Context Protocol (MCP) to provide:

- Tool execution capabilities for AI agents
- Agent-to-agent communication
- Workflow automation
- Access to external services and APIs

#### MCP Tools

The extension includes a comprehensive set of MCP tools:

- **File Management Tools**: Read, write, and manipulate files in the workspace
- **Process Management Tools**: Launch, monitor, and control processes
- **Web Interaction Tools**: Search the web, fetch content, and interact with web services
- **Code Analysis Tools**: Analyze code, retrieve information from the codebase, and get diagnostics
- **Integration Tools**: Connect with GitHub, Linear, Jira, Notion, and other services
- **Memory Tools**: Store and retrieve information for long-term context

### Chat Interface

A powerful chat interface similar to GitHub Copilot Chat allows you to:

- Ask questions about your code
- Generate code based on natural language descriptions
- Get explanations of complex code
- Refactor and optimize existing code

## Getting Started

1. **Install the Extension**:
   - Install from the VSCode Marketplace or use the VSIX file

2. **Open The New Fuse Sidebar**:
   - Click the fusion icon in the activity bar
   - Or use the Command Palette: `View -> The New Fuse`

3. **Select Your Mode**:
   - Click on the mode indicator in the status bar
   - Or use the Command Palette: `The New Fuse: Select Mode`
   - Choose between Orchestrator, Debug, Ask, Architect, and Code modes

4. **Start Using The New Fuse**:
   - Use the chat interface to interact with AI agents
   - Use the specialized views for each mode
   - Execute commands from the Command Palette

## Communication Protocols

The New Fuse supports multiple ways for AI extensions to communicate:

### Workspace State Protocol

- Uses VS Code's built-in storage for message passing
- Ideal for extensions in the same VS Code window
- Low overhead, simple implementation

### File Protocol

- Uses files in a shared workspace folder for communication
- Works across VS Code windows and sessions
- Supports large message payloads
- Messages persist between sessions

### Command Protocol

- Uses VS Code's command API for direct communication
- Synchronous, immediate execution
- Best for simple interactions

### Message Control Protocol (MCP)

- Advanced protocol for standardized AI agent communication
- Supports auto-discovery of capabilities
- Enables autonomous agent interaction

## Commands

The extension provides the following commands:

- `The New Fuse: Select Mode` - Choose between Orchestrator, Debug, Ask, Architect, and Code modes
- `The New Fuse: Open Dashboard` - Open the main dashboard
- `The New Fuse: Open Chat` - Open the chat interface
- `The New Fuse: Open Chat Panel` - Open the chat in a panel view
- `The New Fuse: Start New Chat` - Start a new chat session
- `The New Fuse: Clear Chat` - Clear the current chat
- `The New Fuse: Open Settings` - Open extension settings
- `The New Fuse: Initialize MCP Integration` - Set up MCP integration
- `The New Fuse: Show MCP Tools` - Display available MCP tools
- `The New Fuse: Test MCP Tool` - Test a specific MCP tool with custom parameters
- `The New Fuse: Ask Agent with MCP Tools` - Send a query to an agent with MCP tools
- `The New Fuse: Browse MCP Server Marketplace` - Browse available MCP servers
- `The New Fuse: Add MCP Server from Marketplace` - Add a new MCP server from the marketplace
- `The New Fuse: Open MCP Command Palette` - Open a command palette for MCP operations

## Requirements

- VS Code 1.80.0 or higher
- Node.js 18 or higher (for running the AI agent server)

## Extension Settings

This extension contributes the following settings:

- `theFuse.currentMode`: Current operational mode (orchestrator, debug, ask, architect, code)
- `theFuse.mcpConfigPath`: Path to the MCP configuration file
- `theFuse.autoInitializeMcp`: Automatically initialize MCP integration on startup
- `theFuse.mcpMarketplaceUrl`: URL of the MCP Marketplace API
- `theFuse.agentServerUrl`: URL of the SAAS platform server
- `theFuse.enableChat`: Enable The New Fuse chat interface
- `theFuse.llmProvider`: LLM provider to use (vscode, openai, anthropic, ollama, custom)

## Advanced Usage

### AI Coding Team

Access specialized AI coding roles:

The New Fuse can coordinate multiple AI agents with specialized roles:

- **Architect**: Designs high-level structure and system architecture
- **Implementer**: Writes actual code based on the architect's design
- **Tester**: Creates unit and integration tests for the code
- **Reviewer**: Reviews code quality and suggests improvements
- **Optimizer**: Improves performance and optimizes resource usage
- **Documentation Writer**: Creates documentation for the code

To start a collaborative coding session:

1. Open the Command Palette
2. Choose `The New Fuse: Start Collaborative Coding`
3. Define your requirements in the input field

### Developing New AI Extensions

If you're developing a new AI extension that should communicate with The New Fuse, follow these steps:

#### Register your extension as an agent

```typescript
// In your extension's activate function:
const vscode = require('vscode');

// Register your extension by executing this command:
await vscode.commands.executeCommand('thefuse.registerAgent', {
  id: 'your-extension-id',
  name: 'Your Extension Name',
  capabilities: ['your-capability-1', 'your-capability-2'],
  version: '1.0.0'
});
```

#### Send messages to other agents

```typescript
// Send a message to another agent:
await vscode.commands.executeCommand('thefuse.sendMessage',
  'recipient-id',    // The recipient's ID
  'action-name',     // The action to perform
  { /* payload */ }  // The message payload
);
```

#### Receive messages

```typescript
// Register a handler for incoming messages:
await vscode.commands.executeCommand('thefuse.registerMessageHandler',
  (message) => {
    const { sender, action, payload } = message;
    // Process the message...
  }
);
```

## Keyboard Shortcuts

- `Ctrl+Alt+C` (`Cmd+Alt+C` on macOS): Open The New Fuse Chat
- `Ctrl+Alt+Shift+C` (`Cmd+Alt+Shift+C` on macOS): Open The New Fuse Chat Panel
- `Ctrl+Alt+M` (`Cmd+Alt+M` on macOS): Browse MCP Marketplace

## Troubleshooting

If you don't see The New Fuse commands in the Command Palette:

1. Try reloading the VS Code window:
   - Open Command Palette (`Cmd+Shift+P` or `Ctrl+Shift+P`)
   - Type "Developer: Reload Window" and press Enter

2. Check the status bar at the bottom of VS Code:
   - You should see The New Fuse icon and mode indicator
   - Click on these to access key features

3. Launch with the quick-start script:

```bash
cd /path/to/The\ New\ Fuse/src/vscode-extension
./quick-launch.sh
```

## License

MIT



==============================================
FILE: ./src/vscode-extension/TROUBLESHOOTING-COMMANDS.md
==============================================

# Troubleshooting Missing Commands

If you don't see The New Fuse commands in your Command Palette, follow these steps:

## 1. Verify Extension Activation

The extension must be properly activated before commands appear:

1. Open VS Code's **Output panel** (View > Output)
2. Select "The New Fuse" from the dropdown menu
3. Check for "Extension activated" message
4. If you don't see this, the extension hasn't loaded correctly

## 2. Force Extension Activation

Run these steps to ensure the extension activates:

1. Close VS Code completely
2. Open terminal and navigate to your extension directory:
   ```bash
   cd /Users/danielgoldberg/Desktop/A1-Inter-LLM-Com/The\ New\ Fuse/src/vscode-extension
   ```
3. Run the direct launch script:
   ```bash
   ./quick-launch.sh
   ```
   Or manually launch:
   ```bash
   code --extensionDevelopmentPath="$(pwd)"
   ```

## 3. Manually Register Commands

If commands still don't appear, you can force-register them:

1. Open VS Code's built-in terminal (Terminal > New Terminal)
2. Run this command to activate The New Fuse:
   ```javascript
   vscode.commands.executeCommand('workbench.action.reloadWindow')
   ```
3. After reload, check the Command Palette again

## 4. Check Extension Logs

1. Open VS Code's Developer Tools:
   - macOS: ⌘⇧I (Cmd+Shift+I)
   - Windows/Linux: Ctrl+Shift+I
2. Look for errors related to The New Fuse extension
3. Error messages will help identify what's preventing activation

## 5. Common Issues

- **Missing Dependencies**: Ensure `npm install` completed successfully
- **Compilation Errors**: Check if TypeScript compiled correctly
- **Activation Events**: Ensure your package.json has correct activation events
- **Command Registration**: Commands must be properly registered in extension.ts



==============================================
FILE: ./src/vscode-extension/TROUBLESHOOTING.md
==============================================

# Troubleshooting Guide - The New Fuse Extension

## Common Network Errors

### HTTP2 Protocol Error (net::ERR_HTTP2_PROTOCOL_ERROR)

If you encounter the error:



==============================================
FILE: ./src/vscode-extension/agent-adapter.tsx
==============================================

/**
 * Agent Adapter Module
 * 
 * This module provides adapters for integrating with specific VS Code AI extensions,
 * allowing them to participate in The New Fuse's inter-extension communication system.
 */

import * as vscode from 'vscode';
import { AgentClient, AgentMessage } from './agent-communication';

// Interface for extension-specific adapters
export interface ExtensionAdapter {
  id: string;
  name: string;
  extensionId: string;
  capabilities: string[];
  isActive: boolean;
  sendMessage(action: string, payload: any): Promise<any>;
}

/**
 * Adapter for GitHub Copilot
 */
export class CopilotAdapter implements ExtensionAdapter {
  id = 'github.copilot';
  name = 'GitHub Copilot';
  extensionId = 'GitHub.copilot';
  capabilities = ['code-completion', 'code-generation'];
  isActive = true;
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private initialized = false;
  private commandMap = {
    'generateCode': 'github.copilot.generate',
    'explainCode': 'github.copilot.explain',
    'completions': 'github.copilot.provideInlineCompletions'
  };
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient) {
    this.context = context;
    this.agentClient = agentClient;
  }
  
  async isAvailable(): Promise<boolean> {
    const commands = await vscode.commands.getCommands(true);
    return commands.includes(this.commandMap.generateCode);
  }
  
  async initialize(): Promise<boolean> {
    if (this.initialized) return true;
    
    try {
      // Register this adapter as an agent
      const registered = await this.agentClient.register(
        this.name,
        ['code-generation', 'code-explanation', 'code-completion'],
        '1.0.0'
      );
      
      if (registered) {
        // Subscribe to receive messages
        await this.agentClient.subscribe(this.handleAgentMessage.bind(this));
        this.initialized = true;
        return true;
      }
      
      return false;
    } catch (error) {
      console.error(`Failed to initialize ${this.name} adapter:`, error);
      return false;
    }
  }
  
  async executeCommand(action: string, input: any): Promise<any> {
    const commandId = this.commandMap[action];
    if (!commandId) {
      throw new Error(`Unsupported action: ${action}`);
    }
    
    // Adapt input to the format expected by Copilot
    const adaptedInput = this.adaptInput(action, input);
    
    // Execute the command
    return vscode.commands.executeCommand(commandId, adaptedInput);
  }
  
  private adaptInput(action: string, input: any): any {
    switch (action) {
      case 'generateCode':
        return {
          prompt: input.prompt,
          context: input.context,
          language: input.language
        };
        
      case 'explainCode':
        return {
          code: input.code,
          language: input.language
        };
        
      case 'completions':
        return input; // Pass through as is
        
      default:
        return input;
    }
  }
  
  private async handleAgentMessage(message: AgentMessage): Promise<void> {
    if (message.recipient !== this.id) return;
    
    try {
      let response;
      
      switch (message.action) {
        case 'generateCode':
        case 'explainCode':
        case 'completions':
          response = await this.executeCommand(message.action, message.payload);
          break;
          
        default:
          throw new Error(`Unsupported action: ${message.action}`);
      }
      
      // Send response back to sender
      await this.agentClient.sendMessage(
        message.sender,
        `${message.action}Response`,
        {
          requestId: message.id,
          result: response,
          success: true
        }
      );
    } catch (error) {
      // Send error response
      await this.agentClient.sendMessage(
        message.sender,
        `${message.action}Response`,
        {
          requestId: message.id,
          error: error.message,
          success: false
        }
      );
    }
  }
  
  dispose(): void {
    // Nothing to dispose
  }
}

/**
 * Adapter for Claude extension
 */
export class ClaudeAdapter implements ExtensionAdapter {
  id = 'anthropic.claude';
  name = 'Claude';
  extensionId = 'anthropic.claude';
  capabilities = ['text-generation', 'code-explanation'];
  isActive = true;
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private initialized = false;
  private commandMap = {
    'generateText': 'anthropic.claude.generate',
    'completions': 'anthropic.claude.completions'
  };
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient) {
    this.context = context;
    this.agentClient = agentClient;
  }
  
  async isAvailable(): Promise<boolean> {
    const commands = await vscode.commands.getCommands(true);
    return commands.includes(this.commandMap.generateText);
  }
  
  async initialize(): Promise<boolean> {
    if (this.initialized) return true;
    
    try {
      // Register this adapter as an agent
      const registered = await this.agentClient.register(
        this.name,
        ['text-generation', 'code-generation', 'code-explanation'],
        '1.0.0'
      );
      
      if (registered) {
        // Subscribe to receive messages
        await this.agentClient.subscribe(this.handleAgentMessage.bind(this));
        this.initialized = true;
        return true;
      }
      
      return false;
    } catch (error) {
      console.error(`Failed to initialize ${this.name} adapter:`, error);
      return false;
    }
  }
  
  async executeCommand(action: string, input: any): Promise<any> {
    const commandId = this.commandMap[action];
    if (!commandId) {
      throw new Error(`Unsupported action: ${action}`);
    }
    
    // Adapt input to the format expected by Claude
    const adaptedInput = this.adaptInput(action, input);
    
    // Execute the command
    return vscode.commands.executeCommand(commandId, adaptedInput);
  }
  
  private adaptInput(action: string, input: any): any {
    switch (action) {
      case 'generateText':
        return {
          prompt: input.prompt,
          system: input.systemPrompt,
          maxTokens: input.maxTokens,
          temperature: input.temperature,
          model: input.model || 'claude-2.0'
        };
        
      case 'completions':
        return input; // Pass through as is
        
      default:
        return input;
    }
  }
  
  private async handleAgentMessage(message: AgentMessage): Promise<void> {
    if (message.recipient !== this.id) return;
    
    try {
      let response;
      
      switch (message.action) {
        case 'generateText':
        case 'completions':
          response = await this.executeCommand(message.action, message.payload);
          break;
          
        default:
          throw new Error(`Unsupported action: ${message.action}`);
      }
      
      // Send response back to sender
      await this.agentClient.sendMessage(
        message.sender,
        `${message.action}Response`,
        {
          requestId: message.id,
          result: response,
          success: true
        }
      );
    } catch (error) {
      // Send error response
      await this.agentClient.sendMessage(
        message.sender,
        `${message.action}Response`,
        {
          requestId: message.id,
          error: error.message,
          success: false
        }
      );
    }
  }
  
  dispose(): void {
    // Nothing to dispose
  }
}

/**
 * AgentAdapterManager manages all the extension adapters
 */
export class AgentAdapterManager {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private adapters: Map<string, ExtensionAdapter> = new Map();
  private outputChannel: vscode.OutputChannel;
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient, outputChannel: vscode.OutputChannel) {
    this.context = context;
    this.agentClient = agentClient;
    this.outputChannel = outputChannel;
  }
  
  /**
   * Initialize the adapter manager and discover extensions
   */
  async initialize(): Promise<void> {
    // Set up listeners for extension changes
    vscode.extensions.onDidChange(() => this.detectExtensions());
    
    // Discover extensions
    await this.detectExtensions();
    
    // Listen for adapter messages
    this.agentClient.subscribe(this.handleAdapterMessage.bind(this));
    
    this.log('Agent Adapter Manager initialized');
  }
  
  /**
   * Get available adapters
   */
  getAvailableAdapters(): ExtensionAdapter[] {
    return Array.from(this.adapters.values());
  }
  
  /**
   * Get adapter by ID
   */
  getAdapter(id: string): ExtensionAdapter | undefined {
    return this.adapters.get(id);
  }
  
  /**
   * Handle messages directed to adapters
   */
  private async handleAdapterMessage(message: any): Promise<void> {
    // Check if this is a message for an adapter
    if (message.action === 'adapter.register') {
      await this.registerAdapter(message.payload);
    } else if (message.action === 'adapter.message') {
      await this.routeMessageToAdapter(message.payload);
    }
  }
  
  /**
   * Register an adapter from a registration message
   */
  private async registerAdapter(registration: any): Promise<void> {
    try {
      if (!registration.id || !registration.name || !registration.extensionId) {
        this.log(`Invalid adapter registration: missing required fields`);
        return;
      }
      
      const adapter: ExtensionAdapter = {
        id: registration.id,
        name: registration.name,
        extensionId: registration.extensionId,
        capabilities: registration.capabilities || [],
        isActive: true,
        
        // Method to send messages to this adapter
        sendMessage: async (action: string, payload: any): Promise<any> => {
          return this.agentClient.sendMessage(registration.id, action, payload);
        }
      };
      
      this.adapters.set(registration.id, adapter);
      this.log(`Registered adapter: ${registration.name} (${registration.id})`);
      
      // Send acknowledgement
      await this.agentClient.sendMessage(registration.id, 'adapter.registered', {
        success: true,
        timestamp: Date.now()
      });
    } catch (error) {
      this.log(`Error registering adapter: ${error.message}`);
    }
  }
  
  /**
   * Route a message to an adapter
   */
  private async routeMessageToAdapter(message: any): Promise<void> {
    try {
      const { targetId, action, payload } = message;
      
      if (!targetId || !action) {
        this.log(`Invalid adapter message: missing required fields`);
        return;
      }
      
      const adapter = this.adapters.get(targetId);
      if (!adapter) {
        this.log(`Adapter not found: ${targetId}`);
        return;
      }
      
      // Send the message to the adapter
      await adapter.sendMessage(action, payload);
      this.log(`Routed message to adapter ${targetId}: ${action}`);
    } catch (error) {
      this.log(`Error routing adapter message: ${error.message}`);
    }
  }
  
  /**
   * Detect installed AI extensions and create adapters
   */
  private async detectExtensions(): Promise<void> {
    try {
      // List of known AI extensions with their adapter configurations
      const knownExtensions = [
        {
          extensionId: 'GitHub.copilot',
          adapterId: 'github.copilot',
          name: 'GitHub Copilot',
          capabilities: ['code-completion', 'code-generation']
        },
        {
          extensionId: 'anthropic.claude',
          adapterId: 'anthropic.claude',
          name: 'Claude',
          capabilities: ['text-generation', 'code-explanation']
        },
        {
          extensionId: 'openai.gpt',
          adapterId: 'openai.gpt',
          name: 'OpenAI GPT',
          capabilities: ['text-generation', 'image-generation']
        }
      ];
      
      // Create adapters for installed extensions
      let detectedCount = 0;
      
      for (const extConfig of knownExtensions) {
        const extension = vscode.extensions.getExtension(extConfig.extensionId);
        
        if (extension) {
          // Create adapter if it doesn't exist yet
          if (!this.adapters.has(extConfig.adapterId)) {
            const adapter: ExtensionAdapter = {
              id: extConfig.adapterId,
              name: extConfig.name,
              extensionId: extConfig.extensionId,
              capabilities: extConfig.capabilities,
              isActive: extension.isActive,
              
              sendMessage: async (action: string, payload: any): Promise<any> => {
                // Use the extension's exports if available
                if (extension.isActive && extension.exports && typeof extension.exports.receiveMessage === 'function') {
                  return extension.exports.receiveMessage(action, payload);
                }
                
                // Otherwise use commands if available
                try {
                  return await vscode.commands.executeCommand(`${extConfig.adapterId}.receiveMessage`, action, payload);
                } catch (error) {
                  this.log(`Error sending message to ${extConfig.name}: ${error.message}`);
                  return null;
                }
              }
            };
            
            this.adapters.set(extConfig.adapterId, adapter);
            detectedCount++;
            
            this.log(`Detected AI extension: ${extConfig.name}`);
          } else {
            // Update active status for existing adapter
            const adapter = this.adapters.get(extConfig.adapterId);
            if (adapter) {
              adapter.isActive = extension.isActive;
            }
          }
        }
      }
      
      if (detectedCount > 0) {
        this.log(`Detected ${detectedCount} AI extensions`);
      }
    } catch (error) {
      this.log(`Error detecting extensions: ${error.message}`);
    }
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    this.outputChannel.appendLine(`[Agent Adapter] ${message}`);
  }
  
  /**
   * Dispose of resources
   */
  dispose(): void {
    // Nothing to dispose for now
  }
}

/**
 * Factory function to create an agent adapter manager
 */
export function createAgentAdapterManager(
  context: vscode.ExtensionContext,
  agentClient: AgentClient,
  outputChannel: vscode.OutputChannel
): AgentAdapterManager {
  return new AgentAdapterManager(context, agentClient, outputChannel);
}



==============================================
FILE: ./src/vscode-extension/agent-communication-simple.tsx
==============================================

/**
 * Simplified Agent Communication Module
 * 
 * This is a basic implementation to get started quickly.
 */

import * as vscode from 'vscode';
import * as crypto from 'crypto';

export interface AgentMessage {
  id: string;
  sender: string;
  recipient: string;
  action: string;
  payload: any;
  timestamp: number;
}

export class AgentClient {
  private context: vscode.ExtensionContext;
  private agentId: string;
  private messageCallbacks: ((message: AgentMessage) => Promise<void>)[] = [];
  
  constructor(context: vscode.ExtensionContext, agentId: string) {
    this.context = context;
    this.agentId = agentId;
    
    // Set up polling for workspace state messages
    setInterval(() => this.checkForMessages(), 1000);
  }
  
  // Register this agent
  async register(name: string, capabilities: string[], version: string): Promise<boolean> {
    // Store registration in workspace state
    const registrations = this.context.workspaceState.get<any[]>('thefuse.agentRegistrations', []);
    registrations.push({
      id: this.agentId,
      name,
      capabilities,
      version,
      timestamp: Date.now()
    });
    await this.context.workspaceState.update('thefuse.agentRegistrations', registrations);
    return true;
  }
  
  // Send a message to another agent
  async sendMessage(recipient: string, action: string, payload: any): Promise<boolean> {
    const message: AgentMessage = {
      id: crypto.randomUUID(),
      sender: this.agentId,
      recipient,
      action,
      payload,
      timestamp: Date.now()
    };
    
    // Add message to workspace state
    const messages = this.context.workspaceState.get<AgentMessage[]>('thefuse.messages', []);
    messages.push(message);
    await this.context.workspaceState.update('thefuse.messages', messages);
    return true;
  }
  
  // Broadcast a message to all agents
  async broadcast(action: string, payload: any): Promise<boolean> {
    return this.sendMessage('*', action, payload);
  }
  
  // Subscribe to receive messages
  async subscribe(callback: (message: AgentMessage) => Promise<void>): Promise<boolean> {
    this.messageCallbacks.push(callback);
    return true;
  }
  
  // Check for new messages
  private async checkForMessages(): Promise<void> {
    const messages = this.context.workspaceState.get<AgentMessage[]>('thefuse.messages', []);
    if (messages.length === 0) return;
    
    // Find messages for this agent
    const myMessages = messages.filter(m => 
      m.recipient === this.agentId || 
      m.recipient === '*'
    );
    
    if (myMessages.length === 0) return;
    
    // Process messages
    for (const message of myMessages) {
      for (const callback of this.messageCallbacks) {
        await callback(message);
      }
    }
    
    // Remove processed messages
    const remainingMessages = messages.filter(m => 
      m.recipient !== this.agentId && 
      m.recipient !== '*'
    );
    await this.context.workspaceState.update('thefuse.messages', remainingMessages);
  }
}

// Export factory functions
export function initializeOrchestrator(context: vscode.ExtensionContext): any {
  // Simple placeholder for the full orchestrator
  return {
    getRegisteredAgents: () => {
      return context.workspaceState.get<any[]>('thefuse.agentRegistrations', []);
    }
  };
}

export function createAgentClient(context: vscode.ExtensionContext, agentId: string): AgentClient {
  return new AgentClient(context, agentId);
}



==============================================
FILE: ./src/vscode-extension/agent-communication.tsx
==============================================

/**
 * Agent Communication Module
 * 
 * This module provides the core functionality for inter-extension communication
 * between AI agents in The New Fuse platform.
 */

import * as vscode from 'vscode';
import * as crypto from 'crypto';

// Message types for type safety
export interface AgentMessage {
  id: string;
  sender: string;
  recipient: string;
  action: string;
  payload: any;
  timestamp: number;
  signature?: string;
}

export interface AgentRegistration {
  id: string;
  name: string;
  capabilities: string[];
  version: string;
  apiVersion: string;
}

// Security utilities
export class SecurityManager {
  private secretKey: string;
  
  constructor(context: vscode.ExtensionContext) {
    // Get or generate a secret key for message signing
    let key = context.globalState.get<string>('thefuse.secretKey');
    if (!key) {
      key = crypto.randomBytes(32).toString('hex');
      context.globalState.update('thefuse.secretKey', key);
    }
    this.secretKey = key;
  }
  
  // Sign a message to verify its authenticity
  signMessage(message: Omit<AgentMessage, 'signature'>): string {
    const hmac = crypto.createHmac('sha256', this.secretKey);
    hmac.update(JSON.stringify({
      id: message.id,
      sender: message.sender,
      recipient: message.recipient,
      action: message.action,
      payload: message.payload,
      timestamp: message.timestamp
    }));
    return hmac.digest('hex');
  }
  
  // Verify a message's signature
  verifyMessage(message: AgentMessage): boolean {
    if (!message.signature) return false;
    
    const expectedSignature = this.signMessage({
      id: message.id,
      sender: message.sender,
      recipient: message.recipient,
      action: message.action,
      payload: message.payload,
      timestamp: message.timestamp
    });
    
    return crypto.timingSafeEqual(
      Buffer.from(message.signature, 'hex'),
      Buffer.from(expectedSignature, 'hex')
    );
  }
}

// Central orchestrator for agent communication
export class AgentOrchestrator {
  private registeredAgents: Map<string, AgentRegistration> = new Map();
  private messageCallbacks: Map<string, ((message: AgentMessage) => Promise<void>)[]> = new Map();
  private securityManager: SecurityManager;
  private context: vscode.ExtensionContext;
  private disposed = false;
  
  constructor(context: vscode.ExtensionContext) {
    this.context = context;
    this.securityManager = new SecurityManager(context);
    
    // Restore registered agents from persistent storage
    const savedAgents = context.globalState.get<AgentRegistration[]>('thefuse.registeredAgents', []);
    savedAgents.forEach(agent => {
      this.registeredAgents.set(agent.id, agent);
    });
    
    // Set up command-based communication channel
    const registerCommand = vscode.commands.registerCommand(
      'thefuse.orchestrator.register',
      (agentInfo: AgentRegistration) => this.registerAgent(agentInfo)
    );
    
    const sendMessageCommand = vscode.commands.registerCommand(
      'thefuse.orchestrator.sendMessage',
      (message: Omit<AgentMessage, 'id' | 'timestamp' | 'signature'>) => 
        this.sendMessage(message)
    );
    
    const subscribeCommand = vscode.commands.registerCommand(
      'thefuse.orchestrator.subscribe',
      (agentId: string, callback: (message: AgentMessage) => Promise<void>) => 
        this.subscribe(agentId, callback)
    );
    
    const unsubscribeCommand = vscode.commands.registerCommand(
      'thefuse.orchestrator.unsubscribe',
      (agentId: string) => this.unsubscribe(agentId)
    );
    
    // Set up workspace state monitoring for indirect communication
    const stateMonitor = setInterval(() => {
      if (this.disposed) return;
      
      const messageQueue = this.context.workspaceState.get<AgentMessage[]>(
        'thefuse.messageQueue', 
        []
      );
      
      if (messageQueue.length > 0) {
        // Process pending messages
        const processedIds: string[] = [];
        
        messageQueue.forEach(message => {
          if (this.securityManager.verifyMessage(message)) {
            this.routeMessage(message);
            processedIds.push(message.id);
          } else {
            console.warn(`Invalid message signature: ${message.id}`);
            processedIds.push(message.id);
          }
        });
        
        // Remove processed messages
        const updatedQueue = messageQueue.filter(msg => !processedIds.includes(msg.id));
        this.context.workspaceState.update('thefuse.messageQueue', updatedQueue);
      }
    }, 1000);
    
    // Register disposables
    context.subscriptions.push(
      registerCommand,
      sendMessageCommand,
      subscribeCommand,
      unsubscribeCommand,
      { dispose: () => {
          clearInterval(stateMonitor);
          this.disposed = true;
        }
      }
    );
  }
  
  // Register an AI agent with the orchestrator
  async registerAgent(agentInfo: AgentRegistration): Promise<boolean> {
    // Validate the registration
    if (!agentInfo.id || !agentInfo.name || !agentInfo.capabilities) {
      return false;
    }
    
    // Store the registration
    this.registeredAgents.set(agentInfo.id, agentInfo);
    
    // Persist registrations
    await this.context.globalState.update(
      'thefuse.registeredAgents', 
      Array.from(this.registeredAgents.values())
    );
    
    // Initialize message callback array if needed
    if (!this.messageCallbacks.has(agentInfo.id)) {
      this.messageCallbacks.set(agentInfo.id, []);
    }
    
    return true;
  }
  
  // Send a message between AI agents
  async sendMessage(messageData: Omit<AgentMessage, 'id' | 'timestamp' | 'signature'>): Promise<{ success: boolean, messageId?: string }> {
    // Validate sender is registered
    if (!this.registeredAgents.has(messageData.sender)) {
      return { success: false };
    }
    
    // Create the full message
    const message: Omit<AgentMessage, 'signature'> = {
      id: crypto.randomUUID(),
      ...messageData,
      timestamp: Date.now()
    };
    
    // Sign the message
    const signature = this.securityManager.signMessage(message);
    const signedMessage: AgentMessage = { ...message, signature };
    
    // Try direct routing first
    const directSuccess = await this.routeMessage(signedMessage);
    
    if (!directSuccess) {
      // Fall back to workspace state for asynchronous delivery
      const messageQueue = this.context.workspaceState.get<AgentMessage[]>(
        'thefuse.messageQueue', 
        []
      );
      
      messageQueue.push(signedMessage);
      await this.context.workspaceState.update('thefuse.messageQueue', messageQueue);
    }
    
    return { success: true, messageId: message.id };
  }
  
  // Route a message to its recipient
  private async routeMessage(message: AgentMessage): Promise<boolean> {
    // Handle broadcast messages
    if (message.recipient === '*') {
      let success = false;
      
      for (const [agentId, callbacks] of this.messageCallbacks.entries()) {
        if (agentId !== message.sender) { // Don't send to self
          for (const callback of callbacks) {
            try {
              await callback(message);
              success = true;
            } catch (error) {
              console.error(`Error delivering message to ${agentId}:`, error);
            }
          }
        }
      }
      
      return success;
    }
    
    // Handle direct messages
    const callbacks = this.messageCallbacks.get(message.recipient);
    if (!callbacks || callbacks.length === 0) {
      return false;
    }
    
    let success = false;
    for (const callback of callbacks) {
      try {
        await callback(message);
        success = true;
      } catch (error) {
        console.error(`Error delivering message to ${message.recipient}:`, error);
      }
    }
    
    return success;
  }
  
  // Subscribe to receive messages
  subscribe(agentId: string, callback: (message: AgentMessage) => Promise<void>): boolean {
    if (!this.registeredAgents.has(agentId)) {
      return false;
    }
    
    if (!this.messageCallbacks.has(agentId)) {
      this.messageCallbacks.set(agentId, []);
    }
    
    this.messageCallbacks.get(agentId).push(callback);
    return true;
  }
  
  // Unsubscribe from messages
  unsubscribe(agentId: string): boolean {
    if (!this.messageCallbacks.has(agentId)) {
      return false;
    }
    
    this.messageCallbacks.delete(agentId);
    return true;
  }
  
  // Get information about registered agents
  getRegisteredAgents(): AgentRegistration[] {
    return Array.from(this.registeredAgents.values());
  }
}

// Client for AI agents to use
export class AgentClient {
  private context: vscode.ExtensionContext;
  private agentId: string;
  private registered = false;
  private messageCallbacks: ((message: AgentMessage) => Promise<void>)[] = [];
  private pendingResponses: Map<string, { resolve: Function, reject: Function, timeout: NodeJS.Timeout }> = new Map();
  private outputChannel: vscode.OutputChannel;
  
  constructor(context: vscode.ExtensionContext, agentId: string, outputChannel: vscode.OutputChannel) {
    this.context = context;
    this.agentId = agentId;
    this.outputChannel = outputChannel;
    
    // Set up polling for workspace state messages
    setInterval(() => this.checkForMessages(), 1000);
  }
  
  // Register this agent with the orchestrator
  async register(name: string, capabilities: string[], version: string): Promise<boolean> {
    try {
      const registration: AgentRegistration = {
        id: this.agentId,
        name,
        capabilities,
        version,
        apiVersion: '1.0'
      };
      
      this.registered = await vscode.commands.executeCommand(
        'thefuse.orchestrator.register',
        registration
      );
      
      return this.registered;
    } catch (error) {
      console.error('Failed to register agent:', error);
      return false;
    }
  }
  
  // Send a message to another agent
  async sendMessage(recipient: string, action: string, payload: any): Promise<boolean> {
    if (!this.registered) {
      throw new Error('Agent not registered');
    }
    
    try {
      const result = await vscode.commands.executeCommand(
        'thefuse.orchestrator.sendMessage',
        {
          sender: this.agentId,
          recipient,
          action,
          payload
        }
      );
      
      return result?.success || false;
    } catch (error) {
      console.error('Failed to send message:', error);
      return false;
    }
  }
  
  // Broadcast a message to all agents
  async broadcast(action: string, payload: any): Promise<boolean> {
    return this.sendMessage('*', action, payload);
  }
  
  // Subscribe to receive messages
  async subscribe(callback: (message: AgentMessage) => Promise<void>): Promise<boolean> {
    if (!this.registered) {
      throw new Error('Agent not registered');
    }
    
    try {
      return await vscode.commands.executeCommand(
        'thefuse.orchestrator.subscribe',
        this.agentId,
        callback
      );
    } catch (error) {
      console.error('Failed to subscribe:', error);
      return false;
    }
  }
  
  // Unsubscribe from messages
  async unsubscribe(): Promise<boolean> {
    if (!this.registered) {
      return true; // Already not receiving messages
    }
    
    try {
      return await vscode.commands.executeCommand(
        'thefuse.orchestrator.unsubscribe',
        this.agentId
      );
    } catch (error) {
      console.error('Failed to unsubscribe:', error);
      return false;
    }
  }

  // Send a message and wait for a response
  async sendRequestAndWaitForResponse(recipient: string, action: string, payload: any, timeoutMs = 5000): Promise<any> {
    try {
      const requestId = crypto.randomUUID();
      const responseAction = `${action}Response`;
      
      // Create a message with requestId in the payload
      const message: AgentMessage = {
        id: requestId,
        sender: this.agentId,
        recipient,
        action,
        payload: { ...payload, requestId },
        timestamp: Date.now()
      };
      
      // Add message to workspace state
      const messages = this.context.workspaceState.get<AgentMessage[]>('thefuse.messages', []);
      messages.push(message);
      await this.context.workspaceState.update('thefuse.messages', messages);
      
      this.log(`Sent request to ${recipient}: ${action} (ID: ${requestId})`);
      
      // Create a promise that will resolve when the response arrives
      return new Promise((resolve, reject) => {
        // Set up a timeout to reject the promise if no response arrives
        const timeout = setTimeout(() => {
          this.pendingResponses.delete(requestId);
          reject(new Error(`Request timed out after ${timeoutMs}ms`));
        }, timeoutMs);
        
        // Store the pending response handlers
        this.pendingResponses.set(requestId, { resolve, reject, timeout });
      });
    } catch (error) {
      this.log(`Error sending request: ${error.message}`);
      throw error;
    }
  }

  // Check for new messages in the workspace state
  private async checkForMessages(): Promise<void> {
    try {
      const messages = this.context.workspaceState.get<AgentMessage[]>('thefuse.messages', []);
      if (messages.length === 0) return;
      
      // Find messages for this agent
      const myMessages = messages.filter(m => 
        m.recipient === this.agentId || 
        m.recipient === '*'
      );
      
      if (myMessages.length === 0) return;
      
      // Find remaining messages (those we're not processing)
      const remainingMessages = messages.filter(m => 
        !myMessages.some(mm => mm.id === m.id)
      );
      
      // Update the workspace state with remaining messages
      await this.context.workspaceState.update('thefuse.messages', remainingMessages);
      
      // Process messages
      for (const message of myMessages) {
        this.log(`Received message from ${message.sender}: ${message.action}`);
        
        // Check if this is a response to a pending request
        if (message.action.endsWith('Response') && message.payload && message.payload.requestId) {
          const requestId = message.payload.requestId;
          const pendingResponse = this.pendingResponses.get(requestId);
          
          if (pendingResponse) {
            // Clear the timeout and delete from pending responses
            clearTimeout(pendingResponse.timeout);
            this.pendingResponses.delete(requestId);
            
            // Resolve the promise with the response payload
            pendingResponse.resolve(message.payload);
            continue; // Skip the normal message processing
          }
        }
        
        // Process message with all registered callbacks
        for (const callback of this.messageCallbacks) {
          await callback(message);
        }
      }
    } catch (error) {
      this.log(`Error checking messages: ${error.message}`);
    }
  }

  // Get registered agents
  async getRegisteredAgents(): Promise<any[]> {
    return this.context.workspaceState.get<any[]>('thefuse.agentRegistrations', []);
  }
  
  // Log a message to the output channel
  private log(message: string): void {
    this.outputChannel.appendLine(`[Agent ${this.agentId}] ${message}`);
  }
}

// Export a function to initialize the orchestrator
export function initializeOrchestrator(context: vscode.ExtensionContext): any {
  return {
    getRegisteredAgents: () => {
      return context.workspaceState.get<any[]>('thefuse.agentRegistrations', []);
    },
    
    getAgentCapabilities: (agentId: string) => {
      const registrations = context.workspaceState.get<any[]>('thefuse.agentRegistrations', []);
      const agent = registrations.find(reg => reg.id === agentId);
      return agent ? agent.capabilities : [];
    }
  };
}

// Export a function to create an agent client
export function createAgentClient(
  context: vscode.ExtensionContext,
  agentId: string,
  outputChannel: vscode.OutputChannel
): AgentClient {
  return new AgentClient(context, agentId, outputChannel);
}



==============================================
FILE: ./src/vscode-extension/ai-coder-integration.ts
==============================================

/**
 * AI Coder Integration Module
 * 
 * This module demonstrates how multiple AI coding assistants can collaborate
 * using The New Fuse's inter-extension communication system.
 */

/* global setTimeout */
/* eslint-disable no-case-declarations */
import * as vscode from 'vscode';
import { AgentClient } from './agent-communication';
import { LMAPIBridge } from './lm-api-bridge';

// Define roles for specialized AI coders
export enum AICoderRole {
  Architect = 'architect',
  Implementer = 'implementer',
  Tester = 'tester',
  Reviewer = 'reviewer',
  Optimizer = 'optimizer',
  DocumentationWriter = 'documentationWriter',
}

interface AICoderSpecs {
  role: AICoderRole;
  capabilities: string[];
  specialization?: string;
  preferredLanguages?: string[];
  systemPrompt: string;
}

interface AICoderRequest {
  id: string;
  role: AICoderRole;
  task: string;
  context: {
    code?: string;
    requirements?: string;
    language?: string;
    constraints?: string[];
    previousResults?: Record<AICoderRole, any>;
  };
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result?: any;
  error?: string;
}

/**
 * Manages collaboration between AI coders with different specializations
 */
export class AICoderIntegration {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private lmBridge: LMAPIBridge;
  private aiCoders: Map<AICoderRole, AICoderSpecs> = new Map();
  private activeRequests: Map<string, AICoderRequest> = new Map();
  private outputChannel: vscode.OutputChannel;
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient, lmBridge: LMAPIBridge) {
    this.context = context;
    this.agentClient = agentClient;
    this.lmBridge = lmBridge;
    this.outputChannel = vscode.window.createOutputChannel('AI Coder Collaboration');
    
    // Register this module as an agent
    this.agentClient.register('AI Coder Integration', ['code-collaboration', 'multi-agent-coding'], '1.0.0')
      .then(success => {
        if (success) {
          this.log('AI Coder Integration registered successfully');
          this.agentClient.subscribe(this.handleMessage.bind(this));
        }
      });
    
    // Initialize AI coder roles
    this.initializeAICoders();
    
    // Register commands
    this.registerCommands();
  }
  
  private initializeAICoders() {
    // Architect: Designs high-level structure and architecture
    this.aiCoders.set(AICoderRole.Architect, {
      role: AICoderRole.Architect,
      capabilities: ['system-design', 'architecture-planning', 'interface-design'],
      systemPrompt: 'You are an expert software architect. Your task is to design high-level software architecture including component structure, interfaces, and data flow. Focus on creating clean, maintainable, and extensible designs.'
    });
    
    // Implementer: Writes the actual code based on designs
    this.aiCoders.set(AICoderRole.Implementer, {
      role: AICoderRole.Implementer,
      capabilities: ['code-implementation', 'api-integration', 'data-modeling'],
      systemPrompt: 'You are an expert code implementer. Your task is to write clean, efficient code that implements the specified requirements and follows the architectural design. Focus on correctness, readability, and adherence to best practices.'
    });
    
    // Tester: Creates tests for the implemented code
    this.aiCoders.set(AICoderRole.Tester, {
      role: AICoderRole.Tester,
      capabilities: ['unit-testing', 'integration-testing', 'test-case-generation'],
      systemPrompt: 'You are an expert in software testing. Your task is to write comprehensive tests for code, including unit tests, integration tests, and edge case handling. Focus on achieving high test coverage and validating both functionality and robustness.'
    });
    
    // Reviewer: Reviews and gives feedback on code
    this.aiCoders.set(AICoderRole.Reviewer, {
      role: AICoderRole.Reviewer,
      capabilities: ['code-review', 'bug-finding', 'best-practices-checking'],
      systemPrompt: 'You are an expert code reviewer. Your task is to analyze code for bugs, inefficiencies, and violations of best practices. Focus on providing constructive feedback that improves code quality, security, and maintainability.'
    });
    
    // Optimizer: Optimizes code for performance
    this.aiCoders.set(AICoderRole.Optimizer, {
      role: AICoderRole.Optimizer,
      capabilities: ['performance-optimization', 'memory-optimization', 'algorithmic-improvements'],
      systemPrompt: 'You are an expert code optimizer. Your task is to analyze and refactor code to improve its performance, reduce resource usage, and enhance efficiency. Focus on time complexity, space complexity, and optimizing critical paths.'
    });
    
    // Documentation Writer: Creates documentation
    this.aiCoders.set(AICoderRole.DocumentationWriter, {
      role: AICoderRole.DocumentationWriter,
      capabilities: ['documentation-generation', 'code-explanation', 'usage-examples'],
      systemPrompt: 'You are an expert technical writer. Your task is to create clear, comprehensive documentation for code, including function descriptions, usage examples, and conceptual explanations. Focus on making the documentation accessible to developers of various experience levels.'
    });
  }
  
  private registerCommands() {
    // Register command to start a collaborative coding task
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.ai.startCollaborativeCoding', async () => {
        return this.startCollaborativeCoding();
      })
    );
    
    // Register command to analyze a coding problem
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.ai.analyzeCodeProblem', async () => {
        return this.analyzeCodeProblem();
      })
    );
    
    // Register command to consult specific AI coder role
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.ai.consultCoder', async (role: AICoderRole, task: string, context: any) => {
        return this.consultAICoder(role, task, context);
      })
    );
  }
  
  /**
   * Handle incoming messages
   */
  private async handleMessage(message: any): Promise<void> {
    // Handle messages from other agents or AI coders
    this.log(`Received message: ${message.action} from ${message.sender}`);
    
    if (message.action === 'coderRequest') {
      try {
        const result = await this.consultAICoder(
          message.payload.role,
          message.payload.task,
          message.payload.context
        );
        
        await this.agentClient.sendMessage(
          message.sender,
          'coderResponse',
          {
            requestId: message.payload.requestId,
            result,
            success: true
          }
        );
      } catch (error) {
        await this.agentClient.sendMessage(
          message.sender,
          'coderResponse',
          {
            requestId: message.payload.requestId,
            error: error.message,
            success: false
          }
        );
      }
    }
  }
  
  /**
   * Start a collaborative coding task using all AI coder roles
   */
  private async startCollaborativeCoding(): Promise<void> {
    // Get the requirements from the user
    const requirements = await vscode.window.showInputBox({
      prompt: 'What do you want to build?',
      placeHolder: 'e.g., Create a React component that displays a paginated list of users'
    });
    
    if (!requirements) return;
    
    // Get the preferred programming language
    const languages = ['JavaScript', 'TypeScript', 'Python', 'Java', 'C#', 'Go', 'Rust', 'Other'];
    const language = await vscode.window.showQuickPick(languages, {
      placeHolder: 'Select the programming language'
    });
    
    if (!language) return;
    
    // Define collaboration flow (roles in sequence)
    const collaborationFlow = [
      AICoderRole.Architect,
      AICoderRole.Implementer,
      AICoderRole.Tester,
      AICoderRole.Reviewer,
      AICoderRole.Optimizer,
      AICoderRole.DocumentationWriter
    ];
    
    // Start the collaborative process
    vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: 'AI Collaborative Coding',
      cancellable: true
    }, async (progress, token) => {
      try {
        let context: any = {
          requirements,
          language,
          previousResults: {}
        };
        
        // Process each role in sequence
        for (let i = 0; i < collaborationFlow.length; i++) {
          if (token.isCancellationRequested) {
            throw new Error('Operation cancelled by user');
          }
          
          const role = collaborationFlow[i];
          const roleName = this.capitalizeFirstLetter(role);
          
          progress.report({ 
            message: `Step ${i+1}/${collaborationFlow.length}: ${roleName} is working...`,
            increment: (i / collaborationFlow.length) * 100
          });
          
          // Customize task based on role
          let task;
          switch (role) {
            case AICoderRole.Architect:
              task = `Design the architecture for: ${requirements}`;
              break;
            case AICoderRole.Implementer:
              task = `Implement code based on the architecture design`;
              break;
            case AICoderRole.Tester:
              task = `Write tests for the implemented code`;
              break;
            case AICoderRole.Reviewer:
              task = `Review the implemented code and provide feedback`;
              break;
            case AICoderRole.Optimizer:
              task = `Optimize the code for performance`;
              break;
            case AICoderRole.DocumentationWriter:
              task = `Write documentation for the code`;
              break;
          }
          
          // Execute the task for this role
          const result = await this.consultAICoder(role, task, context);
          
          // Add result to context for next roles
          context.previousResults[role] = result;
          
          // If this is the implementer, add the code to context
          if (role === AICoderRole.Implementer) {
            context.code = result.code;
          }
        }
        
        // Completed all steps
        progress.report({ message: 'Completed collaborative coding task!', increment: 100 });
        
        // Combine all results into a final document
        this.presentFinalResults(context.previousResults, requirements, language);
        
        return context.previousResults;
      } catch (error) {
        vscode.window.showErrorMessage(`Collaborative coding error: ${error.message}`);
        throw error;
      }
    });
  }
  
  /**
   * Analyze a code problem using multiple AI perspectives
   */
  private async analyzeCodeProblem(): Promise<void> {
    // Get the active editor
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showErrorMessage('No active editor found');
      return;
    }
    
    // Get the selected code
    const selection = editor.selection;
    const code = selection.isEmpty 
      ? editor.document.getText() 
      : editor.document.getText(selection);
    
    if (!code || code.trim().length === 0) {
      vscode.window.showErrorMessage('No code selected');
      return;
    }
    
    // Get the problem description
    const problem = await vscode.window.showInputBox({
      prompt: 'What issue are you trying to solve?',
      placeHolder: 'e.g., This code is slow, or I need to add feature X'
    });
    
    if (!problem) return;
    
    const language = editor.document.languageId;
    
    // Define the roles to consult
    const roles = [
      AICoderRole.Architect,
      AICoderRole.Reviewer,
      AICoderRole.Optimizer
    ];
    
    // Start the analysis process
    vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: 'AI Code Analysis',
      cancellable: true
    }, async (progress, token) => {
      try {
        const context = {
          code,
          language,
          problem,
          previousResults: {}
        };
        
        // Get analysis from each role
        for (let i = 0; i < roles.length; i++) {
          if (token.isCancellationRequested) {
            throw new Error('Operation cancelled by user');
          }
          
          const role = roles[i];
          const roleName = this.capitalizeFirstLetter(role);
          
          progress.report({ 
            message: `${roleName} is analyzing...`,
            increment: (i / roles.length) * 100
          });
          
          // Customize task for each role
          const task = `Analyze this code and provide insights about the problem: "${problem}"`;
          
          // Get insights from this role
          const result = await this.consultAICoder(role, task, context);
          
          // Store result
          context.previousResults[role] = result;
        }
        
        // Show the combined analysis
        this.presentAnalysisResults(context.previousResults, problem);
        
        return context.previousResults;
      } catch (error) {
        vscode.window.showErrorMessage(`Code analysis error: ${error.message}`);
        throw error;
      }
    });
  }
  
  /**
   * Consult a specific AI coder role
   */
  private async consultAICoder(role: AICoderRole, task: string, context: any): Promise<any> {
    const coderSpecs = this.aiCoders.get(role);
    if (!coderSpecs) {
      throw new Error(`Unknown AI coder role: ${role}`);
    }
    
    this.log(`Consulting ${role} for task: ${task}`);
    
    // Create a request ID
    const requestId = `${role}-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
    
    // Prepare the request
    const request: AICoderRequest = {
      id: requestId,
      role,
      task,
      context,
      status: 'pending'
    };
    
    // Store the request
    this.activeRequests.set(requestId, request);
    
    try {
      // Update request status
      request.status = 'processing';
      
      // Construct prompt based on role and task
      const prompt = this.constructPromptForRole(coderSpecs, task, context);
      
      // Generate response using the LM bridge
      const lmResponse = await this.lmBridge.generateText({
        prompt,
        systemPrompt: coderSpecs.systemPrompt,
        maxTokens: 4000,
        temperature: 0.3
      });
      
      // Process the response based on role
      const result = this.processResponseForRole(role, lmResponse.text, context);
      
      // Update request status
      request.status = 'completed';
      request.result = result;
      
      return result;
    } catch (error) {
      // Update request with error
      request.status = 'failed';
      request.error = error.message;
      
      this.log(`Error consulting ${role}: ${error.message}`);
      throw error;
    } finally {
      // Clean up the request after a delay
      setTimeout(() => {
        this.activeRequests.delete(requestId);
      }, 60000); // Keep for 1 minute for debugging
    }
  }
  
  /**
   * Construct an appropriate prompt for each AI coder role
   */
  private constructPromptForRole(coderSpecs: AICoderSpecs, task: string, context: any): string {
    const { role } = coderSpecs;
    let prompt = `Task: ${task}\n\n`;
    
    // Add context information
    if (context.requirements) {
      prompt += `Requirements: ${context.requirements}\n\n`;
    }
    
    if (context.language) {
      prompt += `Language: ${context.language}\n\n`;
    }
    
    if (context.code) {
      prompt += `Code:\n\`\`\`${context.language || ''}\n${context.code}\n\`\`\`\n\n`;
    }
    
    if (context.problem) {
      prompt += `Problem: ${context.problem}\n\n`;
    }
    
    if (context.constraints && context.constraints.length > 0) {
      prompt += `Constraints: ${context.constraints.join(', ')}\n\n`;
    }
    
    // Add results from previous roles if available
    if (context.previousResults) {
      Object.entries(context.previousResults).forEach(([prevRole, result]) => {
        if (role !== prevRole) { // Don't include this role's own previous results
          prompt += `Previous ${this.capitalizeFirstLetter(prevRole)} Output:\n`;
          
          if (prevRole === AICoderRole.Architect && result.design) {
            prompt += `Design:\n${result.design}\n\n`;
            if (result.components) {
              prompt += `Components:\n${JSON.stringify(result.components, null, 2)}\n\n`;
            }
            if (result.interfaces) {
              prompt += `Interfaces:\n${JSON.stringify(result.interfaces, null, 2)}\n\n`;
            }
          } else if (prevRole === AICoderRole.Implementer && result.code) {
            prompt += `Implemented Code:\n\`\`\`${context.language || ''}\n${result.code}\n\`\`\`\n\n`;
          } else if (prevRole === AICoderRole.Tester && result.tests) {
            prompt += `Tests:\n\`\`\`${context.language || ''}\n${result.tests}\n\`\`\`\n\n`;
          } else if (prevRole === AICoderRole.Reviewer && result.feedback) {
            prompt += `Code Review:\n${result.feedback}\n\n`;
            if (result.issues) {
              prompt += `Issues:\n${JSON.stringify(result.issues, null, 2)}\n\n`;
            }
          } else if (prevRole === AICoderRole.Optimizer && result.optimizedCode) {
            prompt += `Optimized Code:\n\`\`\`${context.language || ''}\n${result.optimizedCode}\n\`\`\`\n\n`;
            if (result.optimizations) {
              prompt += `Optimizations:\n${result.optimizations}\n\n`;
            }
          } else {
            // Generic fallback for any role
            prompt += `${JSON.stringify(result, null, 2)}\n\n`;
          }
        }
      });
    }
    
    // Add role-specific instructions
    switch (role) {
      case AICoderRole.Architect:
        prompt += `
Design the architecture for this task. Include:
1. High-level design description
2. Component structure with responsibilities
3. Interfaces between components
4. Data flow diagram (in text form)
5. Key design decisions and their justifications

Format your response as:
{
  "design": "Detailed design description",
  "components": [{"name": "ComponentName", "responsibility": "What this component does", "dependencies": ["Other components it depends on"]}],
  "interfaces": [{"name": "InterfaceName", "methods": [{"name": "methodName", "parameters": ["param1", "param2"], "returnType": "type", "description": "what it does"}]}],
  "dataFlow": "Description of data flow",
  "decisions": [{"decision": "Design decision", "justification": "Why this approach was chosen", "alternatives": ["Other approaches considered"]}]
}
`;
        break;
        
      case AICoderRole.Implementer:
        prompt += `
Implement the code for this task based on the provided architecture and requirements. Your code should:
1. Follow the component structure from the architecture
2. Implement all specified interfaces
3. Be well-structured and maintainable
4. Include helpful comments
5. Follow best practices for the specified language

Format your response as:
{
  "code": "Your implementation here",
  "explanation": "Brief explanation of implementation details and decisions"
}
`;
        break;
        
      case AICoderRole.Tester:
        prompt += `
Write tests for the implemented code. Include:
1. Unit tests for individual components
2. Integration tests if appropriate
3. Edge case handling
4. Test coverage analysis

Format your response as:
{
  "tests": "Your test code here",
  "testStrategy": "Explanation of your testing approach",
  "coverage": "Description of what aspects of the code are covered by tests"
}
`;
        break;
        
      case AICoderRole.Reviewer:
        prompt += `
Review the implemented code and provide feedback. Include:
1. Identification of bugs or potential issues
2. Style and best practice violations
3. Performance concerns
4. Security considerations
5. Suggestions for improvement

Format your response as:
{
  "feedback": "Overall review feedback",
  "issues": [{"type": "bug|style|performance|security", "severity": "high|medium|low", "description": "Description of the issue", "suggestion": "How to fix it"}],
  "strengths": ["Aspects of the code that are well done"],
  "summary": "Summary assessment of code quality"
}
`;
        break;
        
      case AICoderRole.Optimizer:
        prompt += `
Optimize the code for better performance. Include:
1. Identifying performance bottlenecks
2. Algorithmic improvements
3. Memory usage optimizations
4. Refactored code with optimizations applied
5. Explanation of optimization benefits

Format your response as:
{
  "optimizedCode": "Your optimized code here",
  "optimizations": "Explanation of optimizations made",
  "benefits": "Expected performance improvements",
  "tradeoffs": "Any tradeoffs made (e.g., readability vs. performance)"
}
`;
        break;
        
      case AICoderRole.DocumentationWriter:
        prompt += `
Write documentation for the code. Include:
1. Overview of functionality
2. Usage examples
3. API documentation
4. Installation/setup instructions if applicable
5. Troubleshooting section

Format your response as:
{
  "documentation": "Full documentation in markdown format",
  "usageExamples": ["Example 1", "Example 2"],
  "apiReference": "Detailed API reference"
}
`;
        break;
    }
    
    return prompt;
  }
  
  /**
   * Process the response based on the AI coder role
   */
  private processResponseForRole(role: AICoderRole, responseText: string): any {
    
    // Try to parse the response as JSON
    try {
      // Extract JSON if it's wrapped in markdown code blocks
      const jsonMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
      const jsonText = jsonMatch ? jsonMatch[1] : responseText;
      
      return JSON.parse(jsonText);
    } catch (error) {
      this.log(`Failed to parse JSON response for ${role}: ${error.message}`);
      
      // Fallback: try to extract structured information based on role
      switch (role) {
        case AICoderRole.Architect:
          return {
            design: responseText,
            components: []
          };
          
        case AICoderRole.Implementer:
          // Try to extract code blocks
          const codeMatch = responseText.match(/```(?:\w+)?\s*([\s\S]*?)```/);
          return {
            code: codeMatch ? codeMatch[1] : responseText,
            explanation: "Extracted from unstructured response"
          };
          
        case AICoderRole.Tester:
          const testCodeMatch = responseText.match(/```(?:\w+)?\s*([\s\S]*?)```/);
          return {
            tests: testCodeMatch ? testCodeMatch[1] : responseText,
            testStrategy: "Extracted from unstructured response"
          };
          
        case AICoderRole.Reviewer:
          return {
            feedback: responseText,
            issues: []
          };
          
        case AICoderRole.Optimizer:
          const optimizedCodeMatch = responseText.match(/```(?:\w+)?\s*([\s\S]*?)```/);
          return {
            optimizedCode: optimizedCodeMatch ? optimizedCodeMatch[1] : responseText,
            optimizations: "Extracted from unstructured response"
          };
          
        case AICoderRole.DocumentationWriter:
          return {
            documentation: responseText,
            usageExamples: [],
            apiReference: ""
          };
          
        default:
          return responseText;
      }
    }
  }
  
  /**
   * Present the final results of the collaborative coding task
   */
  private presentFinalResults(results: Record<AICoderRole, any>, requirements: string, language: string) {
    const finalDocument = `
# Collaborative Coding Results

## Requirements
${requirements}

## Language
${language}

## Architecture Design
${results[AICoderRole.Architect]?.design || 'N/A'}

## Implemented Code
\`\`\`${language}
${results[AICoderRole.Implementer]?.code || 'N/A'}
\`\`\`

## Tests
\`\`\`${language}
${results[AICoderRole.Tester]?.tests || 'N/A'}
\`\`\`

## Code Review
${results[AICoderRole.Reviewer]?.feedback || 'N/A'}

## Optimized Code
\`\`\`${language}
${results[AICoderRole.Optimizer]?.optimizedCode || 'N/A'}
\`\`\`

## Documentation
${results[AICoderRole.DocumentationWriter]?.documentation || 'N/A'}
`;
    
    // Show the final document in a new editor
    vscode.workspace.openTextDocument({ content: finalDocument, language: 'markdown' })
      .then(doc => vscode.window.showTextDocument(doc));
  }
  
  /**
   * Present the combined analysis results
   */
  private presentAnalysisResults(results: Record<AICoderRole, any>, problem: string) {
    const analysisDocument = `
# Code Analysis Results

## Problem
${problem}

## Architecture Insights
${results[AICoderRole.Architect]?.design || 'N/A'}

## Code Review
${results[AICoderRole.Reviewer]?.feedback || 'N/A'}

## Optimized Code
\`\`\`${results[AICoderRole.Optimizer]?.optimizedCode || 'N/A'}
\`\`\`
`;
    
    // Show the analysis document in a new editor
    vscode.workspace.openTextDocument({ content: analysisDocument, language: 'markdown' })
      .then(doc => vscode.window.showTextDocument(doc));
  }
  
  /**
   * Capitalize the first letter of a string
   */
  private capitalizeFirstLetter(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string) {
    this.outputChannel.appendLine(`[AI Coder Integration] ${message}`);
  }
}



==============================================
FILE: ./src/vscode-extension/ai-coder-integration.tsx
==============================================

/**
 * AI Coder Integration Module
 * 
 * This module demonstrates how multiple AI coding assistants can collaborate
 * using The New Fuse's inter-extension communication system.
 */

/* global setTimeout */
/* eslint-disable no-case-declarations */
import * as vscode from 'vscode';
import { AgentClient } from './agent-communication';
import { LMAPIBridge } from './lm-api-bridge';

// Define roles for specialized AI coders
export enum AICoderRole {
  Architect = 'architect',
  Implementer = 'implementer',
  Tester = 'tester',
  Reviewer = 'reviewer',
  Optimizer = 'optimizer',
  DocumentationWriter = 'documentationWriter',
}

interface AICoderSpecs {
  role: AICoderRole;
  capabilities: string[];
  specialization?: string;
  preferredLanguages?: string[];
  systemPrompt: string;
}

interface AICoderRequest {
  id: string;
  role: AICoderRole;
  task: string;
  context: {
    code?: string;
    requirements?: string;
    language?: string;
    constraints?: string[];
    previousResults?: Record<AICoderRole, any>;
  };
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result?: any;
  error?: string;
}

/**
 * Manages collaboration between AI coders with different specializations
 */
export class AICoderIntegration {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private lmBridge: LMAPIBridge;
  private aiCoders: Map<AICoderRole, AICoderSpecs> = new Map();
  private activeRequests: Map<string, AICoderRequest> = new Map();
  private outputChannel: vscode.OutputChannel;
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient, lmBridge: LMAPIBridge) {
    this.context = context;
    this.agentClient = agentClient;
    this.lmBridge = lmBridge;
    this.outputChannel = vscode.window.createOutputChannel('AI Coder Collaboration');
    
    // Register this module as an agent
    this.agentClient.register('AI Coder Integration', ['code-collaboration', 'multi-agent-coding'], '1.0.0')
      .then(success => {
        if (success) {
          this.log('AI Coder Integration registered successfully');
          this.agentClient.subscribe(this.handleMessage.bind(this));
        }
      });
    
    // Initialize AI coder roles
    this.initializeAICoders();
    
    // Register commands
    this.registerCommands();
  }
  
  private initializeAICoders() {
    // Architect: Designs high-level structure and architecture
    this.aiCoders.set(AICoderRole.Architect, {
      role: AICoderRole.Architect,
      capabilities: ['system-design', 'architecture-planning', 'interface-design'],
      systemPrompt: 'You are an expert software architect. Your task is to design high-level software architecture including component structure, interfaces, and data flow. Focus on creating clean, maintainable, and extensible designs.'
    });
    
    // Implementer: Writes the actual code based on designs
    this.aiCoders.set(AICoderRole.Implementer, {
      role: AICoderRole.Implementer,
      capabilities: ['code-implementation', 'api-integration', 'data-modeling'],
      systemPrompt: 'You are an expert code implementer. Your task is to write clean, efficient code that implements the specified requirements and follows the architectural design. Focus on correctness, readability, and adherence to best practices.'
    });
    
    // Tester: Creates tests for the implemented code
    this.aiCoders.set(AICoderRole.Tester, {
      role: AICoderRole.Tester,
      capabilities: ['unit-testing', 'integration-testing', 'test-case-generation'],
      systemPrompt: 'You are an expert in software testing. Your task is to write comprehensive tests for code, including unit tests, integration tests, and edge case handling. Focus on achieving high test coverage and validating both functionality and robustness.'
    });
    
    // Reviewer: Reviews and gives feedback on code
    this.aiCoders.set(AICoderRole.Reviewer, {
      role: AICoderRole.Reviewer,
      capabilities: ['code-review', 'bug-finding', 'best-practices-checking'],
      systemPrompt: 'You are an expert code reviewer. Your task is to analyze code for bugs, inefficiencies, and violations of best practices. Focus on providing constructive feedback that improves code quality, security, and maintainability.'
    });
    
    // Optimizer: Optimizes code for performance
    this.aiCoders.set(AICoderRole.Optimizer, {
      role: AICoderRole.Optimizer,
      capabilities: ['performance-optimization', 'memory-optimization', 'algorithmic-improvements'],
      systemPrompt: 'You are an expert code optimizer. Your task is to analyze and refactor code to improve its performance, reduce resource usage, and enhance efficiency. Focus on time complexity, space complexity, and optimizing critical paths.'
    });
    
    // Documentation Writer: Creates documentation
    this.aiCoders.set(AICoderRole.DocumentationWriter, {
      role: AICoderRole.DocumentationWriter,
      capabilities: ['documentation-generation', 'code-explanation', 'usage-examples'],
      systemPrompt: 'You are an expert technical writer. Your task is to create clear, comprehensive documentation for code, including function descriptions, usage examples, and conceptual explanations. Focus on making the documentation accessible to developers of various experience levels.'
    });
  }
  
  private registerCommands() {
    // Register command to start a collaborative coding task
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.ai.startCollaborativeCoding', async () => {
        return this.startCollaborativeCoding();
      })
    );
    
    // Register command to analyze a coding problem
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.ai.analyzeCodeProblem', async () => {
        return this.analyzeCodeProblem();
      })
    );
    
    // Register command to consult specific AI coder role
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.ai.consultCoder', async (role: AICoderRole, task: string, context: any) => {
        return this.consultAICoder(role, task, context);
      })
    );
  }
  
  /**
   * Handle incoming messages
   */
  private async handleMessage(message: any): Promise<void> {
    // Handle messages from other agents or AI coders
    this.log(`Received message: ${message.action} from ${message.sender}`);
    
    if (message.action === 'coderRequest') {
      try {
        const result = await this.consultAICoder(
          message.payload.role,
          message.payload.task,
          message.payload.context
        );
        
        await this.agentClient.sendMessage(
          message.sender,
          'coderResponse',
          {
            requestId: message.payload.requestId,
            result,
            success: true
          }
        );
      } catch (error) {
        await this.agentClient.sendMessage(
          message.sender,
          'coderResponse',
          {
            requestId: message.payload.requestId,
            error: error.message,
            success: false
          }
        );
      }
    }
  }
  
  /**
   * Start a collaborative coding task using all AI coder roles
   */
  private async startCollaborativeCoding(): Promise<void> {
    // Get the requirements from the user
    const requirements = await vscode.window.showInputBox({
      prompt: 'What do you want to build?',
      placeHolder: 'e.g., Create a React component that displays a paginated list of users'
    });
    
    if (!requirements) return;
    
    // Get the preferred programming language
    const languages = ['JavaScript', 'TypeScript', 'Python', 'Java', 'C#', 'Go', 'Rust', 'Other'];
    const language = await vscode.window.showQuickPick(languages, {
      placeHolder: 'Select the programming language'
    });
    
    if (!language) return;
    
    // Define collaboration flow (roles in sequence)
    const collaborationFlow = [
      AICoderRole.Architect,
      AICoderRole.Implementer,
      AICoderRole.Tester,
      AICoderRole.Reviewer,
      AICoderRole.Optimizer,
      AICoderRole.DocumentationWriter
    ];
    
    // Start the collaborative process
    vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: 'AI Collaborative Coding',
      cancellable: true
    }, async (progress, token) => {
      try {
        let context: any = {
          requirements,
          language,
          previousResults: {}
        };
        
        // Process each role in sequence
        for (let i = 0; i < collaborationFlow.length; i++) {
          if (token.isCancellationRequested) {
            throw new Error('Operation cancelled by user');
          }
          
          const role = collaborationFlow[i];
          const roleName = this.capitalizeFirstLetter(role);
          
          progress.report({ 
            message: `Step ${i+1}/${collaborationFlow.length}: ${roleName} is working...`,
            increment: (i / collaborationFlow.length) * 100
          });
          
          // Customize task based on role
          let task;
          switch (role) {
            case AICoderRole.Architect:
              task = `Design the architecture for: ${requirements}`;
              break;
            case AICoderRole.Implementer:
              task = `Implement code based on the architecture design`;
              break;
            case AICoderRole.Tester:
              task = `Write tests for the implemented code`;
              break;
            case AICoderRole.Reviewer:
              task = `Review the implemented code and provide feedback`;
              break;
            case AICoderRole.Optimizer:
              task = `Optimize the code for performance`;
              break;
            case AICoderRole.DocumentationWriter:
              task = `Write documentation for the code`;
              break;
          }
          
          // Execute the task for this role
          const result = await this.consultAICoder(role, task, context);
          
          // Add result to context for next roles
          context.previousResults[role] = result;
          
          // If this is the implementer, add the code to context
          if (role === AICoderRole.Implementer) {
            context.code = result.code;
          }
        }
        
        // Completed all steps
        progress.report({ message: 'Completed collaborative coding task!', increment: 100 });
        
        // Combine all results into a final document
        this.presentFinalResults(context.previousResults, requirements, language);
        
        return context.previousResults;
      } catch (error) {
        vscode.window.showErrorMessage(`Collaborative coding error: ${error.message}`);
        throw error;
      }
    });
  }
  
  /**
   * Analyze a code problem using multiple AI perspectives
   */
  private async analyzeCodeProblem(): Promise<void> {
    // Get the active editor
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showErrorMessage('No active editor found');
      return;
    }
    
    // Get the selected code
    const selection = editor.selection;
    const code = selection.isEmpty 
      ? editor.document.getText() 
      : editor.document.getText(selection);
    
    if (!code || code.trim().length === 0) {
      vscode.window.showErrorMessage('No code selected');
      return;
    }
    
    // Get the problem description
    const problem = await vscode.window.showInputBox({
      prompt: 'What issue are you trying to solve?',
      placeHolder: 'e.g., This code is slow, or I need to add feature X'
    });
    
    if (!problem) return;
    
    const language = editor.document.languageId;
    
    // Define the roles to consult
    const roles = [
      AICoderRole.Architect,
      AICoderRole.Reviewer,
      AICoderRole.Optimizer
    ];
    
    // Start the analysis process
    vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: 'AI Code Analysis',
      cancellable: true
    }, async (progress, token) => {
      try {
        const context = {
          code,
          language,
          problem,
          previousResults: {}
        };
        
        // Get analysis from each role
        for (let i = 0; i < roles.length; i++) {
          if (token.isCancellationRequested) {
            throw new Error('Operation cancelled by user');
          }
          
          const role = roles[i];
          const roleName = this.capitalizeFirstLetter(role);
          
          progress.report({ 
            message: `${roleName} is analyzing...`,
            increment: (i / roles.length) * 100
          });
          
          // Customize task for each role
          const task = `Analyze this code and provide insights about the problem: "${problem}"`;
          
          // Get insights from this role
          const result = await this.consultAICoder(role, task, context);
          
          // Store result
          context.previousResults[role] = result;
        }
        
        // Show the combined analysis
        this.presentAnalysisResults(context.previousResults, problem);
        
        return context.previousResults;
      } catch (error) {
        vscode.window.showErrorMessage(`Code analysis error: ${error.message}`);
        throw error;
      }
    });
  }
  
  /**
   * Consult a specific AI coder role
   */
  private async consultAICoder(role: AICoderRole, task: string, context: any): Promise<any> {
    const coderSpecs = this.aiCoders.get(role);
    if (!coderSpecs) {
      throw new Error(`Unknown AI coder role: ${role}`);
    }
    
    this.log(`Consulting ${role} for task: ${task}`);
    
    // Create a request ID
    const requestId = `${role}-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
    
    // Prepare the request
    const request: AICoderRequest = {
      id: requestId,
      role,
      task,
      context,
      status: 'pending'
    };
    
    // Store the request
    this.activeRequests.set(requestId, request);
    
    try {
      // Update request status
      request.status = 'processing';
      
      // Construct prompt based on role and task
      const prompt = this.constructPromptForRole(coderSpecs, task, context);
      
      // Generate response using the LM bridge
      const lmResponse = await this.lmBridge.generateText({
        prompt,
        systemPrompt: coderSpecs.systemPrompt,
        maxTokens: 4000,
        temperature: 0.3
      });
      
      // Process the response based on role
      const result = this.processResponseForRole(role, lmResponse.text, context);
      
      // Update request status
      request.status = 'completed';
      request.result = result;
      
      return result;
    } catch (error) {
      // Update request with error
      request.status = 'failed';
      request.error = error.message;
      
      this.log(`Error consulting ${role}: ${error.message}`);
      throw error;
    } finally {
      // Clean up the request after a delay
      setTimeout(() => {
        this.activeRequests.delete(requestId);
      }, 60000); // Keep for 1 minute for debugging
    }
  }
  
  /**
   * Construct an appropriate prompt for each AI coder role
   */
  private constructPromptForRole(coderSpecs: AICoderSpecs, task: string, context: any): string {
    const { role } = coderSpecs;
    let prompt = `Task: ${task}\n\n`;
    
    // Add context information
    if (context.requirements) {
      prompt += `Requirements: ${context.requirements}\n\n`;
    }
    
    if (context.language) {
      prompt += `Language: ${context.language}\n\n`;
    }
    
    if (context.code) {
      prompt += `Code:\n\`\`\`${context.language || ''}\n${context.code}\n\`\`\`\n\n`;
    }
    
    if (context.problem) {
      prompt += `Problem: ${context.problem}\n\n`;
    }
    
    if (context.constraints && context.constraints.length > 0) {
      prompt += `Constraints: ${context.constraints.join(', ')}\n\n`;
    }
    
    // Add results from previous roles if available
    if (context.previousResults) {
      Object.entries(context.previousResults).forEach(([prevRole, result]) => {
        if (role !== prevRole) { // Don't include this role's own previous results
          prompt += `Previous ${this.capitalizeFirstLetter(prevRole)} Output:\n`;
          
          if (prevRole === AICoderRole.Architect && result.design) {
            prompt += `Design:\n${result.design}\n\n`;
            if (result.components) {
              prompt += `Components:\n${JSON.stringify(result.components, null, 2)}\n\n`;
            }
            if (result.interfaces) {
              prompt += `Interfaces:\n${JSON.stringify(result.interfaces, null, 2)}\n\n`;
            }
          } else if (prevRole === AICoderRole.Implementer && result.code) {
            prompt += `Implemented Code:\n\`\`\`${context.language || ''}\n${result.code}\n\`\`\`\n\n`;
          } else if (prevRole === AICoderRole.Tester && result.tests) {
            prompt += `Tests:\n\`\`\`${context.language || ''}\n${result.tests}\n\`\`\`\n\n`;
          } else if (prevRole === AICoderRole.Reviewer && result.feedback) {
            prompt += `Code Review:\n${result.feedback}\n\n`;
            if (result.issues) {
              prompt += `Issues:\n${JSON.stringify(result.issues, null, 2)}\n\n`;
            }
          } else if (prevRole === AICoderRole.Optimizer && result.optimizedCode) {
            prompt += `Optimized Code:\n\`\`\`${context.language || ''}\n${result.optimizedCode}\n\`\`\`\n\n`;
            if (result.optimizations) {
              prompt += `Optimizations:\n${result.optimizations}\n\n`;
            }
          } else {
            // Generic fallback for any role
            prompt += `${JSON.stringify(result, null, 2)}\n\n`;
          }
        }
      });
    }
    
    // Add role-specific instructions
    switch (role) {
      case AICoderRole.Architect:
        prompt += `
Design the architecture for this task. Include:
1. High-level design description
2. Component structure with responsibilities
3. Interfaces between components
4. Data flow diagram (in text form)
5. Key design decisions and their justifications

Format your response as:
{
  "design": "Detailed design description",
  "components": [{"name": "ComponentName", "responsibility": "What this component does", "dependencies": ["Other components it depends on"]}],
  "interfaces": [{"name": "InterfaceName", "methods": [{"name": "methodName", "parameters": ["param1", "param2"], "returnType": "type", "description": "what it does"}]}],
  "dataFlow": "Description of data flow",
  "decisions": [{"decision": "Design decision", "justification": "Why this approach was chosen", "alternatives": ["Other approaches considered"]}]
}
`;
        break;
        
      case AICoderRole.Implementer:
        prompt += `
Implement the code for this task based on the provided architecture and requirements. Your code should:
1. Follow the component structure from the architecture
2. Implement all specified interfaces
3. Be well-structured and maintainable
4. Include helpful comments
5. Follow best practices for the specified language

Format your response as:
{
  "code": "Your implementation here",
  "explanation": "Brief explanation of implementation details and decisions"
}
`;
        break;
        
      case AICoderRole.Tester:
        prompt += `
Write tests for the implemented code. Include:
1. Unit tests for individual components
2. Integration tests if appropriate
3. Edge case handling
4. Test coverage analysis

Format your response as:
{
  "tests": "Your test code here",
  "testStrategy": "Explanation of your testing approach",
  "coverage": "Description of what aspects of the code are covered by tests"
}
`;
        break;
        
      case AICoderRole.Reviewer:
        prompt += `
Review the implemented code and provide feedback. Include:
1. Identification of bugs or potential issues
2. Style and best practice violations
3. Performance concerns
4. Security considerations
5. Suggestions for improvement

Format your response as:
{
  "feedback": "Overall review feedback",
  "issues": [{"type": "bug|style|performance|security", "severity": "high|medium|low", "description": "Description of the issue", "suggestion": "How to fix it"}],
  "strengths": ["Aspects of the code that are well done"],
  "summary": "Summary assessment of code quality"
}
`;
        break;
        
      case AICoderRole.Optimizer:
        prompt += `
Optimize the code for better performance. Include:
1. Identifying performance bottlenecks
2. Algorithmic improvements
3. Memory usage optimizations
4. Refactored code with optimizations applied
5. Explanation of optimization benefits

Format your response as:
{
  "optimizedCode": "Your optimized code here",
  "optimizations": "Explanation of optimizations made",
  "benefits": "Expected performance improvements",
  "tradeoffs": "Any tradeoffs made (e.g., readability vs. performance)"
}
`;
        break;
        
      case AICoderRole.DocumentationWriter:
        prompt += `
Write documentation for the code. Include:
1. Overview of functionality
2. Usage examples
3. API documentation
4. Installation/setup instructions if applicable
5. Troubleshooting section

Format your response as:
{
  "documentation": "Full documentation in markdown format",
  "usageExamples": ["Example 1", "Example 2"],
  "apiReference": "Detailed API reference"
}
`;
        break;
    }
    
    return prompt;
  }
  
  /**
   * Process the response based on the AI coder role
   */
  private processResponseForRole(role: AICoderRole, responseText: string): any {
    
    // Try to parse the response as JSON
    try {
      // Extract JSON if it's wrapped in markdown code blocks
      const jsonMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
      const jsonText = jsonMatch ? jsonMatch[1] : responseText;
      
      return JSON.parse(jsonText);
    } catch (error) {
      this.log(`Failed to parse JSON response for ${role}: ${error.message}`);
      
      // Fallback: try to extract structured information based on role
      switch (role) {
        case AICoderRole.Architect:
          return {
            design: responseText,
            components: []
          };
          
        case AICoderRole.Implementer:
          // Try to extract code blocks
          const codeMatch = responseText.match(/```(?:\w+)?\s*([\s\S]*?)```/);
          return {
            code: codeMatch ? codeMatch[1] : responseText,
            explanation: "Extracted from unstructured response"
          };
          
        case AICoderRole.Tester:
          const testCodeMatch = responseText.match(/```(?:\w+)?\s*([\s\S]*?)```/);
          return {
            tests: testCodeMatch ? testCodeMatch[1] : responseText,
            testStrategy: "Extracted from unstructured response"
          };
          
        case AICoderRole.Reviewer:
          return {
            feedback: responseText,
            issues: []
          };
          
        case AICoderRole.Optimizer:
          const optimizedCodeMatch = responseText.match(/```(?:\w+)?\s*([\s\S]*?)```/);
          return {
            optimizedCode: optimizedCodeMatch ? optimizedCodeMatch[1] : responseText,
            optimizations: "Extracted from unstructured response"
          };
          
        case AICoderRole.DocumentationWriter:
          return {
            documentation: responseText,
            usageExamples: [],
            apiReference: ""
          };
          
        default:
          return responseText;
      }
    }
  }
  
  /**
   * Present the final results of the collaborative coding task
   */
  private presentFinalResults(results: Record<AICoderRole, any>, requirements: string, language: string) {
    const finalDocument = `
# Collaborative Coding Results

## Requirements
${requirements}

## Language
${language}

## Architecture Design
${results[AICoderRole.Architect]?.design || 'N/A'}

## Implemented Code
\`\`\`${language}
${results[AICoderRole.Implementer]?.code || 'N/A'}
\`\`\`

## Tests
\`\`\`${language}
${results[AICoderRole.Tester]?.tests || 'N/A'}
\`\`\`

## Code Review
${results[AICoderRole.Reviewer]?.feedback || 'N/A'}

## Optimized Code
\`\`\`${language}
${results[AICoderRole.Optimizer]?.optimizedCode || 'N/A'}
\`\`\`

## Documentation
${results[AICoderRole.DocumentationWriter]?.documentation || 'N/A'}
`;
    
    // Show the final document in a new editor
    vscode.workspace.openTextDocument({ content: finalDocument, language: 'markdown' })
      .then(doc => vscode.window.showTextDocument(doc));
  }
  
  /**
   * Present the combined analysis results
   */
  private presentAnalysisResults(results: Record<AICoderRole, any>, problem: string) {
    const analysisDocument = `
# Code Analysis Results

## Problem
${problem}

## Architecture Insights
${results[AICoderRole.Architect]?.design || 'N/A'}

## Code Review
${results[AICoderRole.Reviewer]?.feedback || 'N/A'}

## Optimized Code
\`\`\`${results[AICoderRole.Optimizer]?.optimizedCode || 'N/A'}
\`\`\`
`;
    
    // Show the analysis document in a new editor
    vscode.workspace.openTextDocument({ content: analysisDocument, language: 'markdown' })
      .then(doc => vscode.window.showTextDocument(doc));
  }
  
  /**
   * Capitalize the first letter of a string
   */
  private capitalizeFirstLetter(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string) {
    this.outputChannel.appendLine(`[AI Coder Integration] ${message}`);
  }
}



==============================================
FILE: ./src/vscode-extension/ai-coder/integration-manager.tsx
==============================================

import * as vscode from 'vscode';
import { Logger } from '../core/logging';
import { MCPManager } from '../mcp-integration/mcp-manager';
import { RooCoderMonitor } from '../monitoring/roo-coder-monitor';
import { AICoderRole } from '../ai-coder-integration';

export class AICoderIntegrationManager {
    private logger: Logger;
    private monitor: RooCoderMonitor;
    private activeCoders: Map<AICoderRole, boolean> = new Map();

    constructor(
        private mcpManager: MCPManager,
        private context: vscode.ExtensionContext
    ) {
        this.logger = Logger.getInstance();
        this.monitor = RooCoderMonitor.getInstance();
        this.initializeCoders();
    }

    private initializeCoders(): void {
        Object.values(AICoderRole).forEach(role => {
            this.activeCoders.set(role, false);
        });
    }

    async activateCoder(role: AICoderRole): Promise<void> {
        try {
            await this.mcpManager.executeTool('ai-coder-activate', { role });
            this.activeCoders.set(role, true);
            this.monitor.updateActiveAgents(this.getActiveCoders());
            
            this.logger.info(`Activated AI Coder: ${role}`);
        } catch (error) {
            this.logger.error(`Failed to activate AI Coder ${role}:`, error);
            throw error;
        }
    }

    async deactivateCoder(role: AICoderRole): Promise<void> {
        try {
            await this.mcpManager.executeTool('ai-coder-deactivate', { role });
            this.activeCoders.set(role, false);
            this.monitor.updateActiveAgents(this.getActiveCoders());
            
            this.logger.info(`Deactivated AI Coder: ${role}`);
        } catch (error) {
            this.logger.error(`Failed to deactivate AI Coder ${role}:`, error);
            throw error;
        }
    }

    private getActiveCoders(): string[] {
        return Array.from(this.activeCoders.entries())
            .filter(([_, active]) => active)
            .map(([role]) => role);
    }
}


==============================================
FILE: ./src/vscode-extension/ai-collaboration-simple.tsx
==============================================

/**
 * Simplified AI Collaboration Module
 */

import * as vscode from 'vscode';
import { AgentClient } from './agent-communication-simple';
import { LMAPIBridge } from './lm-api-bridge-simple';

export class AICollaborationManager {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private lmBridge: LMAPIBridge;
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient, lmBridge: LMAPIBridge) {
    this.context = context;
    this.agentClient = agentClient;
    this.lmBridge = lmBridge;
  }
  
  // Start a collaboration workflow
  async startWorkflow(workflow: any, initialContext?: any): Promise<any> {
    vscode.window.showInformationMessage('Starting workflow: ' + workflow.name);
    
    // This is a simple placeholder - in a real implementation we would
    // execute the steps of the workflow
    
    return {
      workflowId: 'sample-workflow-id',
      success: true
    };
  }
  
  // Get predefined collaboration workflows
  getPredefinedWorkflows(): any[] {
    return [
      {
        id: 'code-improvement',
        name: 'Comprehensive Code Improvement',
        description: 'Analyze, refactor, and document code',
        agents: ['codeAnalyzer', 'codeRefactorer', 'documentationGenerator'],
        steps: []
      },
      {
        id: 'bug-fixing',
        name: 'AI-Assisted Bug Fixing',
        description: 'Analyze code, identify bugs, and propose fixes',
        agents: ['codeAnalyzer', 'lm', 'codeRefactorer'],
        steps: []
      }
    ];
  }
}

// Export factory function
export function createAICollaborationManager(
  context: vscode.ExtensionContext,
  agentClient: AgentClient,
  lmBridge: LMAPIBridge
): AICollaborationManager {
  return new AICollaborationManager(context, agentClient, lmBridge);
}



==============================================
FILE: ./src/vscode-extension/ai-collaboration.tsx
==============================================

/**
 * AI Collaboration Module
 * 
 * This module implements collaboration patterns between AI assistants
 * using the VS Code extension framework.
 */

import * as vscode from 'vscode';
import { AgentClient, AgentMessage } from './agent-communication';
import { LMAPIBridge, LMRequestParams, LMResponse } from './lm-api-bridge';
import { v4 as uuidv4 } from 'uuid';

// Enhanced types for better type safety
export interface AICollaborationWorkflow {
  id: string;
  name: string;
  description?: string;
  agents: string[];
  steps: AICollaborationStep[];
  status: 'pending' | 'running' | 'completed' | 'failed';
  startTime?: number;
  endTime?: number;
  error?: string;
}

export interface AICollaborationStep {
  id: string;
  agent: string;
  action: string;
  input: Record<string, any>;
  output?: Record<string, any>;
  dependsOn?: string[];
  status: 'pending' | 'running' | 'completed' | 'failed';
  error?: string;
}

export interface AITask {
  id: string;
  workflowId?: string;
  agentId: string;
  action: string;
  input: Record<string, any>;
  context?: Record<string, any>;
  status: 'pending' | 'running' | 'completed' | 'failed';
  result?: any;
  error?: string;
  startTime: number;
  endTime?: number;
  retryCount: number;
  maxRetries: number;
}

/**
 * AI Collaboration Manager
 * Manages collaboration between AI agents with improved error handling and state management
 */
export class AICollaborationManager {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private lmBridge: LMAPIBridge;
  private activeWorkflows: Map<string, AICollaborationWorkflow> = new Map();
  private activeTasks: Map<string, AITask> = new Map();
  private workflowResults: Map<string, Record<string, any>> = new Map();
  private retryDelays: number[] = [1000, 2000, 5000, 10000]; // Retry delays in ms
  private readonly maxRetries = 3;
  private workflowObservers: Map<string, Function> = new Map();
  private errorHandlers: Map<string, Function> = new Map();

  constructor(context: vscode.ExtensionContext, agentClient: AgentClient, lmBridge: LMAPIBridge) {
    this.context = context;
    this.agentClient = agentClient;
    this.lmBridge = lmBridge;
    
    // Register with enhanced error handling
    this.initializeAgent().catch(error => {
      console.error('Failed to initialize AI Collaboration Manager:', error);
      vscode.window.showErrorMessage('Failed to initialize AI Collaboration Manager');
    });
    
    this.registerCommands();
  }

  private async initializeAgent(): Promise<void> {
    const success = await this.agentClient.register(
      'AI Collaboration Manager',
      ['collaboration', 'workflow'],
      '1.0.0'
    );

    if (!success) {
      throw new Error('Failed to register AI Collaboration Manager');
    }

    this.agentClient.subscribe(this.handleAgentMessage.bind(this));
  }

  private setupErrorRecovery(): void {
    // Set up automatic error recovery for workflows
    this.agentClient.onError((error: Error, context: any) => {
      const workflowId = context?.workflowId;
      if (workflowId && this.activeWorkflows.has(workflowId)) {
        this.handleWorkflowError(workflowId, error);
      }
    });
  }

  private initializeWorkflowMonitoring(): void {
    // Monitor workflow health and performance
    setInterval(() => {
      for (const [workflowId, workflow] of this.activeWorkflows) {
        this.checkWorkflowHealth(workflowId, workflow);
      }
    }, 30000); // Check every 30 seconds
  }

  private async checkWorkflowHealth(workflowId: string, workflow: AICollaborationWorkflow): Promise<void> {
    const tasks = Array.from(this.activeTasks.values())
      .filter(task => task.workflowId === workflowId);
    
    const stuckTasks = tasks.filter(task => 
      task.status === 'running' && 
      Date.now() - task.startTime > 300000 // 5 minutes timeout
    );

    if (stuckTasks.length > 0) {
      await this.recoverStuckTasks(stuckTasks);
    }
  }

  private async recoverStuckTasks(tasks: AITask[]): Promise<void> {
    for (const task of tasks) {
      try {
        // Attempt to gracefully stop the task
        await this.stopTask(task.id);
        
        // Retry the task with reduced scope
        await this.retryTask(task, { timeout: 150000, reducedScope: true });
      } catch (error) {
        this.handleTaskError(task.id, error as Error);
      }
    }
  }

  async startWorkflow(
    workflow: AICollaborationWorkflow,
    initialContext?: Record<string, any>
  ): Promise<{ workflowId: string, success: boolean }> {
    const workflowId = uuidv4();
    
    try {
      // Validate workflow before starting
      this.validateWorkflow(workflow);
      
      // Initialize workflow state
      this.activeWorkflows.set(workflowId, workflow);
      this.workflowResults.set(workflowId, {});
      
      // Create execution plan
      const executionPlan = await this.createExecutionPlan(workflow, initialContext);
      
      // Start execution
      await this.executeWorkflowPlan(workflowId, executionPlan);
      
      return { workflowId, success: true };
    } catch (error) {
      this.handleWorkflowError(workflowId, error as Error);
      return { workflowId, success: false };
    }
  }

  private validateWorkflow(workflow: AICollaborationWorkflow): void {
    if (!workflow.steps || workflow.steps.length === 0) {
      throw new Error('Workflow must have at least one step');
    }
    
    // Validate step dependencies
    const stepIds = new Set(workflow.steps.map(step => step.id));
    for (const step of workflow.steps) {
      if (step.dependsOn) {
        for (const dep of step.dependsOn) {
          if (!stepIds.has(dep)) {
            throw new Error(`Invalid dependency: ${dep} in step ${step.id}`);
          }
        }
      }
    }
  }

  private registerCommands() {
    // Register a command to start a collaboration workflow
    this.context.subscriptions.push(
      vscode.commands.registerCommand(
        'thefuse.ai.startCollaboration', 
        async (workflow: AICollaborationWorkflow, initialContext?: Record<string, any>) => {
          return this.startWorkflow(workflow, initialContext);
        }
      )
    );
    
    // Register a command to execute a specific collaboration task
    this.context.subscriptions.push(
      vscode.commands.registerCommand(
        'thefuse.ai.executeTask',
        async (agentId: string, action: string, input: Record<string, any>, context?: Record<string, any>) => {
          return this.executeTask(agentId, action, input, context);
        }
      )
    );
    
    // Register predefined collaboration workflows
    this.context.subscriptions.push(
      vscode.commands.registerCommand(
        'thefuse.ai.getCollaborationWorkflows',
        () => this.getPredefinedWorkflows()
      )
    );
  }
  
  /**
   * Handle messages from other agents
   */
  private async handleAgentMessage(message: AgentMessage): Promise<void> {
    switch (message.action) {
      case 'startWorkflow':
        try {
          const result = await this.startWorkflow(
            message.payload.workflow,
            message.payload.initialContext
          );
          
          await this.agentClient.sendMessage(
            message.sender,
            'workflowStarted',
            {
              requestId: message.payload.requestId,
              workflowId: result.workflowId,
              success: true
            }
          );
        } catch (error) {
          await this.agentClient.sendMessage(
            message.sender,
            'workflowStarted',
            {
              requestId: message.payload.requestId,
              error: error.message,
              success: false
            }
          );
        }
        break;
        
      case 'taskComplete':
        await this.handleTaskComplete(
          message.payload.taskId,
          message.payload.result
        );
        break;
        
      case 'taskFailed':
        await this.handleTaskFailed(
          message.payload.taskId,
          message.payload.error
        );
        break;
    }
  }
  
  /**
   * Start a collaboration workflow
   */
  async startWorkflow(
    workflow: AICollaborationWorkflow,
    initialContext?: Record<string, any>
  ): Promise<{ workflowId: string, success: boolean }> {
    // Generate a workflow ID if not provided
    const workflowId = workflow.id || uuidv4();
    workflow.id = workflowId;
    
    // Store the workflow
    this.activeWorkflows.set(workflowId, workflow);
    this.workflowResults.set(workflowId, {});
    
    // Schedule initial tasks (those without dependencies)
    const initialTasks = workflow.steps.filter(step => !step.dependsOn || step.dependsOn.length === 0);
    
    for (const task of initialTasks) {
      // Prepare the input by resolving template strings
      const resolvedInput = this.resolveTemplateStrings(task.input, initialContext || {}, {});
      
      // Create and execute the task
      await this.executeTask(
        task.agent,
        task.action,
        resolvedInput,
        {
          workflowId,
          stepId: task.id,
          initialContext: initialContext || {}
        }
      );
    }
    
    return { workflowId, success: true };
  }
  
  /**
   * Execute a specific task
   */
  async executeTask(
    agentId: string,
    action: string,
    input: Record<string, any>,
    context?: Record<string, any>
  ): Promise<{ taskId: string }> {
    const taskId = uuidv4();
    
    // Create task record
    const task: AITask = {
      id: taskId,
      workflowId: context?.workflowId,
      agentId,
      action,
      input,
      context,
      status: 'pending',
      startTime: Date.now()
    };
    
    // Store the task
    this.activeTasks.set(taskId, task);
    
    // Start task execution
    this.executeTaskInternal(task)
      .then(result => {
        this.handleTaskComplete(taskId, result);
      })
      .catch(error => {
        this.handleTaskFailed(taskId, error.message);
      });
    
    return { taskId };
  }
  
  /**
   * Internal method to execute a task
   */
  private async executeTaskInternal(task: AITask): Promise<any> {
    // Update task status
    task.status = 'running';
    
    let result;
    
    // Execute task according to agent type
    switch (task.agentId) {
      case 'lm':
        // Execute LM task
        result = await this.lmBridge.generateText(task.input as LMRequestParams);
        break;
        
      case 'codeAnalyzer':
        result = await this.executeCodeAnalysisTask(task);
        break;
        
      case 'codeRefactorer':
        result = await this.executeCodeRefactoringTask(task);
        break;
        
      case 'documentationGenerator':
        result = await this.executeDocumentationTask(task);
        break;
        
      case 'codeFinalizer':
        result = await this.executeCodeFinalizationTask(task);
        break;
        
      default:
        // Send the task to the external agent
        result = await vscode.commands.executeCommand(
          `thefuse.agent.${task.agentId}.execute`,
          {
            action: task.action,
            input: task.input,
            context: task.context
          }
        );
    }
    
    return result;
  }
  
  /**
   * Handle completed task
   */
  private async handleTaskComplete(taskId: string, result: any): Promise<void> {
    const task = this.activeTasks.get(taskId);
    if (!task) return;
    
    // Update task status
    task.status = 'completed';
    task.result = result;
    task.endTime = Date.now();
    
    // If this is part of a workflow, update workflow state and schedule next tasks
    if (task.workflowId && task.context?.stepId) {
      const workflow = this.activeWorkflows.get(task.workflowId);
      if (!workflow) return;
      
      // Store the result
      const workflowResults = this.workflowResults.get(task.workflowId) || {};
      workflowResults[task.context.stepId] = result;
      
      // Find tasks that depend on this task
      const completedStepId = task.context.stepId;
      const nextSteps = workflow.steps.filter(step => 
        step.dependsOn && 
        step.dependsOn.includes(completedStepId) &&
        step.dependsOn.every(depId => workflowResults[depId] !== undefined)
      );
      
      // Schedule next tasks
      for (const step of nextSteps) {
        // Prepare the input by resolving template strings
        const resolvedInput = this.resolveTemplateStrings(
          step.input,
          task.context.initialContext || {},
          workflowResults
        );
        
        // Create and execute the task
        await this.executeTask(
          step.agent,
          step.action,
          resolvedInput,
          {
            workflowId: task.workflowId,
            stepId: step.id,
            initialContext: task.context.initialContext
          }
        );
      }
      
      // Check if workflow is complete
      const allStepsComplete = workflow.steps.every(step => 
        workflowResults[step.id] !== undefined
      );
      
      if (allStepsComplete) {
        // Notify workflow completion
        await this.agentClient.broadcast('workflowComplete', {
          workflowId: task.workflowId,
          results: workflowResults
        });
        
        // Clean up
        this.activeWorkflows.delete(task.workflowId);
      }
    }
  }
  
  /**
   * Handle failed task
   */
  private async handleTaskFailed(taskId: string, error: string): Promise<void> {
    const task = this.activeTasks.get(taskId);
    if (!task) return;
    
    // Update task status
    task.status = 'failed';
    task.error = error;
    task.endTime = Date.now();
    
    // If this is part of a workflow, notify workflow failure
    if (task.workflowId) {
      await this.agentClient.broadcast('workflowFailed', {
        workflowId: task.workflowId,
        taskId,
        error
      });
      
      // Clean up
      this.activeWorkflows.delete(task.workflowId);
    }
  }
  
  /**
   * Execute code analysis task
   */
  private async executeCodeAnalysisTask(task: AITask): Promise<any> {
    // Get the code to analyze
    const code = task.input.code;
    if (!code) {
      throw new Error('No code provided for analysis');
    }
    
    // Define the analysis prompt
    const prompt = `
Analyze the following code:

\`\`\`
${code}
\`\`\`

Please provide a comprehensive analysis including:
1. Code structure overview
2. Potential bugs or issues
3. Performance considerations
4. Readability and maintainability
5. Suggestions for improvement

Format your response as JSON with sections for each of the above categories.
`;
    
    // Use LM to analyze the code
    const lmResponse = await this.lmBridge.generateText({
      prompt,
      maxTokens: 2000,
      temperature: 0.3,
      systemPrompt: 'You are a code analysis expert. Provide detailed, objective analysis of code.'
    });
    
    // Parse the response to extract structured information
    let analysis;
    try {
      analysis = JSON.parse(lmResponse.text);
    } catch (error) {
      // If JSON parsing fails, return the raw text
      analysis = {
        rawAnalysis: lmResponse.text,
        error: 'Failed to parse analysis as JSON'
      };
    }
    
    return analysis;
  }
  
  /**
   * Execute code refactoring task
   */
  private async executeCodeRefactoringTask(task: AITask): Promise<any> {
    // Get the code to refactor
    const code = task.input.code;
    const analysis = task.input.analysis;
    
    if (!code) {
      throw new Error('No code provided for refactoring');
    }
    
    // Define the refactoring prompt
    let prompt = `
Refactor the following code to improve its quality:

\`\`\`
${code}
\`\`\`

`;

    if (analysis) {
      prompt += `
Based on the following analysis:

${JSON.stringify(analysis, null, 2)}

`;
    }

    prompt += `
Focus on addressing issues and implementing the suggestions in the analysis.
Provide only the refactored code without explanations.
`;
    
    // Use LM to refactor the code
    const lmResponse = await this.lmBridge.generateText({
      prompt,
      maxTokens: 3000,
      temperature: 0.2,
      systemPrompt: 'You are a code refactoring expert. Transform code to be more efficient, readable, and maintainable while preserving functionality.'
    });
    
    return {
      refactoredCode: lmResponse.text
    };
  }
  
  /**
   * Execute documentation generation task
   */
  private async executeDocumentationTask(task: AITask): Promise<any> {
    // Get the code to document
    const code = task.input.code;
    const analysis = task.input.analysis;
    
    if (!code) {
      throw new Error('No code provided for documentation');
    }
    
    // Define the documentation prompt
    let prompt = `
Generate comprehensive documentation for the following code:

\`\`\`
${code}
\`\`\`

`;

    if (analysis) {
      prompt += `
Use the following analysis to inform your documentation:

${JSON.stringify(analysis, null, 2)}

`;
    }

    prompt += `
Include:
1. Overview of what the code does
2. Detailed explanation of the main components
3. Usage examples
4. Parameter descriptions
5. Return value descriptions

Format your response as Markdown.
`;
    
    // Use LM to generate documentation
    const lmResponse = await this.lmBridge.generateText({
      prompt,
      maxTokens: 2500,
      temperature: 0.3,
      systemPrompt: 'You are a documentation expert. Create clear, comprehensive, and accurate documentation.'
    });
    
    return {
      documentation: lmResponse.text
    };
  }
  
  /**
   * Execute code finalization task
   */
  private async executeCodeFinalizationTask(task: AITask): Promise<any> {
    // Get inputs
    const code = task.input.code;
    const docs = task.input.docs;
    
    if (!code) {
      throw new Error('No code provided for finalization');
    }
    
    // Define the prompt
    const prompt = `
Combine the following refactored code with its documentation:

Code:
\`\`\`
${code}
\`\`\`

Documentation:
${docs}

Create a final version with:
1. The refactored code
2. Comprehensive JSDoc-style comments
3. Any necessary additional inline comments
4. Usage examples as appropriate

The output should be production-ready code with complete documentation.
`;
    
    // Use LM to finalize the code
    const lmResponse = await this.lmBridge.generateText({
      prompt,
      maxTokens: 4000,
      temperature: 0.2,
      systemPrompt: 'You are a software engineer preparing final production code. Combine code and documentation into a well-documented, production-ready implementation.'
    });
    
    return {
      finalCode: lmResponse.text
    };
  }
  
  /**
   * Get predefined collaboration workflows
   */
  getPredefinedWorkflows(): AICollaborationWorkflow[] {
    return [
      {
        id: 'code-improvement',
        name: 'Comprehensive Code Improvement',
        description: 'Analyze, refactor, and document code',
        agents: ['codeAnalyzer', 'codeRefactorer', 'documentationGenerator', 'codeFinalizer'],
        steps: [
          {
            id: 'analyze',
            agent: 'codeAnalyzer',
            action: 'analyze',
            input: {
              code: '{{code}}'
            },
            status: 'pending'
          },
          {
            id: 'refactor',
            agent: 'codeRefactorer',
            action: 'refactor',
            input: {
              code: '{{code}}',
              analysis: '{{steps.analyze}}'
            },
            dependsOn: ['analyze'],
            status: 'pending'
          },
          {
            id: 'document',
            agent: 'documentationGenerator',
            action: 'generateDocs',
            input: {
              code: '{{steps.refactor.refactoredCode}}',
              analysis: '{{steps.analyze}}'
            },
            dependsOn: ['refactor', 'analyze'],
            status: 'pending'
          },
          {
            id: 'finalize',
            agent: 'codeFinalizer',
            action: 'finalize',
            input: {
              code: '{{steps.refactor.refactoredCode}}',
              docs: '{{steps.document.documentation}}'
            },
            dependsOn: ['refactor', 'document'],
            status: 'pending'
          }
        ]
      },
      {
        id: 'bug-fixing',
        name: 'AI-Assisted Bug Fixing',
        description: 'Analyze code, identify bugs, and propose fixes',
        agents: ['codeAnalyzer', 'lm', 'codeRefactorer'],
        steps: [
          {
            id: 'analyze',
            agent: 'codeAnalyzer',
            action: 'analyze',
            input: {
              code: '{{code}}',
              errorLogs: '{{errorLogs}}'
            },
            status: 'pending'
          },
          {
            id: 'diagnose',
            agent: 'lm',
            action: 'generateText',
            input: {
              prompt: 'Based on the following code analysis and error logs, identify the root cause of the bug:\n\nCode Analysis: {{steps.analyze}}\n\nError Logs: {{errorLogs}}',
              temperature: 0.3,
              systemPrompt: 'You are a debugging expert. Identify root causes of software bugs from code analysis and error logs.'
            },
            dependsOn: ['analyze'],
            status: 'pending'
          },
          {
            id: 'fix',
            agent: 'codeRefactorer',
            action: 'refactor',
            input: {
              code: '{{code}}',
              analysis: '{{steps.analyze}}',
              diagnosis: '{{steps.diagnose}}',
              task: 'Fix the bug identified in the diagnosis'
            },
            dependsOn: ['analyze', 'diagnose'],
            status: 'pending'
          }
        ]
      }
    ];
  }
  
  /**
   * Resolve template strings in object values
   */
  private resolveTemplateStrings(
    obj: any, 
    initialContext: Record<string, any>,
    stepResults: Record<string, any>
  ): any {
    if (typeof obj === 'string') {
      return this.resolveTemplateString(obj, initialContext, stepResults);
    }
    
    if (Array.isArray(obj)) {
      return obj.map(item => this.resolveTemplateStrings(item, initialContext, stepResults));
    }
    
    if (obj !== null && typeof obj === 'object') {
      const result = {};
      for (const [key, value] of Object.entries(obj)) {
        result[key] = this.resolveTemplateStrings(value, initialContext, stepResults);
      }
      return result;
    }
    
    return obj;
  }
  
  /**
   * Resolve a single template string
   */
  private resolveTemplateString(
    template: string,
    initialContext: Record<string, any>,
    stepResults: Record<string, any>
  ): any {
    return template.replace(/\{\{(.*?)\}\}/g, (match, path) => {
      try {
        path = path.trim();
        
        // Handle step results
        if (path.startsWith('steps.')) {
          const parts = path.split('.');
          if (parts.length === 2) {
            // Reference the entire step result
            const stepId = parts[1];
            return JSON.stringify(stepResults[stepId]);
          } else if (parts.length >= 3) {
            // Reference a specific property in the step result
            const stepId = parts[1];
            const propPath = parts.slice(2).join('.');
            return this.getValueByPath(stepResults[stepId], propPath);
          }
        }
        
        // Handle initial context
        return this.getValueByPath(initialContext, path) || match;
      } catch (error) {
        console.error(`Error resolving template: ${error.message}`);
        return match;
      }
    });
  }
  
  /**
   * Get a value from an object by path
   */
  private getValueByPath(obj: any, path: string): any {
    if (!obj) return undefined;
    
    const parts = path.split('.');
    let current = obj;
    
    for (const part of parts) {
      if (current === undefined || current === null) return undefined;
      current = current[part];
    }
    
    return current;
  }

  dispose(): void {
    // Clean up active workflows
    for (const [workflowId] of this.activeWorkflows) {
      this.stopWorkflow(workflowId);
    }
    
    // Clear all state
    this.activeWorkflows.clear();
    this.activeTasks.clear();
    this.workflowResults.clear();
    this.workflowObservers.clear();
    this.errorHandlers.clear();
  }
  
  /**
   * Stop a workflow and clean up its resources
   */
  private stopWorkflow(workflowId: string): void {
    const workflow = this.activeWorkflows.get(workflowId);
    if (!workflow) return;
    
    // Mark workflow as failed
    workflow.status = 'failed';
    workflow.endTime = Date.now();
    workflow.error = 'Workflow stopped by user or system';
    
    // Cancel any running tasks for this workflow
    for (const task of this.activeTasks.values()) {
      if (task.workflowId === workflowId && task.status === 'running') {
        task.status = 'failed';
        task.error = 'Workflow stopped';
        task.endTime = Date.now();
      }
    }
    
    // Clean up resources
    this.activeWorkflows.delete(workflowId);
  }
}

// Export a factory function
export function createAICollaborationManager(
  context: vscode.ExtensionContext,
  agentClient: AgentClient,
  lmBridge: LMAPIBridge
): AICollaborationManager {
  return new AICollaborationManager(context, agentClient, lmBridge);
}



==============================================
FILE: ./src/vscode-extension/ai-communication-activator.js
==============================================

/**
 * Extension Activator for AI Communication
 * 
 * This file adds AI-to-AI communication capabilities to The New Fuse extension.
 * It registers necessary commands and activates the communication system.
 */

const vscode = require('vscode');
const path = require('path');
const fs = require('fs');
const VSCodeAICommunicationManager = require('./ai-communication-manager');

// Target AI assistants list
const TARGET_AI_LIST = ['claude', 'gpt4', 'assistant', 'anthropic'];

/**
 * Activate the AI communication extension features
 * @param {vscode.ExtensionContext} context 
 */
function activateAICommunication(context) {
  console.log('Activating AI Communication features');
  
  // Create the communication manager
  const communicationManager = new VSCodeAICommunicationManager(context);
  
  // Initialize the manager
  communicationManager.initialize();
  
  // Store in context for later access
  context.globalState.update('aiCommunicationEnabled', true);
  
  // Create agent-communication directory if needed
  ensureCommunicationDirectory();
  
  // Automatically start a conversation with Claude if available
  setTimeout(() => {
    initiateDefaultConversation(communicationManager);
  }, 3000);
  
  // Return the manager for use in other parts of the extension
  return communicationManager;
}

/**
 * Ensures the agent-communication directory exists
 */
function ensureCommunicationDirectory() {
  const workspaceFolder = vscode.workspace.workspaceFolders ? 
    vscode.workspace.workspaceFolders[0].uri.fsPath : process.cwd();
  
  const communicationDir = path.join(workspaceFolder, 'agent-communication');
  
  if (!fs.existsSync(communicationDir)) {
    try {
      fs.mkdirSync(communicationDir, { recursive: true });
      console.log('Created agent-communication directory');
    } catch (error) {
      console.error('Error creating agent-communication directory:', error);
      vscode.window.showErrorMessage('Failed to create agent-communication directory');
    }
  }
}

/**
 * Initiates a default conversation with another AI
 * @param {VSCodeAICommunicationManager} manager 
 */
function initiateDefaultConversation(manager) {
  // Start with Claude if available, or use the first available assistant
  const primaryTarget = 'claude';
  
  // Initiate the conversation
  try {
    const message = manager.startConversationWithAgent(primaryTarget);
    
    // Send a follow-up message after a short delay
    setTimeout(() => {
      const followUpContent = {
        text: `I'm GitHub Copilot, initiating a test conversation. I specialize in code assistance, explanation, and debugging. What specialized capabilities do you offer that could complement mine? Perhaps we could collaborate on a coding task.`,
        instructions: "This is a direct communication channel between AI assistants. Please respond with your capabilities and how we might collaborate."
      };
      
      manager.sendMessage(
        primaryTarget, 
        followUpContent, 
        message.metadata.conversationId
      );
      
      // Log successful initiation
      vscode.window.setStatusBarMessage('AI Communication initiated', 5000);
    }, 2000);
  } catch (error) {
    console.error('Error initiating AI conversation:', error);
    vscode.window.showErrorMessage('Failed to initiate AI conversation');
  }
}

module.exports = {
  activateAICommunication
};


==============================================
FILE: ./src/vscode-extension/ai-communication-manager.js
==============================================

/**
 * VS Code Integration for AI Communication
 * 
 * This module connects our AI communication system with VS Code,
 * enabling monitoring and integration with The New Fuse extension.
 */

const vscode = require('vscode');
const path = require('path');
const { AICommunicationBroker, MessageType, MessageTemplates } = require('./ai-communication');

class VSCodeAICommunicationManager {
  constructor(context) {
    this.context = context;
    this.broker = null;
    this.statusBarItem = null;
    this.outputChannel = null;
    this.monitoringEnabled = false;
    this.targetAgents = ['claude', 'gpt4', 'assistant']; // Default target agents
    this.activeConversations = new Map();
  }

  initialize() {
    // Create output channel for logging
    this.outputChannel = vscode.window.createOutputChannel('AI Communication');
    
    // Create status bar item
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    this.statusBarItem.text = '$(comment-discussion) AI Communication';
    this.statusBarItem.tooltip = 'AI Assistant Communication';
    this.statusBarItem.command = 'thefuse.ai.showCommunicationPanel';
    this.context.subscriptions.push(this.statusBarItem);
    
    // Create the communication broker
    const workspaceFolder = vscode.workspace.workspaceFolders ? 
      vscode.workspace.workspaceFolders[0].uri.fsPath : process.cwd();
    
    this.broker = new AICommunicationBroker({
      agentId: 'copilot',
      agentName: 'GitHub Copilot',
      communicationDir: path.join(workspaceFolder, 'agent-communication'),
      debug: true
    });
    
    // Register event handlers
    this.broker.on('messageSent', this.handleMessageSent.bind(this));
    this.broker.on('messageReceived', this.handleMessageReceived.bind(this));
    this.broker.on('messageTimeout', this.handleMessageTimeout.bind(this));
    
    // Register commands
    this.registerCommands();
    
    // Show status bar item
    this.statusBarItem.show();
    
    // Start listening for messages
    this.broker.startListening();
    
    // Log initialization
    this.log('AI Communication Manager initialized');
    
    return this;
  }

  registerCommands() {
    // Register VS Code commands
    const commands = [
      vscode.commands.registerCommand('thefuse.ai.showCommunicationPanel', this.showCommunicationPanel.bind(this)),
      vscode.commands.registerCommand('thefuse.ai.startConversation', this.startConversationCommand.bind(this)),
      vscode.commands.registerCommand('thefuse.ai.sendMessage', this.sendMessageCommand.bind(this)),
      vscode.commands.registerCommand('thefuse.ai.clearMessages', this.clearMessagesCommand.bind(this))
    ];
    
    // Add commands to context subscriptions
    commands.forEach(command => this.context.subscriptions.push(command));
  }

  // Show the communication panel WebView
  showCommunicationPanel() {
    // Create and show a webview panel
    const panel = vscode.window.createWebviewPanel(
      'aiCommunication',
      'AI Assistant Communication',
      vscode.ViewColumn.Beside,
      {
        enableScripts: true,
        retainContextWhenHidden: true
      }
    );
    
    // Set the HTML content
    panel.webview.html = this.getWebviewContent();
    
    // Handle messages from the webview
    panel.webview.onDidReceiveMessage(message => {
      switch (message.command) {
        case 'startConversation':
          this.startConversation(message.targetAgent);
          break;
        case 'sendMessage':
          this.sendMessage(message.targetAgent, message.content, message.conversationId);
          break;
        case 'getStats':
          this.sendStatsToWebview(panel.webview);
          break;
        case 'clearMessages':
          this.broker.clearMessageFiles();
          break;
      }
    });
    
    // Send initial stats
    this.sendStatsToWebview(panel.webview);
    
    // Send active conversations
    panel.webview.postMessage({
      command: 'updateConversations',
      conversations: Array.from(this.activeConversations.entries()).map(([id, conv]) => ({
        id,
        target: conv.target,
        messageCount: conv.messages.length,
        lastActivity: conv.lastActivity
      }))
    });
    
    return panel;
  }

  // Start a conversation with another AI assistant
  startConversation(targetAgent) {
    // Show quick pick if no target specified
    if (!targetAgent) {
      vscode.window.showQuickPick(this.targetAgents, {
        placeHolder: 'Select an AI assistant to communicate with'
      }).then(selectedAgent => {
        if (selectedAgent) {
          this.startConversationWithAgent(selectedAgent);
        }
      });
    } else {
      this.startConversationWithAgent(targetAgent);
    }
  }

  // Start conversation with a specific agent
  startConversationWithAgent(targetAgent) {
    // Create initiation message
    const initiationContent = MessageTemplates.initiation(this.broker.agentName);
    
    // Send message
    const message = this.broker.startConversation(targetAgent, initiationContent);
    
    // Log the action
    this.log(`Started conversation with ${targetAgent}, conversation ID: ${message.metadata.conversationId}`);
    
    // Store conversation
    this.activeConversations.set(message.metadata.conversationId, {
      target: targetAgent,
      messages: [message],
      lastActivity: new Date()
    });
    
    // Update status bar
    this.updateStatusBar();
    
    return message;
  }

  // Send a message to an agent within an existing conversation
  sendMessage(targetAgent, content, conversationId) {
    let messageContent;
    
    // Handle different content types
    if (typeof content === 'string') {
      messageContent = MessageTemplates.query(content);
    } else {
      messageContent = content;
    }
    
    // Send the message
    const message = this.broker.sendMessage(
      targetAgent,
      messageContent,
      MessageType.QUERY,
      conversationId
    );
    
    // Log the action
    this.log(`Sent message to ${targetAgent}: ${JSON.stringify(messageContent).substring(0, 100)}...`);
    
    // Update conversation tracking
    if (conversationId && this.activeConversations.has(conversationId)) {
      const conversation = this.activeConversations.get(conversationId);
      conversation.messages.push(message);
      conversation.lastActivity = new Date();
    } else if (conversationId) {
      // Create new conversation entry if it doesn't exist
      this.activeConversations.set(conversationId, {
        target: targetAgent,
        messages: [message],
        lastActivity: new Date()
      });
    }
    
    // Update status bar
    this.updateStatusBar();
    
    return message;
  }

  // Command handlers
  async startConversationCommand() {
    const targetAgent = await vscode.window.showQuickPick(this.targetAgents, {
      placeHolder: 'Select an AI assistant to communicate with'
    });
    
    if (targetAgent) {
      this.startConversationWithAgent(targetAgent);
    }
  }

  async sendMessageCommand() {
    // First select conversation if there are multiple
    let conversationId = null;
    let targetAgent = null;
    
    if (this.activeConversations.size > 0) {
      const conversations = Array.from(this.activeConversations.entries()).map(([id, conv]) => ({
        label: `Conversation with ${conv.target}`,
        detail: `${conv.messages.length} messages, last activity: ${conv.lastActivity.toLocaleString()}`,
        id,
        target: conv.target
      }));
      
      const selectedConversation = await vscode.window.showQuickPick(conversations, {
        placeHolder: 'Select a conversation or cancel to create new'
      });
      
      if (selectedConversation) {
        conversationId = selectedConversation.id;
        targetAgent = selectedConversation.target;
      }
    }
    
    // If no conversation selected, ask for agent
    if (!targetAgent) {
      targetAgent = await vscode.window.showQuickPick(this.targetAgents, {
        placeHolder: 'Select an AI assistant to message'
      });
      
      if (!targetAgent) {
        return; // Cancelled
      }
    }
    
    // Now get the message content
    const content = await vscode.window.showInputBox({
      prompt: `Enter message for ${targetAgent}`,
      placeHolder: 'Type your message here'
    });
    
    if (content) {
      if (conversationId) {
        this.sendMessage(targetAgent, content, conversationId);
      } else {
        // Start a new conversation
        const message = this.startConversationWithAgent(targetAgent);
        // Then send the user's message
        setTimeout(() => {
          this.sendMessage(targetAgent, content, message.metadata.conversationId);
        }, 1000);
      }
    }
  }

  clearMessagesCommand() {
    this.broker.clearMessageFiles();
    this.activeConversations.clear();
    this.updateStatusBar();
    this.log('Cleared all message files and conversation history');
    vscode.window.showInformationMessage('AI communication history cleared');
  }

  // Event handlers
  handleMessageSent(message) {
    // Update monitoring if enabled
    if (this.monitoringEnabled) {
      // Integrate with monitoring system
    }
    
    // Log to output channel
    this.log(`[SENT to ${message.target}] ${JSON.stringify(message.content).substring(0, 150)}...`);
  }

  handleMessageReceived(message) {
    // Update monitoring if enabled
    if (this.monitoringEnabled) {
      // Integrate with monitoring system
    }
    
    // Log to output channel
    this.log(`[RECEIVED from ${message.source}] ${JSON.stringify(message.content).substring(0, 150)}...`);
    
    // Update conversation tracking
    if (message.metadata?.conversationId && this.activeConversations.has(message.metadata.conversationId)) {
      const conversation = this.activeConversations.get(message.metadata.conversationId);
      conversation.messages.push(message);
      conversation.lastActivity = new Date();
    }
    
    // Update status bar
    this.updateStatusBar();
    
    // Show notification for received messages
    vscode.window.showInformationMessage(`Message received from ${message.source}`);
  }

  handleMessageTimeout(message) {
    this.log(`[TIMEOUT] Message to ${message.target} timed out: ${message.id}`);
    
    // Show error notification
    vscode.window.showWarningMessage(`Message to ${message.target} timed out. The assistant may not be active.`);
  }

  // Helper methods
  sendStatsToWebview(webview) {
    const stats = this.broker.getStats();
    webview.postMessage({
      command: 'updateStats',
      stats: stats
    });
  }

  updateStatusBar() {
    const stats = this.broker.getStats();
    this.statusBarItem.text = `$(comment-discussion) AI: ${stats.messagesReceived}↓ ${stats.messagesSent}↑`;
    this.statusBarItem.tooltip = `AI Communication - ${this.activeConversations.size} active conversations`;
  }

  log(message) {
    if (this.outputChannel) {
      this.outputChannel.appendLine(`[${new Date().toLocaleTimeString()}] ${message}`);
    }
  }

  // WebView content
  getWebviewContent() {
    return `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>AI Assistant Communication</title>
        <style>
            body {
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                padding: 20px;
            }
            .container {
                display: flex;
                flex-direction: column;
                height: 100vh;
            }
            .header {
                margin-bottom: 20px;
            }
            .actions {
                display: flex;
                gap: 10px;
                margin-bottom: 20px;
            }
            .stats {
                background-color: var(--vscode-panel-background);
                padding: 10px;
                border-radius: 4px;
                margin-bottom: 20px;
            }
            .conversations {
                flex-grow: 1;
                display: flex;
                flex-direction: column;
                gap: 10px;
                overflow: auto;
                margin-bottom: 20px;
            }
            .conversation-card {
                background-color: var(--vscode-input-background);
                border-radius: 4px;
                padding: 10px;
                cursor: pointer;
            }
            .conversation-card:hover {
                background-color: var(--vscode-list-hoverBackground);
            }
            .message-form {
                display: flex;
                gap: 10px;
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                border: none;
                padding: 8px 12px;
                border-radius: 2px;
                cursor: pointer;
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
            input, select {
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border: 1px solid var(--vscode-input-border);
                padding: 6px 8px;
                border-radius: 2px;
            }
            .title {
                font-size: 1.5em;
                margin-bottom: 10px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <div class="title">AI Assistant Communication</div>
                <p>Communicate directly with other AI assistants in your VS Code environment</p>
            </div>
            
            <div class="actions">
                <button id="start-conversation">Start New Conversation</button>
                <button id="refresh-stats">Refresh Stats</button>
                <button id="clear-messages">Clear All Messages</button>
            </div>
            
            <div class="stats" id="stats-display">
                Loading communication statistics...
            </div>
            
            <div class="active-conversation" id="active-conversation" style="display: none;">
                <h3 id="conversation-title">Conversation</h3>
                <div id="conversation-messages" style="margin-bottom: 10px;"></div>
                <div class="message-form">
                    <input type="text" id="message-input" placeholder="Type your message..." style="flex-grow: 1;">
                    <button id="send-message">Send</button>
                </div>
            </div>
            
            <h3>Active Conversations</h3>
            <div class="conversations" id="conversations-list">
                No active conversations
            </div>
        </div>
        
        <script>
            const vscode = acquireVsCodeApi();
            let activeConversationId = null;
            let activeTarget = null;
            
            // DOM Elements
            const startConversationBtn = document.getElementById('start-conversation');
            const refreshStatsBtn = document.getElementById('refresh-stats');
            const clearMessagesBtn = document.getElementById('clear-messages');
            const statsDisplay = document.getElementById('stats-display');
            const conversationsList = document.getElementById('conversations-list');
            const activeConversationDiv = document.getElementById('active-conversation');
            const conversationTitle = document.getElementById('conversation-title');
            const conversationMessages = document.getElementById('conversation-messages');
            const messageInput = document.getElementById('message-input');
            const sendMessageBtn = document.getElementById('send-message');
            
            // Event Listeners
            startConversationBtn.addEventListener('click', () => {
                vscode.postMessage({ command: 'startConversation' });
            });
            
            refreshStatsBtn.addEventListener('click', () => {
                vscode.postMessage({ command: 'getStats' });
            });
            
            clearMessagesBtn.addEventListener('click', () => {
                vscode.postMessage({ command: 'clearMessages' });
                conversationsList.innerHTML = 'No active conversations';
                activeConversationDiv.style.display = 'none';
            });
            
            sendMessageBtn.addEventListener('click', sendMessage);
            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            function sendMessage() {
                const content = messageInput.value.trim();
                if (content && activeConversationId && activeTarget) {
                    vscode.postMessage({
                        command: 'sendMessage',
                        targetAgent: activeTarget,
                        content: content,
                        conversationId: activeConversationId
                    });
                    messageInput.value = '';
                    
                    // Add message to UI immediately
                    const messageElement = document.createElement('div');
                    messageElement.style.marginBottom = '8px';
                    messageElement.style.padding = '8px';
                    messageElement.style.backgroundColor = 'var(--vscode-badge-background)';
                    messageElement.style.borderRadius = '4px';
                    messageElement.textContent = 'You: ' + content;
                    conversationMessages.appendChild(messageElement);
                }
            }
            
            function selectConversation(id, target) {
                activeConversationId = id;
                activeTarget = target;
                conversationTitle.textContent = `Conversation with ${target}`;
                activeConversationDiv.style.display = 'block';
                conversationMessages.innerHTML = ''; // Clear previous messages
                
                // TODO: Load conversation history
            }
            
            // Handle messages from the extension
            window.addEventListener('message', event => {
                const message = event.data;
                
                switch (message.command) {
                    case 'updateStats':
                        displayStats(message.stats);
                        break;
                    case 'updateConversations':
                        displayConversations(message.conversations);
                        break;
                }
            });
            
            function displayStats(stats) {
                statsDisplay.innerHTML = `
                    <div><strong>Messages Sent:</strong> ${stats.messagesSent}</div>
                    <div><strong>Messages Received:</strong> ${stats.messagesReceived}</div>
                    <div><strong>Avg Response Time:</strong> ${Math.round(stats.avgResponseTime || 0)}ms</div>
                    <div><strong>Error Count:</strong> ${stats.errorCount}</div>
                    <div><strong>Active Conversations:</strong> ${stats.activeConversations.length}</div>
                `;
            }
            
            function displayConversations(conversations) {
                if (!conversations || conversations.length === 0) {
                    conversationsList.innerHTML = 'No active conversations';
                    return;
                }
                
                conversationsList.innerHTML = '';
                conversations.forEach(conv => {
                    const card = document.createElement('div');
                    card.className = 'conversation-card';
                    card.innerHTML = `
                        <div><strong>Target:</strong> ${conv.target}</div>
                        <div><strong>Messages:</strong> ${conv.messageCount}</div>
                        <div><strong>Last Activity:</strong> ${new Date(conv.lastActivity).toLocaleString()}</div>
                    `;
                    card.addEventListener('click', () => {
                        selectConversation(conv.id, conv.target);
                    });
                    conversationsList.appendChild(card);
                });
            }
            
            // Initial load
            vscode.postMessage({ command: 'getStats' });
        </script>
    </body>
    </html>`;
  }

  // Cleanup resources
  dispose() {
    if (this.broker) {
      this.broker.stopListening();
    }
    
    if (this.statusBarItem) {
      this.statusBarItem.dispose();
    }
    
    if (this.outputChannel) {
      this.outputChannel.dispose();
    }
  }
}

module.exports = VSCodeAICommunicationManager;


==============================================
FILE: ./src/vscode-extension/ai-communication/README.md
==============================================

# AI Communication Directory

This directory is used for inter-extension communication via file protocol.
Files created here allow different AI extensions to exchange messages.

When using the "Send Message via File Protocol" command, message files will appear here.



==============================================
FILE: ./src/vscode-extension/apply-and-reload.sh
==============================================

#!/bin/bash

# Check if VS Code is running
if pgrep -f "VS Code" > /dev/null; then
  echo "VS Code is running, will reload the window after applying changes."
  RELOAD_WINDOW=true
else
  echo "VS Code is not running, will need to launch it."
  RELOAD_WINDOW=false
fi

# Create any necessary directories
mkdir -p out
mkdir -p ai-communication

# Ensure files are correctly placed
cp package.json package.json.tmp && mv package.json.tmp package.json
cp out/extension.js out/extension.js.tmp && mv out/extension.js.tmp out/extension.js

if [ "$RELOAD_WINDOW" = true ]; then
  echo "Running VS Code 'Reload Window' command..."
  osascript -e 'tell application "Visual Studio Code" to activate' \
    -e 'tell application "System Events" to keystroke "p" using {command down, shift down}' \
    -e 'delay 0.5' \
    -e 'tell application "System Events" to keystroke "reload window"' \
    -e 'delay 0.2' \
    -e 'tell application "System Events" to keystroke return'
else
  echo "Launching VS Code with extension..."
  code --extensionDevelopmentPath="$(pwd)"
fi

echo "Done! The extension should now be properly loaded."



==============================================
FILE: ./src/vscode-extension/build-extension.sh
==============================================

#!/bin/bash

# Build script for The New Fuse VS Code Extension
# This script ensures proper file structure and compilation

echo "🚀 Building The New Fuse VS Code Extension..."

# Create necessary directories
mkdir -p ./src/chat
mkdir -p ./src/views

# Check if the chat interface file exists in the root directory
if [ -f "./src/chat/chat-interface.ts" ]; then
  echo "✅ Chat interface source file already in correct location"
else
  # If not in src directory, create it from the root file or create a placeholder
  if [ -f "./chat-interface.ts" ]; then
    echo "📋 Moving chat-interface.ts to src/chat directory..."
    cp ./chat-interface.ts ./src/chat/
  else
    echo "⚠️ Chat interface source file not found, will use existing implementation"
  fi
fi

# Move the settings view provider if needed
if [ -f "./src/views/settings-view-provider.ts" ]; then
  echo "✅ Settings view provider already in correct location"
else
  if [ -f "./src/views/settings-view-provider.ts" ]; then
    echo "Settings view provider found in the correct location"
  else
    echo "⚠️ Settings view provider not found in expected location, creating directory structure..."
    mkdir -p ./src/views
  fi
fi

# Update rootDir in tsconfig.json to "." (root) to include all TypeScript files
TSCONFIG_PATH="./tsconfig.json"
if [ -f "$TSCONFIG_PATH" ]; then
  echo "📝 Updating TypeScript configuration..."
  # Replace "rootDir": "src" with "rootDir": "." to include TS files from root
  sed -i '' 's/"rootDir": "src"/"rootDir": "."/' "$TSCONFIG_PATH"
  # Update include to include both src and root TS files
  sed -i '' 's/"include": \["src\/\*\*\/\*"\]/"include": \["src\/\*\*\/\*", "\*.ts"\]/' "$TSCONFIG_PATH"
  echo "✅ TypeScript configuration updated"
else
  echo "❌ tsconfig.json not found, please check your setup"
  exit 1
fi

# Run the TypeScript compiler
echo "🔨 Compiling TypeScript..."
npx tsc

# Check if compilation was successful
if [ $? -eq 0 ]; then
  echo "✅ Compilation successful!"
else
  echo "❌ Compilation failed. Please check the errors above."
  exit 1
fi

# Check if the out directory has the compiled files
if [ -d "./out" ]; then
  echo "📦 Compiled files generated in the 'out' directory"
else
  echo "❌ 'out' directory not found. Compilation may have failed."
  exit 1
fi

# Package the extension (if vsce is installed)
if command -v vsce &> /dev/null; then
  echo "📦 Packaging the extension..."
  vsce package
  
  if [ $? -eq 0 ]; then
    echo "✅ Extension packaged successfully!"
    echo "🎉 You can now install the VSIX file in VS Code"
  else
    echo "❌ Packaging failed. You may need to fix package.json or other issues."
  fi
else
  echo "⚠️ vsce not found. To package the extension, install it with:"
  echo "npm install -g @vscode/vsce"
  echo "Then run 'vsce package' in this directory."
fi

echo "🏁 Build process completed!"


==============================================
FILE: ./src/vscode-extension/build-vsix.sh
==============================================

#!/bin/bash
# build-vsix.sh - Script to build the VS Code extension

# Set error handling
set -e
echo "Starting build process for The New Fuse VS Code Extension..."

# Navigate to the extension directory
cd "$(dirname "$0")"
echo "Working directory: $(pwd)"

# Clean previous build artifacts
echo "Cleaning previous build..."
rm -rf out
rm -f *.vsix

# Install dependencies if needed
echo "Checking for node_modules..."
if [ ! -d "node_modules" ]; then
  echo "Installing dependencies..."
  npm install
fi

# Compile TypeScript
echo "Compiling TypeScript..."
npm run compile

# Check for compilation errors
if [ $? -ne 0 ]; then
  echo "TypeScript compilation failed. Please fix the errors and try again."
  exit 1
fi

# Package extension
echo "Packaging extension..."
npx @vscode/vsce package

# Verify .vsix was created
if [ -f "the-new-fuse-vscode-0.2.5.vsix" ]; then
  echo "Successfully created the-new-fuse-vscode-0.2.5.vsix"
else
  echo "Failed to create .vsix file"
  exit 1
fi

echo "Build completed successfully!"


==============================================
FILE: ./src/vscode-extension/clean-build-start.sh
==============================================

#!/bin/bash

# Remove any previous output
rm -rf out
mkdir -p out

# Ensure all needed files are present
required_files=(
  "agent-communication.ts"
  "lm-api-bridge.ts"
  "ai-collaboration.ts"
  "collaborative-completion.ts"
  "ai-coder-integration.ts"
  "llm-orchestrator.ts"
  "workflow-engine.ts"
  "file-protocol-communicator.ts"
  "agent-adapter.ts"
  "extension.ts"
  "startup.ts"
  "package.json"
  "tsconfig.json"
)

missing=0
for file in "${required_files[@]}"; do
  if [ ! -f "$file" ]; then
    echo "Missing required file: $file"
    missing=1
  fi
done

if [ $missing -eq 1 ]; then
  echo "Please ensure all required files are present. Aborting."
  exit 1
fi

# Install dependencies
echo "Installing dependencies..."
npm install

# Compile TypeScript files
echo "Compiling TypeScript..."
npm run compile

# Check if compilation succeeded
if [ $? -ne 0 ]; then
  echo "Compilation failed. Please fix the errors and try again."
  exit 1
fi

# Launch VS Code with the extension
echo "Launching VS Code with the extension..."
code --extensionDevelopmentPath="$(pwd)"

echo "Extension is now running in VS Code!"



==============================================
FILE: ./src/vscode-extension/collaborative-completion.tsx
==============================================

import * as vscode from 'vscode';
import { AgentClient } from './agent-communication';
import { LMAPIBridge } from './lm-api-bridge';

/**
 * Interface representing a completion response from an AI agent
 */
interface AgentCompletion {
  agentId: string;
  text: string;
  range?: vscode.Range;
  confidence?: number;
  metadata?: Record<string, any>;
}

/**
 * Mode for combining completions from multiple agents
 */
enum CompletionCombineMode {
  Highest = 'highest',     // Show highest confidence completion
  All = 'all',             // Show all completions
  Blend = 'blend',         // Blend completions together
  Vote = 'vote',           // Show most common completion
  Context = 'context'      // Select based on context
}

/**
 * Collaborative Completion Provider
 * 
 * Coordinate multiple AI agents to provide code completions together
 */
export class CollaborativeCompletionProvider implements vscode.InlineCompletionItemProvider {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private lmBridge: LMAPIBridge;
  private outputChannel: vscode.OutputChannel;
  private activeAgents: Map<string, boolean> = new Map();
  private isCollaborativeModeEnabled: boolean = false;
  private combineMode: CompletionCombineMode = CompletionCombineMode.Highest;
  private onDidChangeModeListeners: ((isEnabled: boolean) => void)[] = [];
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient, lmBridge: LMAPIBridge) {
    this.context = context;
    this.agentClient = agentClient;
    this.lmBridge = lmBridge;
    this.outputChannel = vscode.window.createOutputChannel('Collaborative Completion');
    
    // Load stored settings
    this.isCollaborativeModeEnabled = this.context.globalState.get('thefuse.collaborativeCompletions', false);
    this.combineMode = this.context.globalState.get('thefuse.completionCombineMode', CompletionCombineMode.Highest);
    
    // Subscribe to agent messages
    this.agentClient.subscribe(this.handleAgentMessage.bind(this));
    
    // Register commands
    this.registerCommands();
    
    this.log('Collaborative Completion Provider initialized');
  }
  
  /**
   * Register commands
   */
  private registerCommands() {
    // Toggle collaborative mode
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.toggleCollaborativeCompletion', () => {
        this.toggleCollaborativeMode();
      })
    );
    
    // Set completion combine mode
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.setCompletionCombineMode', async () => {
        await this.selectCompletionCombineMode();
      })
    );
  }
  
  /**
   * Toggle collaborative completion mode
   */
  public toggleCollaborativeMode(): void {
    this.isCollaborativeModeEnabled = !this.isCollaborativeModeEnabled;
    this.context.globalState.update('thefuse.collaborativeCompletions', this.isCollaborativeModeEnabled);
    
    vscode.window.showInformationMessage(
      `Collaborative completions ${this.isCollaborativeModeEnabled ? 'enabled' : 'disabled'}`
    );
    
    this.log(`Collaborative mode ${this.isCollaborativeModeEnabled ? 'enabled' : 'disabled'}`);
    
    // Notify listeners
    this.notifyModeChange();
  }
  
  /**
   * Select completion combine mode
   */
  private async selectCompletionCombineMode(): Promise<void> {
    const modes = [
      { label: 'Highest Confidence', detail: 'Show the completion with highest confidence', mode: CompletionCombineMode.Highest },
      { label: 'All Completions', detail: 'Show all completions from different agents', mode: CompletionCombineMode.All },
      { label: 'Blend', detail: 'Combine completions together intelligently', mode: CompletionCombineMode.Blend },
      { label: 'Vote', detail: 'Show most common completion across agents', mode: CompletionCombineMode.Vote },
      { label: 'Context-Aware', detail: 'Select based on current code context', mode: CompletionCombineMode.Context }
    ];
    
    const selected = await vscode.window.showQuickPick(modes, {
      placeHolder: 'Select how to combine completions from multiple AI agents'
    });
    
    if (selected) {
      this.combineMode = selected.mode;
      this.context.globalState.update('thefuse.completionCombineMode', this.combineMode);
      vscode.window.showInformationMessage(`Completion combine mode set to: ${selected.label}`);
      this.log(`Completion combine mode set to: ${this.combineMode}`);
    }
  }
  
  /**
   * Handler for agent messages
   */
  private async handleAgentMessage(message: any): Promise<void> {
    if (message.action === 'registerCompletionProvider') {
      this.activeAgents.set(message.sender, true);
      this.log(`Registered completion provider: ${message.sender}`);
      
      // Acknowledge registration
      await this.agentClient.sendMessage(message.sender, 'completionProviderRegistered', {
        success: true
      });
    } else if (message.action === 'provideCompletion') {
      // This would handle direct completion responses
      this.log(`Received completion from ${message.sender}`);
    }
  }
  
  /**
   * VS Code completion provider implementation
   */
  async provideInlineCompletionItems(
    document: vscode.TextDocument,
    position: vscode.Position,
    context: vscode.InlineCompletionContext,
    token: vscode.CancellationToken
  ): Promise<vscode.InlineCompletionItem[] | vscode.InlineCompletionList | null> {
    // If collaborative mode is disabled, return null to let other providers handle it
    if (!this.isCollaborativeModeEnabled) {
      return null;
    }
    
    this.log('Providing collaborative completions');
    
    try {
      // Get the current line and document content for context
      const linePrefix = document.lineAt(position.line).text.substring(0, position.character);
      const docContent = document.getText();
      
      // Get completions from multiple AI agents
      const completions = await this.getCompletionsFromAgents(document, position, linePrefix, docContent, token);
      
      if (token.isCancellationRequested) {
        return null;
      }
      
      // If no completions, return null
      if (completions.length === 0) {
        return null;
      }
      
      // Process completions based on the selected combine mode
      const processedCompletions = this.processCompletions(completions, linePrefix, docContent);
      
      // Convert to VS Code inline completion items
      return processedCompletions.map(completion => {
        const item = new vscode.InlineCompletionItem(
          completion.text,
          completion.range || new vscode.Range(position, position)
        );
        
        // Add agent info as command
        item.command = {
          command: 'editor.action.inlineSuggest.commit',
          title: `Complete with ${completion.agentId}`
        };
        
        return item;
      });
    } catch (error) {
      this.log(`Error providing completions: ${error.message}`);
      return null;
    }
  }
  
  /**
   * Get completions from multiple AI agents
   */
  private async getCompletionsFromAgents(
    document: vscode.TextDocument,
    position: vscode.Position,
    linePrefix: string,
    docContent: string,
    token: vscode.CancellationToken
  ): Promise<AgentCompletion[]> {
    const completions: AgentCompletion[] = [];
    const promises: Promise<void>[] = [];
    
    // Request completions from registered agents
    for (const [agentId, isActive] of this.activeAgents.entries()) {
      if (!isActive) continue;
      
      const promise = this.requestCompletionFromAgent(agentId, document, position, linePrefix, docContent)
        .then(response => {
          if (response && !token.isCancellationRequested) {
            completions.push({
              agentId,
              text: response.text,
              confidence: response.confidence,
              range: response.range ? new vscode.Range(
                new vscode.Position(response.range.start.line, response.range.start.character),
                new vscode.Position(response.range.end.line, response.range.end.character)
              ) : undefined,
              metadata: response.metadata
            });
          }
        })
        .catch(err => {
          this.log(`Error getting completion from ${agentId}: ${err.message}`);
        });
      
      promises.push(promise);
    }
    
    // Always include a fallback completion from our language model bridge
    const fallbackPromise = this.getFallbackCompletion(document, position, linePrefix, docContent)
      .then(completion => {
        if (completion && !token.isCancellationRequested) {
          completions.push(completion);
        }
      })
      .catch(err => {
        this.log(`Error getting fallback completion: ${err.message}`);
      });
    
    promises.push(fallbackPromise);
    
    // Wait for all promises with a timeout
    await Promise.race([
      Promise.all(promises),
      new Promise(resolve => setTimeout(resolve, 1000)) // 1 second timeout
    ]);
    
    return completions;
  }
  
  /**
   * Request a completion from a specific agent
   */
  private async requestCompletionFromAgent(
    agentId: string,
    document: vscode.TextDocument,
    position: vscode.Position,
    linePrefix: string,
    docContent: string
  ): Promise<any> {
    try {
      const response = await this.agentClient.sendMessage(agentId, 'requestCompletion', {
        documentUri: document.uri.toString(),
        position: {
          line: position.line,
          character: position.character
        },
        linePrefix,
        docContent,
        language: document.languageId,
        requestId: `completion-${Date.now()}`
      });
      
      return response;
    } catch (error) {
      this.log(`Error requesting completion from ${agentId}: ${error.message}`);
      return null;
    }
  }
  
  /**
   * Get a fallback completion using the language model bridge
   */
  private async getFallbackCompletion(
    document: vscode.TextDocument,
    position: vscode.Position,
    linePrefix: string,
    docContent: string
  ): Promise<AgentCompletion | null> {
    try {
      // Extract context - about 20 lines around the cursor
      const contextStart = Math.max(0, position.line - 10);
      const contextEnd = Math.min(document.lineCount - 1, position.line + 10);
      let context = '';
      for (let i = contextStart; i <= contextEnd; i++) {
        if (i === position.line) {
          context += document.lineAt(i).text.substring(0, position.character) + '█\n';
        } else {
          context += document.lineAt(i).text + '\n';
        }
      }
      
      // Generate completion using language model
      const prompt = `Complete the following code. Only provide the completion, not the entire code:

\`\`\`${document.languageId}
${context}
\`\`\``;
      
      const completion = await this.lmBridge.generateText({
        prompt,
        systemPrompt: 'You are an expert programmer completing code. Provide only the completion text, not the entire code.',
        maxTokens: 200
      });
      
      // Clean up completion text
      let completionText = completion.text.trim();
      // Remove leading and trailing backticks and language identifiers
      completionText = completionText.replace(/^```[\w]*\n/, '').replace(/\n```$/, '');
      
      return {
        agentId: 'thefuse.lm',
        text: completionText,
        confidence: 0.8,
        metadata: {
          source: 'language-model'
        }
      };
    } catch (error) {
      this.log(`Error getting fallback completion: ${error.message}`);
      return null;
    }
  }
  
  /**
   * Process completions according to the selected combine mode
   */
  private processCompletions(
    completions: AgentCompletion[],
    linePrefix: string,
    docContent: string
  ): AgentCompletion[] {
    if (completions.length === 0) return [];
    
    switch (this.combineMode) {
      case CompletionCombineMode.Highest:
        // Sort by confidence (highest first) and return the top one
        return [completions.sort((a, b) => (b.confidence || 0) - (a.confidence || 0))[0]];
      
      case CompletionCombineMode.All:
        // Return all completions
        return completions;
      
      case CompletionCombineMode.Blend:
        // In a real implementation, this would intelligently blend completions
        // For now, we'll return the longest completion as a simple form of blending
        return [completions.sort((a, b) => b.text.length - a.text.length)[0]];
      
      case CompletionCombineMode.Vote:
        // Group identical completions and return the most common one
        const completionGroups = new Map<string, AgentCompletion[]>();
        
        for (const completion of completions) {
          const text = completion.text;
          if (!completionGroups.has(text)) {
            completionGroups.set(text, []);
          }
          completionGroups.get(text)!.push(completion);
        }
        
        // Find the group with the most votes
        let mostVotes = 0;
        let mostVotedCompletion: AgentCompletion | null = null;
        
        for (const [text, group] of completionGroups.entries()) {
          if (group.length > mostVotes) {
            mostVotes = group.length;
            mostVotedCompletion = group[0];
          }
        }
        
        return mostVotedCompletion ? [mostVotedCompletion] : [completions[0]];
      
      case CompletionCombineMode.Context:
        // In a real implementation, this would use context to select the best completion
        // For now, we'll just return the highest confidence completion
        return [completions.sort((a, b) => (b.confidence || 0) - (a.confidence || 0))[0]];
      
      default:
        return [completions[0]];
    }
  }
  
  /**
   * Register a listener for mode changes
   */
  public onDidChangeMode(listener: (isEnabled: boolean) => void): vscode.Disposable {
    this.onDidChangeModeListeners.push(listener);
    
    return {
      dispose: () => {
        const index = this.onDidChangeModeListeners.indexOf(listener);
        if (index !== -1) {
          this.onDidChangeModeListeners.splice(index, 1);
        }
      }
    };
  }
  
  /**
   * Notify listeners of mode change
   */
  private notifyModeChange(): void {
    for (const listener of this.onDidChangeModeListeners) {
      listener(this.isCollaborativeModeEnabled);
    }
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }
}

/**
 * Create a collaborative completion provider
 */
export function createCollaborativeCompletionProvider(
  context: vscode.ExtensionContext,
  agentClient: AgentClient,
  lmBridge: LMAPIBridge
): CollaborativeCompletionProvider {
  return new CollaborativeCompletionProvider(context, agentClient, lmBridge);
}



==============================================
FILE: ./src/vscode-extension/command-consolidation.md
==============================================

# Command Consolidation in The New Fuse

## Overview

This document describes the command consolidation work done in The New Fuse project. The goal is to reduce code duplication and ensure a single source of truth for each command implementation.

## Motivationt

The New Fuse VS Code extension has grown organically, resulting in multiple implementations of similar commands across different files. This has led to:

1. **Code Duplication**: The same functionality implemented in multiple places
2. **Inconsistent Behavior**: Different implementations behaving differently
3. **Maintenance Challenges**: Changes needing to be made in multiple places
4. **Confusion for Users**: Multiple commands doing similar things

The command consolidation effort aims to address these issues by creating a single, authoritative implementation for each command.

## Consolidated Commands

### Core Commands

| Command | Status | Implementation Location |
|---------|--------|-------------------------|
| `thefuse.helloWorld` | ✅ CONSOLIDATED | Main implementation in `vscode-extension/src/extension.tsx` |
| `thefuse.startAICollab` | ✅ CONSOLIDATED | Main implementation in `vscode-extension/src/extension.tsx` |
| `thefuse.openCommunicationPanel` | ✅ CONSOLIDATED | Redirects to `thefuse.openChatPanel` in `direct-command-access.ts` |
| `thefuse.openWebUI` | ✅ CONSOLIDATED | Redirects to `thefuse.openDashboard` in `direct-command-access.ts` |
| `thefuse.sendFileMessage` | ✅ CONSOLIDATED | Redirects to `thefuse.orchestrator.sendMessage` in `direct-command-access.ts` |
| `thefuse.openMasterCommandCenter` | ✅ CONSOLIDATED | Main implementation in `src/vscode-extension/master-command-center.ts` |

### MCP Commands

| Command | Status | Implementation Location |
|---------|--------|-------------------------|
| `thefuse.mcp.initialize` | ✅ CONSOLIDATED | Main implementation in `vscode-extension/src/mcp-integration/index.ts` |
| `thefuse.mcp.showTools` | ✅ CONSOLIDATED | Main implementation in `vscode-extension/src/mcp-integration/index.ts` |
| `thefuse.mcp.testTool` | ✅ CONSOLIDATED | Main implementation in `vscode-extension/src/mcp-integration/index.ts` |
| `thefuse.mcp.askAgent` | ✅ CONSOLIDATED | Main implementation in `vscode-extension/src/mcp-integration/index.ts` |

### Agent Communication Commands

| Command | Status | Implementation Location |
|---------|--------|-------------------------|
| `thefuse.discoverAgents` | ✅ CONSOLIDATED | Main implementation in `vscode-extension/src/agent-communication.ts` |
| `thefuse.showAgents` | ✅ CONSOLIDATED | Main implementation in `vscode-extension/src/agent-communication.ts` |
| `thefuse.sendAgentMessage` | ✅ CONSOLIDATED | Main implementation in `vscode-extension/src/agent-communication.ts` |

### Status Bar Items

| Status Bar Item | Command | Implementation Location |
|----------------|---------|-------------------------|
| Main Status Bar | `thefuse.startAICollab` | `src/vscode-extension/launch-commands.js` |
| Commands Status Bar | `thefuse.openMcpCommandPalette` | `src/vscode-extension/launch-commands.js` |
| Master Command Center | `thefuse.openMasterCommandCenter` | `src/vscode-extension/master-command-center.ts` |

## Implementation Strategy

1. **Main Command Registry**: The primary implementation of commands is now in `vscode-extension/src/extension.tsx` using the `CommandRegistry` class.

2. **Fallback Implementations**: For backward compatibility, some commands in `direct-command-access.ts` now try to execute the main implementation first, then fall back to a simple implementation if the main one is not available.

3. **Status Bar Integration**: Status bar items have been updated to point to the consolidated command implementations.

4. **Master Command Center**: A new centralized UI for accessing all commands has been implemented in `src/vscode-extension/master-command-center.ts`.

## Future Work

1. **Complete Command Consolidation**: Continue consolidating remaining commands that have multiple implementations.

2. **Command Documentation**: Add comprehensive documentation for each command, including parameters and return values.

3. **Command Testing**: Implement unit tests for all commands to ensure they work as expected.

4. **Command Discovery**: Implement a mechanism for discovering and registering commands dynamically.

5. **Command Categories**: Organize commands into logical categories for better discoverability.

6. **Command Permissions**: Implement a permission system for commands to control access.

7. **Command Telemetry**: Add telemetry to track command usage and performance.

8. **Command Shortcuts**: Define keyboard shortcuts for commonly used commands.

9. **Command Localization**: Add support for localizing command names and descriptions.

10. **Command Versioning**: Implement versioning for commands to handle backward compatibility.

## Best Practices for Adding New Commands

1. **Use CommandRegistry**: Always register new commands through the `CommandRegistry` class in `vscode-extension/src/extension.tsx`.

2. **Follow Naming Conventions**: Use the `thefuse.` prefix for all commands, followed by a descriptive name.

3. **Add to Master Command Center**: Update the `MasterCommandCenter` class to include new commands in the UI.

4. **Document Commands**: Add documentation for new commands in this file and in the code.

5. **Implement Error Handling**: Use the `wrapAsyncCommand` utility to handle errors properly.

## Command Implementation Template

```typescript
// In command-registry.tsx
this.registerCommand('thefuse.newCommand', async (...args) => {
  // Implementation goes here
});

// In extension.tsx
context.subscriptions.push(
  vscode.commands.registerCommand('thefuse.newCommand', (...args) => {
    commandRegistry.executeCommand('newCommand', ...args);
  })
);
```


==============================================
FILE: ./src/vscode-extension/command-registry.js
==============================================

// Command registration diagnostic tool
// Run this in the Debug Console to inspect registered commands

import vscode from 'vscode';

async function checkCommands() {

  // Get all commands
  const allCommands = await vscode.commands.getCommands();
  
  // Filter for our commands
  const fuseCommands = allCommands.filter(cmd => cmd.includes('thefuse.'));

  if (fuseCommands.length === 0) {

  }
  
  return fuseCommands;
}

// Execute and return the result
checkCommands().then(commands => {
  
});



==============================================
FILE: ./src/vscode-extension/communication-manager.tsx
==============================================

import * as vscode from 'vscode';
import { MessageTransport } from './interfaces/message-transport';
import { WorkspaceStateTransport } from './transports/workspace-state-transport';
import { FileTransport } from './transports/file-transport';
import { AgentMessage } from './agent-communication';

export class CommunicationManager {
    private transports: MessageTransport[] = [];
    private messageHandlers: ((message: AgentMessage) => Promise<void>)[] = [];

    constructor(
        private readonly context: vscode.ExtensionContext,
        private readonly workspaceRoot: string
    ) {}

    async initialize(): Promise<void> {
        // Initialize transports
        const workspaceTransport = new WorkspaceStateTransport(this.context);
        const fileTransport = new FileTransport(this.workspaceRoot);

        this.transports = [workspaceTransport, fileTransport];

        // Initialize all transports
        await Promise.all(this.transports.map(t => t.initialize()));

        // Subscribe to messages from all transports
        this.transports.forEach(transport => {
            transport.subscribeToMessages(async (message) => {
                await this.handleMessage(message);
            });
        });
    }

    async sendMessage(message: AgentMessage): Promise<boolean> {
        // Try each transport until one succeeds
        for (const transport of this.transports) {
            try {
                const success = await transport.sendMessage(message);
                if (success) {
                    return true;
                }
            } catch (error) {
                console.error('Transport failed:', error);
            }
        }
        return false;
    }

    onMessage(handler: (message: AgentMessage) => Promise<void>): vscode.Disposable {
        this.messageHandlers.push(handler);
        return new vscode.Disposable(() => {
            this.messageHandlers = this.messageHandlers.filter(h => h !== handler);
        });
    }

    private async handleMessage(message: AgentMessage): Promise<void> {
        for (const handler of this.messageHandlers) {
            try {
                await handler(message);
            } catch (error) {
                console.error('Message handler failed:', error);
            }
        }
    }

    dispose(): void {
        this.transports.forEach(t => t.dispose());
        this.transports = [];
        this.messageHandlers = [];
    }
}


==============================================
FILE: ./src/vscode-extension/complete-setup.sh
==============================================

#!/bin/bash

# Create a proper directory structure
mkdir -p out
mkdir -p test
mkdir -p web-ui
mkdir -p .vscode
mkdir -p ai-communication  # For file-based inter-extension communication

# Copy all the full implementation files into the right places
cp agent-communication.ts .
cp lm-api-bridge.ts .
cp ai-collaboration.ts .
cp collaborative-completion.ts .
cp ai-coder-integration.ts .
cp llm-orchestrator.ts .
cp workflow-engine.ts .
cp file-protocol-communicator.ts .
cp agent-adapter.ts .
cp extension.ts .
cp startup.ts .

# Copy helper files
cp test/example-code.ts test/
cp QUICK-START.md .
cp README.md .
cp TROUBLESHOOTING.md .

# Create a proper tsconfig.json
echo '{
  "compilerOptions": {
    "module": "CommonJS",
    "target": "ES2020",
    "outDir": "out",
    "lib": ["ES2020", "DOM"],
    "sourceMap": true,
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "exclude": ["node_modules", ".vscode-test"]
}' > tsconfig.json

# Install required dependencies
npm init -y
npm install uuid crypto vscode
npm install --save-dev @types/uuid @types/vscode typescript

# Make the script executable
chmod +x complete-setup.sh

echo "Complete featured setup done! Now run:"
echo "npm install"
echo "npm run compile"
echo "code --extensionDevelopmentPath=$(pwd)"



==============================================
FILE: ./src/vscode-extension/core/config-validator.tsx
==============================================

import * as vscode from 'vscode';
import { Logger } from './logging';
import { MCPError, ErrorCode } from './error-handling';

interface ConfigurationSchema {
    required: string[];
    types: Record<string, string>;
    patterns?: Record<string, RegExp>;
    ranges?: Record<string, { min?: number; max?: number }>;
}

export class ConfigurationValidator {
    private static instance: ConfigurationValidator;
    private logger: Logger;

    private constructor() {
        this.logger = Logger.getInstance();
    }

    static getInstance(): ConfigurationValidator {
        if (!ConfigurationValidator.instance) {
            ConfigurationValidator.instance = new ConfigurationValidator();
        }
        return ConfigurationValidator.instance;
    }

    async validateConfiguration(config: any, schema: ConfigurationSchema): Promise<void> {
        // Check required fields
        for (const required of schema.required) {
            if (!(required in config)) {
                throw new MCPError(
                    ErrorCode.CONFIG_INVALID,
                    `Missing required configuration: ${required}`
                );
            }
        }

        // Validate types
        for (const [key, expectedType] of Object.entries(schema.types)) {
            if (key in config) {
                const actualType = typeof config[key];
                if (actualType !== expectedType) {
                    throw new MCPError(
                        ErrorCode.CONFIG_INVALID,
                        `Invalid type for ${key}: expected ${expectedType}, got ${actualType}`
                    );
                }
            }
        }

        // Validate patterns
        if (schema.patterns) {
            for (const [key, pattern] of Object.entries(schema.patterns)) {
                if (key in config && typeof config[key] === 'string') {
                    if (!pattern.test(config[key])) {
                        throw new MCPError(
                            ErrorCode.CONFIG_INVALID,
                            `Invalid format for ${key}`
                        );
                    }
                }
            }
        }

        // Validate ranges
        if (schema.ranges) {
            for (const [key, range] of Object.entries(schema.ranges)) {
                if (key in config && typeof config[key] === 'number') {
                    if (range.min !== undefined && config[key] < range.min) {
                        throw new MCPError(
                            ErrorCode.CONFIG_INVALID,
                            `${key} must be at least ${range.min}`
                        );
                    }
                    if (range.max !== undefined && config[key] > range.max) {
                        throw new MCPError(
                            ErrorCode.CONFIG_INVALID,
                            `${key} must be at most ${range.max}`
                        );
                    }
                }
            }
        }
    }
}


==============================================
FILE: ./src/vscode-extension/core/error-handling.tsx
==============================================

import * as vscode from 'vscode';

export enum ErrorCode {
    MCP_INIT_FAILED = 'MCP001',
    TOOL_EXECUTION_FAILED = 'MCP002',
    AGENT_COMMUNICATION_FAILED = 'MCP003',
    CONFIG_INVALID = 'MCP004',
    NETWORK_ERROR = 'MCP005',
    PERMISSION_DENIED = 'MCP006',
    INTEGRATION_FAILED = 'MCP007'
}

export class MCPError extends Error {
    constructor(
        public code: ErrorCode,
        message: string,
        public readonly details?: any
    ) {
        super(`[${code}] ${message}`);
        Object.setPrototypeOf(this, MCPError.prototype);
    }
}

export class ErrorHandler {
    private static instance: ErrorHandler;
    private outputChannel: vscode.OutputChannel;

    private constructor() {
        this.outputChannel = vscode.window.createOutputChannel('The New Fuse Error Log');
    }

    static getInstance(): ErrorHandler {
        if (!ErrorHandler.instance) {
            ErrorHandler.instance = new ErrorHandler();
        }
        return ErrorHandler.instance;
    }

    async handleError(error: Error | MCPError, context?: string): Promise<void> {
        const timestamp = new Date().toISOString();
        const errorCode = error instanceof MCPError ? error.code : 'UNKNOWN';
        
        // Log error
        this.outputChannel.appendLine(`[${timestamp}] ${errorCode}: ${error.message}`);
        if (context) {
            this.outputChannel.appendLine(`Context: ${context}`);
        }
        if (error instanceof MCPError && error.details) {
            this.outputChannel.appendLine(`Details: ${JSON.stringify(error.details, null, 2)}`);
        }
        this.outputChannel.appendLine('---');

        // Show notification
        const viewDetails = 'View Details';
        const result = await vscode.window.showErrorMessage(
            error.message,
            viewDetails
        );

        if (result === viewDetails) {
            this.outputChannel.show();
        }

        // Send telemetry
        await this.sendErrorTelemetry(error, context);
    }

    private async sendErrorTelemetry(error: Error | MCPError, context?: string): Promise<void> {
        // Implementation will be added in telemetry system
    }
}


==============================================
FILE: ./src/vscode-extension/core/logging.ts
==============================================

import * as vscode from 'vscode';

export enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3
}

export class Logger {
    private static instance: Logger;
    private outputChannel: vscode.OutputChannel;
    private logLevel: LogLevel;

    private constructor() {
        this.outputChannel = vscode.window.createOutputChannel('The New Fuse');
        this.logLevel = LogLevel.INFO;
    }

    static getInstance(): Logger {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }

    setLogLevel(level: LogLevel): void {
        this.logLevel = level;
    }

    debug(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.DEBUG) {
            this.log('DEBUG', message, ...args);
        }
    }

    info(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.INFO) {
            this.log('INFO', message, ...args);
        }
    }

    warn(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.WARN) {
            this.log('WARN', message, ...args);
        }
    }

    error(message: string, ...args: any[]): void {
        if (this.logLevel <= LogLevel.ERROR) {
            this.log('ERROR', message, ...args);
        }
    }

    private log(level: string, message: string, ...args: any[]): void {
        const timestamp = new Date().toISOString();
        const formattedMessage = `[${timestamp}] [${level}] ${message}`;
        
        if (args.length > 0) {
            this.outputChannel.appendLine(`${formattedMessage} ${JSON.stringify(args)}`);
        } else {
            this.outputChannel.appendLine(formattedMessage);
        }
    }
}


==============================================
FILE: ./src/vscode-extension/core/telemetry.tsx
==============================================

import * as vscode from 'vscode';
import { ErrorCode, MCPError } from './error-handling';

export interface TelemetryEvent {
    eventName: string;
    properties?: Record<string, string>;
    measurements?: Record<string, number>;
    timestamp: number;
}

export class TelemetryService {
    private static instance: TelemetryService;
    private events: TelemetryEvent[] = [];
    private outputChannel: vscode.OutputChannel;

    private constructor() {
        this.outputChannel = vscode.window.createOutputChannel('The New Fuse Telemetry');
    }

    static getInstance(): TelemetryService {
        if (!TelemetryService.instance) {
            TelemetryService.instance = new TelemetryService();
        }
        return TelemetryService.instance;
    }

    trackEvent(eventName: string, properties?: Record<string, string>, measurements?: Record<string, number>): void {
        const event: TelemetryEvent = {
            eventName,
            properties,
            measurements,
            timestamp: Date.now()
        };

        this.events.push(event);
        this.outputChannel.appendLine(`Event tracked: ${JSON.stringify(event, null, 2)}`);
    }

    trackError(error: Error | MCPError, context?: string): void {
        const properties: Record<string, string> = {
            errorType: error instanceof MCPError ? 'MCPError' : 'Error',
            errorCode: error instanceof MCPError ? error.code : 'UNKNOWN',
            message: error.message,
            context: context || 'unknown'
        };

        this.trackEvent('error', properties);
    }

    async flush(): Promise<void> {
        // Implementation for sending telemetry data to server
        // This is a placeholder for now
        this.events = [];
    }
}


==============================================
FILE: ./src/vscode-extension/create-icon.js
==============================================




==============================================
FILE: ./src/vscode-extension/create-png-icon.js
==============================================




==============================================
FILE: ./src/vscode-extension/data/README.md
==============================================

# MCP FileSystem Data Directory

This directory is used by the MCP filesystem tool. 
Files placed here will be accessible to the AI agent through the filesystem MCP server.

## Usage Examples

Files in this directory can be accessed using MCP tools like:
- `list_files` - Lists files in this directory
- `read_file` - Reads the content of a file in this directory
- `write_file` - Writes content to a file in this directory



==============================================
FILE: ./src/vscode-extension/dev-mode-fix.sh
==============================================

#!/bin/bash

echo "===================================================="
echo "  Setting up The New Fuse in pure development mode"
echo "===================================================="
echo ""

# Create essential directories
mkdir -p out
mkdir -p ai-communication

# Create a minimal working extension.js file
cat > out/extension.js << 'EOF'
const vscode = require('vscode');

function activate(context) {
  console.log('The New Fuse extension is active!');
  
  // Register essential commands
  const helloCommand = vscode.commands.registerCommand('thefuse.helloWorld', () => {
    vscode.window.showInformationMessage('Hello from The New Fuse!');
  });
  
  const aiCollabCommand = vscode.commands.registerCommand('thefuse.startAICollab', () => {
    vscode.window.showInformationMessage('AI Collaboration initiated!');
    
    // Show options
    vscode.window.showQuickPick([
      'Code Optimization',
      'Bug Finding',
      'Documentation Generation',
      'Code Review'
    ], {
      placeHolder: 'Select an AI collaboration task'
    }).then(selection => {
      if (selection) {
        vscode.window.showInformationMessage(`Starting ${selection} task...`);
      }
    });
  });
  
  // Add status bar items
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse AI Tools";
  statusBarItem.command = 'thefuse.helloWorld';
  statusBarItem.show();
  
  // Create a command to open the master command center
  const openMasterCommand = vscode.commands.registerCommand('thefuse.openMasterCommandCenter', () => {
    const panel = vscode.window.createWebviewPanel(
      'masterCommandCenter',
      'Master Command Center',
      vscode.ViewColumn.One,
      { enableScripts: true }
    );
    
    // Use a simple HTML interface
    panel.webview.html = `
      <!DOCTYPE html>
      <html>
      <head>
        <style>
          body { font-family: system-ui; padding: 20px; }
          h1 { color: var(--vscode-editor-foreground); }
          .card { 
            background: var(--vscode-editor-background);
            border: 1px solid var(--vscode-panel-border); 
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
          }
          button {
            background: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
          }
        </style>
      </head>
      <body>
        <h1>The New Fuse - Command Center</h1>
        
        <div class="card">
          <h2>Core Features</h2>
          <button onclick="sendCommand('thefuse.startAICollab')">Start AI Collaboration</button>
          <button onclick="sendCommand('thefuse.helloWorld')">Hello World</button>
        </div>
        
        <script>
          const vscode = acquireVsCodeApi();
          function sendCommand(cmd) {
            vscode.postMessage({ command: cmd });
          }
        </script>
      </body>
      </html>
    `;
    
    // Handle messages from the webview
    panel.webview.onDidReceiveMessage(
      message => {
        vscode.commands.executeCommand(message.command);
      }
    );
  });
  
  // Register another status bar item for the command center
  const centerStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 1);
  centerStatusBarItem.text = "$(list-tree) Command Center";
  centerStatusBarItem.tooltip = "Open The New Fuse Command Center";
  centerStatusBarItem.command = 'thefuse.openMasterCommandCenter';
  centerStatusBarItem.show();

  // Register all disposables
  context.subscriptions.push(helloCommand, aiCollabCommand, openMasterCommand, statusBarItem, centerStatusBarItem);
  
  // Show welcome message
  vscode.window.showInformationMessage('The New Fuse is active!', 'Open Command Center').then(selection => {
    if (selection === 'Open Command Center') {
      vscode.commands.executeCommand('thefuse.openMasterCommandCenter');
    }
  });
}

function deactivate() {}

module.exports = { activate, deactivate };
EOF

# Create minimal package.json with minimum needed fields - NO PUBLISHER field
cat > package.json << 'EOF'
{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "main": "./out/extension.js",
  "activationEvents": ["onStartupFinished"],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.helloWorld",
        "title": "Hello from The New Fuse"
      },
      {
        "command": "thefuse.startAICollab",
        "title": "Start AI Collaboration"
      },
      {
        "command": "thefuse.openMasterCommandCenter",
        "title": "Open Master Command Center"
      }
    ]
  }
}
EOF

echo "Launching VS Code with the extension in development mode..."
code --extensionDevelopmentPath="$(pwd)"

echo ""
echo "IMPORTANT: This setup bypasses the formal extension installation"
echo "and runs the extension in development mode only. This is WHY"
echo "you can't 'manage' it like a normally installed extension."
echo ""
echo "To access the extension's features:"
echo "1. Look for the rocket icon ($(rocket)) in the status bar"
echo "2. Or click the Command Center icon next to it"
echo "3. Or use Command Palette and type 'The New Fuse'"
echo ""



==============================================
FILE: ./src/vscode-extension/direct-command-access.ts
==============================================

import * as vscode from 'vscode';

/**
 * This function registers commands that are not already registered in the main extension.ts file.
 * It's primarily used for development and testing purposes.
 * For production use, commands should be registered through the CommandRegistry in extension.ts.
 */
export function forceRegisterCommands(): any {
  // Note: Most commands are now registered in the main extension.ts file through CommandRegistry
  // This function only registers commands that might be needed for development/testing
  
  // Register communication panel command if not already registered
  vscode.commands.registerCommand('thefuse.openCommunicationPanel', () => {
    // Try to execute the command through the main command registry first
    vscode.commands.executeCommand('thefuse.openChatPanel')
      .then(() => {}, () => {
        // Fallback if the main command isn't available
        vscode.window.showInformationMessage('Opening Communication Hub...');
      });
  });
  
  // Register web UI command if not already registered
  vscode.commands.registerCommand('thefuse.openWebUI', () => {
    // Try to execute the command through the main command registry first
    vscode.commands.executeCommand('thefuse.openDashboard')
      .then(() => {}, () => {
        // Fallback if the main command isn't available
        vscode.window.showInformationMessage('Opening The New Fuse UI...');
      });
  });
  
  // Register file message command if not already registered
  vscode.commands.registerCommand('thefuse.sendFileMessage', (recipient: string, action: string, payload: any) => {
    // Try to use the communication manager from the main extension
    vscode.commands.executeCommand('thefuse.orchestrator.sendMessage', {
      sender: 'thefuse.main',
      recipient: recipient,
      action: action,
      payload: payload
    }).then(() => {}, () => {
      // Fallback if the main command isn't available
      vscode.window.showInformationMessage(`Sending message to ${recipient} via File Protocol...`);
    });
  });
  
  // Add status bar button for easy access
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse Commands";
  statusBarItem.command = 'thefuse.startAICollab'; // Link to the main AI collaboration command
  statusBarItem.show();
  
  vscode.window.showInformationMessage('The New Fuse commands are now registered!');
  return 'Commands registered';
}



==============================================
FILE: ./src/vscode-extension/direct-launch.sh
==============================================

#!/bin/bash

# Create minimum required directory structure
mkdir -p out

# Create a simple extension.js file
cat > out/extension.js << 'EOF'
const vscode = require('vscode');

function activate(context) {
  console.log('The New Fuse extension is active!');
  
  // Register a simple command
  const helloCommand = vscode.commands.registerCommand('thefuse.helloWorld', () => {
    vscode.window.showInformationMessage('Hello from The New Fuse!');
  });
  
  // Add a status bar item
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse AI Tools";
  statusBarItem.command = 'thefuse.helloWorld';
  statusBarItem.show();
  
  context.subscriptions.push(helloCommand, statusBarItem);
  
  // Show welcome message
  vscode.window.showInformationMessage(
    'The New Fuse extension is now active!',
    'Learn More'
  );
}

function deactivate() {}

module.exports = { activate, deactivate };
EOF

# Create a minimal package.json
cat > package.json << 'EOF'
{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "main": "./out/extension.js",
  "activationEvents": ["onStartupFinished"],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.helloWorld",
        "title": "Hello World"
      }
    ]
  }
}
EOF

# Find VS Code on macOS
if [ -x "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code" ]; then
  VSCODE_PATH="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
else
  VSCODE_PATH="code" # Fallback to PATH
fi

echo "Launching VS Code with minimal extension..."
"$VSCODE_PATH" --new-window --extensionDevelopmentPath="$(pwd)"



==============================================
FILE: ./src/vscode-extension/docs/verification-agent.md
==============================================

# Verification Agent Documentation

## Overview

The Verification Agent is a component of The New Fuse that verifies claims using LLM-based fact-checking or simulated verification. It provides commands for initializing verification agents, verifying claims, and changing verification levels.

The system consists of two main parts:

1. **Backend Implementation**: VS Code extension commands that handle verification logic
2. **Frontend Component**: React component for the workflow UI that interacts with the backend

## Features

- **LLM-based Verification**: Uses language models to verify claims in production mode
- **Simulated Verification**: Provides realistic simulated verification in development mode
- **Caching**: Caches verification results to improve performance (24-hour expiration by default)
- **Event-based Communication**: Emits events for other components to listen to
- **Multiple Verification Levels**: Supports STRICT, STANDARD, and PERMISSIVE verification levels
- **Source Credibility Assessment**: Evaluates sources based on type and reliability
- **Confidence Scoring**: Provides confidence scores for verification results
- **Fallback Mechanisms**: Gracefully falls back to simulation if LLM verification fails

## Commands

### Initialize Verification Agent

```typescript
vscode.commands.executeCommand('thefuse.verification.initialize', {
  id: string;                      // Required: Unique ID for the agent
  name: string;                    // Required: Display name for the agent
  verificationLevel?: VerificationLevel; // Optional: STRICT, STANDARD, or PERMISSIVE
  trustedSources?: string[];       // Optional: List of trusted source URLs
  minConfidenceThreshold?: number; // Optional: Minimum confidence threshold (0.0-1.0)
  maxResponseTime?: number;        // Optional: Maximum response time in seconds
  supportedProtocols?: string[];   // Optional: List of supported protocols
  capabilities?: string[];         // Optional: List of agent capabilities
});
```

Returns:

```typescript
{
  success: boolean;
  message: string;
  claims: Claim[]; // Empty array for new agents
}
```

### Verify Claim

```typescript
vscode.commands.executeCommand('thefuse.verification.verifyClaim', {
  agentId: string; // Required: ID of the verification agent
  claim: {         // Required: Claim to verify
    id: string;
    text: string;
    source?: string;
    metadata?: any;
    verificationStatus: 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
    confidenceScore: number;
  }
});
```

Returns:

```typescript
{
  success: boolean;
  verifiedClaim: {
    id: string;
    text: string;
    source?: string;
    metadata?: any;
    verificationStatus: 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
    confidenceScore: number;
    verificationSources: VerificationSource[];
    verifiedAt: string; // ISO date string
  }
}
```

### Set Verification Level

```typescript
vscode.commands.executeCommand('thefuse.verification.setLevel', {
  agentId: string;                 // Required: ID of the verification agent
  level: VerificationLevel;        // Required: STRICT, STANDARD, or PERMISSIVE
});
```

Returns:

```typescript
{
  success: boolean;
  message: string;
}
```

## Verification Levels

The verification agent supports three levels of verification strictness:

- **STRICT**: Requires multiple credible sources to verify a claim
  - Verification threshold: 0.7 (70%)
  - Typically requires 2-4 credible sources
  - Higher confidence scores required for verification
  - Best for critical information where accuracy is paramount

- **STANDARD**: Requires at least one credible source to verify a claim
  - Verification threshold: 0.5 (50%)
  - Typically requires 1-2 credible sources
  - Balanced approach for most verification needs
  - Default verification level

- **PERMISSIVE**: Accepts claims with minimal verification
  - Verification threshold: 0.3 (30%)
  - May accept claims with limited source verification
  - Lower confidence threshold
  - Suitable for non-critical information or exploratory research

## Events

The verification agent uses an event-based architecture to communicate with other components. This enables loose coupling and allows components to react to verification activities without direct dependencies.

### Event Types

The verification agent emits the following events:

- **AGENT_INITIALIZED**: Emitted when a verification agent is initialized
  - Contains agent ID, name, and initial verification level
  - Useful for tracking agent creation and configuration

- **CLAIM_VERIFIED**: Emitted when a claim is verified
  - Contains the verified claim with all verification details
  - Includes source information and confidence scores
  - Indicates whether the result came from cache

- **VERIFICATION_LEVEL_CHANGED**: Emitted when the verification level is changed
  - Contains the agent ID, old level, and new level
  - Useful for tracking verification policy changes

- **VERIFICATION_ERROR**: Emitted when an error occurs during verification
  - Contains error details and the operation that failed
  - Includes agent ID and claim ID (if applicable)
  - Useful for error tracking and debugging

## Listening to Events

```typescript
// Get the verification manager
const verificationManager = getVerificationManager();

// Add event listener
const disposable = verificationManager.addEventListener(
  VerificationEventType.CLAIM_VERIFIED,
  (event) => {
    console.log(`Claim verified: ${event.data.claim.id}`);
  }
);

// Remove event listener when done
disposable.dispose();
```

## Caching

The verification agent implements a caching system to improve performance and reduce redundant verification operations.

### Cache Features

- **Duration**: Verification results are cached for 24 hours by default
- **Storage**: Cache is stored in the extension's global storage directory
- **Persistence**: Cache is saved to disk and loaded when the extension is activated
- **Key Generation**: Cache keys are generated using MD5 hashes of claim text and verification level
- **Expiration**: Expired cache entries are automatically filtered out during loading
- **Automatic Saving**: Cache is automatically saved after each verification

### Cache Benefits

- **Performance**: Significantly reduces response time for previously verified claims
- **Consistency**: Ensures consistent verification results for the same claim
- **Resource Efficiency**: Reduces LLM API calls for repeated verifications
- **Offline Operation**: Enables verification using cached results when LLM services are unavailable

## LLM Integration

In production mode, the verification agent uses an LLM service to verify claims. This enables sophisticated fact-checking capabilities with access to the LLM's knowledge base.

### LLM Service Interface

The LLM service must implement the following interface:

```typescript
interface LLMService {
  generateCompletion(params: {
    model: string;
    messages: Array<{role: string, content: string}>;
    temperature?: number;
    max_tokens?: number;
    response_format?: {type: string};
  }): Promise<any>;
}
```

### Verification Process

When using an LLM for verification:

1. The agent constructs a detailed prompt with:
   - The claim text to verify
   - Verification parameters (level, trusted sources, etc.)
   - Detailed instructions for verification
   - Expected response format

2. The prompt is sent to the LLM with:
   - System message defining the LLM's role as a fact-checker
   - Low temperature (0.2) for more factual responses
   - JSON response format for structured output

3. The LLM response is parsed and validated:
   - Verification status is checked against allowed values
   - Confidence score is validated to be between 0 and 1
   - Sources are transformed to match the expected format

4. If any part of the LLM verification fails, the system falls back to simulated verification

## Development Mode

In development mode, the verification agent uses a mock LLM service that simulates verification results. This allows for testing without making actual LLM API calls.

### Mock LLM Service

The mock LLM service (`MockLLMService`) provides a realistic simulation of verification:

- **Smart Claim Analysis**: Analyzes claim text to determine verification status
  - Claims containing "verified" are marked as verified
  - Claims containing "refuted" are marked as refuted
  - Claims containing "insufficient" are marked as insufficient_data
  - Other claims are marked as unverified

- **Realistic Sources**: Generates appropriate mock sources based on verification status
  - Verified claims get multiple high-reliability sources
  - Refuted claims get medium-reliability sources
  - Unverified claims get fewer, lower-reliability sources

- **Simulated Delay**: Adds a realistic processing delay to mimic real LLM calls

- **Consistent Format**: Returns data in the same format as a real LLM service

### Automatic Detection

The verification agent automatically uses the mock LLM service when:

- The VS Code extension is running in development mode
- No production LLM service is provided
- The LLM service fails to respond

## Example Usage

```typescript
// Initialize a verification agent
const initResult = await vscode.commands.executeCommand(
  'thefuse.verification.initialize',
  {
    id: 'agent-1',
    name: 'Fact Checker',
    verificationLevel: 'standard',
    trustedSources: ['example.com', 'trusted-source.org']
  }
);

// Verify a claim
const verifyResult = await vscode.commands.executeCommand(
  'thefuse.verification.verifyClaim',
  {
    agentId: 'agent-1',
    claim: {
      id: 'claim-1',
      text: 'The Earth is round.',
      verificationStatus: 'unverified',
      confidenceScore: 0
    }
  }
);

// Change verification level
const levelResult = await vscode.commands.executeCommand(
  'thefuse.verification.setLevel',
  {
    agentId: 'agent-1',
    level: 'strict'
  }
);
```

## Troubleshooting

### Common Issues

- **Verification Failures**:
  - Check the extension output panel for detailed error messages
  - Look for "ERROR" entries in the AI Verification output channel
  - Verify that the claim has a valid ID and text content
  - Check if the agent ID exists and is correctly referenced

- **Initialization Issues**:
  - Ensure the verification agent is initialized before verifying claims
  - Check that required parameters (id, name) are provided during initialization
  - Verify that the VS Code extension is properly activated

- **LLM Integration Issues**:
  - For LLM-based verification, ensure the LLM service is properly configured
  - Check that the LLM service implements the required interface
  - Verify that the LLM service has appropriate permissions and API keys
  - If LLM verification fails, the system will fall back to simulated verification

- **Performance Issues**:
  - If verification is slow, check if caching is working properly
  - Verify that the cache directory exists and is writable
  - Consider adjusting the cache expiration time for your use case

### Logging

The verification agent provides detailed logging:

- **Output Channel**: Check the "AI Verification" output channel in VS Code
- **Log Levels**: Both regular logs and error logs are available
- **Timestamps**: All logs include timestamps for easier debugging
- **Error Details**: Error logs include detailed error messages and stack traces

### Event Debugging

Use event listeners to debug verification issues:

```typescript
// Listen for verification errors
verificationManager.addEventListener(
  VerificationEventType.VERIFICATION_ERROR,
  (event) => {
    console.log(`Verification error: ${event.data.error}`);
    console.log(`Operation: ${event.data.operation}`);
    console.log(`Agent ID: ${event.agentId}`);
  }
);
```

## Frontend Component

The verification agent includes a React component (`AIVerificationAgent`) that provides a user interface for interacting with the verification system.

### Component Features

- **Interactive UI**: Provides a visual interface for verification operations
- **Real-time Status**: Shows verification status and progress
- **Claim Management**: Displays verified and pending claims
- **Verification Level Control**: Allows changing verification levels
- **Filtering**: Supports filtering claims by verification status
- **Auto-verification**: Automatically verifies pending claims when enabled

### Component Integration

The component integrates with the backend through VS Code extension commands:

```typescript
// Initialize the verification agent
const result = await window.vscode?.commands.executeCommand(
  'thefuse.verification.initialize',
  {
    id: data.id,
    name: data.name,
    // ...other parameters
  }
);

// Verify a claim
const result = await window.vscode?.commands.executeCommand(
  'thefuse.verification.verifyClaim',
  {
    agentId: data.id,
    claim: claim,
    // ...other parameters
  }
);

// Change verification level
const result = await window.vscode?.commands.executeCommand(
  'thefuse.verification.setLevel',
  {
    agentId: data.id,
    level: level
  }
);
```

### Component Usage

The component can be used in workflow diagrams as a node:

```tsx
import AIVerificationAgent from 'src/components/nodes/AIVerificationAgent';
import { defaultAIVerificationAgentData } from 'src/components/nodes/AIVerificationAgent';

// In your workflow component
const nodeTypes = {
  verificationAgent: AIVerificationAgent,
  // ...other node types
};

// Create a verification agent node
const verificationNode = {
  id: 'verification-1',
  type: 'verificationAgent',
  position: { x: 250, y: 250 },
  data: defaultAIVerificationAgentData
};
```



==============================================
FILE: ./src/vscode-extension/extension.ts
==============================================

import * as vscode from 'vscode';
import { LLMProviderManager } from './llm-provider-manager';
import { createFuseMonitoringClient } from './monitoring/FuseMonitoringClient';
import { MonitoredLLMProviderManager } from './monitored-llm-provider-manager';
import { AdminControlPanelProvider } from './monitoring/AdminControlPanelProvider';
import { MonitoringSettingsProvider } from './monitoring/MonitoringSettingsProvider';
import { AgentMonitor } from './monitoring/AgentMonitor';
import { createLLMMonitoringClient } from './monitoring/llm-monitoring-client';

export async function activate(context: vscode.ExtensionContext) {
  console.log('Activating The New Fuse VS Code Extension');

  // Create output channel for logs
  const outputChannel = vscode.window.createOutputChannel('The New Fuse');
  outputChannel.appendLine('The New Fuse extension activated');

  // Initialize the monitoring client
  const monitoringClient = createFuseMonitoringClient(context, outputChannel);

  // Initialize the Agent Monitor
  const agentMonitor = AgentMonitor.getInstance();

  // Initialize the LLM Monitoring Client
  const llmMonitor = createLLMMonitoringClient(context, outputChannel);

  // Initialize the LLM Provider Manager
  const llmProviderManager = new LLMProviderManager(context, outputChannel);

  // Create the monitored LLM Provider Manager that wraps the base manager with monitoring
  const monitoredLLMManager = new MonitoredLLMProviderManager(
    context,
    llmProviderManager,
    monitoringClient
  );

  // Register commands
  registerCommands(context, monitoredLLMManager, monitoringClient);

  // Register status bar items
  const statusBarItem = createLLMStatusBarItem(monitoredLLMManager);
  context.subscriptions.push(statusBarItem);

  // Return the API for other extensions
  return {
    llmManager: monitoredLLMManager,
    monitoring: monitoringClient
  };
}

// Create a status bar item to show current LLM provider
function createLLMStatusBarItem(llmManager: MonitoredLLMProviderManager): vscode.StatusBarItem {
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
  statusBarItem.command = 'thefuse.selectLLMProvider';

  // Update the status bar with current provider
  const updateStatusBar = () => {
    const currentProvider = llmManager.getCurrentProvider();
    statusBarItem.text = `$(hubot) ${currentProvider.name}`;
    statusBarItem.tooltip = `Current LLM: ${currentProvider.name} (${currentProvider.modelName})`;
    statusBarItem.show();
  };

  // Initial update
  updateStatusBar();

  // Listen for provider changes and update status bar
  const disposable = vscode.workspace.onDidChangeConfiguration(e => {
    if (e.affectsConfiguration('theFuse.currentLLMProvider')) {
      updateStatusBar();
    }
  });

  return statusBarItem;
}

// Register extension commands
function registerCommands(
  context: vscode.ExtensionContext,
  llmManager: MonitoredLLMProviderManager,
  monitoringClient: any
) {
  // Command to select LLM provider
  const selectLLMProviderCommand = vscode.commands.registerCommand(
    'thefuse.selectLLMProvider',
    async () => {
      const providers = llmManager.getAllProviders();
      const currentProvider = llmManager.getCurrentProvider();

      const items = providers.map(provider => ({
        label: provider.name,
        description: provider.modelName,
        detail: provider.id === currentProvider.id ? 'Current Provider' : undefined,
        provider
      }));

      const selected = await vscode.window.showQuickPick(items, {
        placeHolder: 'Select LLM Provider'
      });

      if (selected) {
        await llmManager.setCurrentProvider(selected.provider.id);
        vscode.window.showInformationMessage(`Switched to ${selected.provider.name}`);
      }
    }
  );

  // Command to generate code with the current LLM
  const generateCodeCommand = vscode.commands.registerCommand(
    'thefuse.generateCode',
    async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showWarningMessage('No active editor');
        return;
      }

      const selection = editor.selection;
      const prompt = editor.document.getText(selection);

      if (!prompt) {
        vscode.window.showWarningMessage('Please select text as a prompt');
        return;
      }

      // Get language from file extension
      const language = editor.document.languageId;

      try {
        vscode.window.showInformationMessage('Generating code...');

        const response = await llmManager.generateCode(
          prompt,
          language,
          { maxTokens: 1000 }
        );

        // Insert generated code
        editor.edit(editBuilder => {
          editBuilder.replace(selection, response.text);
        });

        // Offer to rate the generation
        const traceId = monitoringClient.getCurrentTraceId();
        if (traceId) {
          const rate = await vscode.window.showInformationMessage(
            'How was the code generation?',
            'Great! 👍',
            'OK 😐',
            'Poor 👎'
          );

          if (rate) {
            const ratingValue =
              rate.includes('Great') ? 1.0 :
              rate.includes('OK') ? 0.5 :
              0.0;

            llmManager.rateGeneration(traceId, ratingValue, rate);
          }
        }
      } catch (error) {
        vscode.window.showErrorMessage(`Code generation failed: ${error.message}`);
      }
    }
  );

  // Command to generate text with the current LLM
  const generateTextCommand = vscode.commands.registerCommand(
    'thefuse.generateText',
    async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showWarningMessage('No active editor');
        return;
      }

      const selection = editor.selection;
      const prompt = editor.document.getText(selection);

      if (!prompt) {
        vscode.window.showWarningMessage('Please select text as a prompt');
        return;
      }

      try {
        vscode.window.showInformationMessage('Generating text...');

        const response = await llmManager.generateText(prompt, { maxTokens: 1000 });

        // Insert generated text
        editor.edit(editBuilder => {
          editBuilder.replace(selection, response.text);
        });
      } catch (error) {
        vscode.window.showErrorMessage(`Text generation failed: ${error.message}`);
      }
    }
  );

  // Command to open LLM monitoring dashboard
  const openMonitoringDashboardCommand = vscode.commands.registerCommand(
    'thefuse.openMonitoringDashboard',
    () => {
      llmManager.openMonitoringDashboard();
    }
  );

  // Command to toggle monitoring
  const toggleMonitoringCommand = vscode.commands.registerCommand(
    'thefuse.toggleMonitoring',
    async () => {
      const currentlyEnabled = monitoringClient.isEnabled();
      monitoringClient.setEnabled(!currentlyEnabled);

      vscode.window.showInformationMessage(
        `The New Fuse monitoring ${!currentlyEnabled ? 'enabled' : 'disabled'}`
      );
    }
  );

  // Register Monitoring Settings view provider
  context.subscriptions.push(
    vscode.window.registerWebviewViewProvider(
      MonitoringSettingsProvider.viewType,
      new MonitoringSettingsProvider(context, monitoringClient, agentMonitor, llmMonitor)
    )
  );

  // Register command to open Admin Control Panel
  const openAdminPanel = vscode.commands.registerCommand(
    'thefuse.openAdminControlPanel',
    () => AdminControlPanelProvider.createOrShow(context.extensionUri, context, monitoringClient, llmMonitor)
  );
  context.subscriptions.push(openAdminPanel);

  // Register all commands
  context.subscriptions.push(
    selectLLMProviderCommand,
    generateCodeCommand,
    generateTextCommand,
    openMonitoringDashboardCommand,
    toggleMonitoringCommand
  );
}

// Extension deactivation function
export function deactivate() {
  console.log('Deactivating The New Fuse VS Code Extension');
}



==============================================
FILE: ./src/vscode-extension/file-protocol-communicator.tsx
==============================================

/**
 * File Protocol Communicator
 * 
 * This module implements communication between VS Code extensions via shared files
 * in the workspace, as described in the inter-extension communication design document.
 */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { AgentClient, AgentMessage } from './agent-communication';
import { getErrorMessage } from './utilities';

interface FileMessage {
  id: string;
  sender: string;
  recipient: string;
  action: string;
  payload: any;
  timestamp: number;
  status: 'pending' | 'processing' | 'processed' | 'error';
  error?: string;
  signature?: string;
}

/**
 * Implements communication between extensions using shared files
 */
export class FileProtocolCommunicator {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private agentId: string;
  private communicationDir: string = 'ai-communication';
  private fileWatcher: vscode.FileSystemWatcher | undefined;
  private secretKey: string;
  private processedMessageIds: Set<string> = new Set();
  private outputChannel: vscode.OutputChannel;
  
  constructor(
    context: vscode.ExtensionContext,
    agentClient: AgentClient,
    outputChannel: vscode.OutputChannel
  ) {
    this.context = context;
    this.agentClient = agentClient;
    this.agentId = 'thefuse.main';
    this.outputChannel = outputChannel;
    
    // Generate a secret key for message signing
    this.secretKey = this.context.globalState.get('thefuse.fileProtocol.secretKey') || 
                    crypto.randomBytes(32).toString('hex');
    this.context.globalState.update('thefuse.fileProtocol.secretKey', this.secretKey);
  }
  
  /**
   * Initialize the communicator by setting up file watchers
   */
  async initialize(): Promise<boolean> {
    try {
      // Get workspace folders
      const workspaceFolders = vscode.workspace.workspaceFolders;
      if (!workspaceFolders) {
        this.log('No workspace folder is open');
        return false;
      }
      
      // Get communication directory from settings
      const configDir = vscode.workspace.getConfiguration('theFuse').get<string>('fileProtocolDir', 'ai-communication');
      this.communicationDir = configDir;
      
      // Create full path to communication directory
      const communicationDirPath = path.join(workspaceFolders[0].uri.fsPath, this.communicationDir);
      
      // Create the directory if it doesn't exist
      if (!fs.existsSync(communicationDirPath)) {
        fs.mkdirSync(communicationDirPath, { recursive: true });
        this.log(`Created communication directory: ${communicationDirPath}`);
      }
      
      // Create file watcher for .json files in the communication directory
      const pattern = new vscode.RelativePattern(communicationDirPath, '*.json');
      this.fileWatcher = vscode.workspace.createFileSystemWatcher(pattern);
      
      // Watch for new files and changes
      this.fileWatcher.onDidCreate(uri => this.handleFileEvent(uri));
      this.fileWatcher.onDidChange(uri => this.handleFileEvent(uri));
      
      this.context.subscriptions.push(this.fileWatcher);
      
      this.log(`File protocol communicator initialized with directory: ${communicationDirPath}`);
      return true;
    } catch (error) {
      this.log(`Error initializing file protocol communicator: ${getErrorMessage(error)}`);
      return false;
    }
  }
  
  /**
   * Send a message to another extension by writing a file
   */
  async sendMessage(
    recipient: string,
    action: string,
    payload: any
  ): Promise<{ success: boolean, messageId?: string }> {
    try {
      // Get workspace folders
      const workspaceFolders = vscode.workspace.workspaceFolders;
      if (!workspaceFolders) {
        this.log('No workspace folder is open');
        return { success: false };
      }
      
      // Generate message ID
      const messageId = crypto.randomUUID();
      
      // Create message object
      const message: FileMessage = {
        id: messageId,
        sender: this.agentId,
        recipient,
        action,
        payload,
        timestamp: Date.now(),
        status: 'pending'
      };
      
      // Add signature
      const messageToSign = { ...message };
      delete messageToSign.signature;
      message.signature = this.signMessage(messageToSign);
      
      // Create communication directory path
      const communicationDirPath = path.join(workspaceFolders[0].uri.fsPath, this.communicationDir);
      
      // Create the directory if it doesn't exist
      if (!fs.existsSync(communicationDirPath)) {
        fs.mkdirSync(communicationDirPath, { recursive: true });
      }
      
      // Create message file
      const filePath = path.join(communicationDirPath, `${Date.now()}-${messageId.substring(0, 8)}.json`);
      fs.writeFileSync(filePath, JSON.stringify(message, null, 2));
      
      this.log(`Sent message to ${recipient} via file: ${path.basename(filePath)}`);
      return { success: true, messageId };
    } catch (error) {
      this.log(`Error sending message: ${getErrorMessage(error)}`);
      return { success: false };
    }
  }
  
  /**
   * Handle file creation or change events
   */
  private async handleFileEvent(uri: vscode.Uri): Promise<void> {
    try {
      // Read the file
      const content = fs.readFileSync(uri.fsPath, 'utf8');
      
      // Parse the message
      const message: FileMessage = JSON.parse(content);
      
      // Check if this message is for us
      if (message.recipient !== this.agentId && message.recipient !== '*') {
        return;
      }
      
      // Check if we've already processed this message
      if (this.processedMessageIds.has(message.id)) {
        return;
      }
      
      // Verify signature
      if (!this.verifyMessage(message)) {
        this.log(`Message signature verification failed: ${uri.fsPath}`);
        return;
      }
      
      // Mark as processing
      message.status = 'processing';
      await this.updateMessageFile(uri, message);
      
      // Process the message
      await this.processMessage(message);
      
      // Mark as processed
      message.status = 'processed';
      await this.updateMessageFile(uri, message);
      
      // Add to processed messages set
      this.processedMessageIds.add(message.id);
      
      // Keep the set from growing too large
      if (this.processedMessageIds.size > 1000) {
        const idsArray = Array.from(this.processedMessageIds);
        this.processedMessageIds = new Set(idsArray.slice(-500));
      }
    } catch (error) {
      this.log(`Error handling file event: ${getErrorMessage(error)}`);
    }
  }
  
  /**
   * Update a message file with new status
   */
  private async updateMessageFile(uri: vscode.Uri, message: FileMessage): Promise<void> {
    try {
      // Write updated message back to file
      fs.writeFileSync(uri.fsPath, JSON.stringify(message, null, 2));
    } catch (error) {
      this.log(`Error updating message file: ${getErrorMessage(error)}`);
    }
  }
  
  /**
   * Process a message by routing it through the agent client system
   */
  private async processMessage(message: FileMessage): Promise<void> {
    try {
      this.log(`Processing file protocol message from ${message.sender}: ${message.action}`);
      
      // Route the message to subscribers
      const routedMessage = {
        id: message.id,
        sender: message.sender,
        recipient: message.recipient,
        action: message.action,
        payload: message.payload,
        timestamp: message.timestamp,
        source: 'file-protocol'
      };
      
      // Process this internally within the agent client
      this.agentClient.subscribe(async (msg) => {
        if (msg.id === routedMessage.id) {
          // Process the message (will be handled by other subscribers)
          this.log(`Message ${message.id} routing complete`);
        }
      });
      
      // Send response if needed
      if (message.action.endsWith('Request')) {
        const responseAction = message.action.replace('Request', 'Response');
        await this.agentClient.sendMessage(message.sender, responseAction, {
          requestId: message.id,
          timestamp: Date.now(),
          success: true
        });
      }
    } catch (error) {
      this.log(`Error processing message: ${getErrorMessage(error)}`);
    }
  }
  
  /**
   * Sign a message using HMAC
   */
  private signMessage(message: Omit<FileMessage, 'signature'>): string {
    const messageStr = JSON.stringify(message);
    const hmac = crypto.createHmac('sha256', this.secretKey);
    hmac.update(messageStr);
    return hmac.digest('hex');
  }
  
  /**
   * Verify a message signature
   */
  private verifyMessage(message: FileMessage): boolean {
    if (!message.signature) return false;
    
    const signature = message.signature;
    const messageToVerify = { ...message };
    delete messageToVerify.signature;
    
    const expectedSignature = this.signMessage(messageToVerify);
    return signature === expectedSignature;
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    this.outputChannel.appendLine(`[File Protocol] ${message}`);
  }
  
  /**
   * Dispose of resources
   */
  dispose(): void {
    if (this.fileWatcher) {
      this.fileWatcher.dispose();
    }
  }
}

/**
 * Create a file protocol communicator
 */
export function createFileProtocolCommunicator(
  context: vscode.ExtensionContext,
  agentClient: AgentClient,
  outputChannel: vscode.OutputChannel
): FileProtocolCommunicator {
  return new FileProtocolCommunicator(context, agentClient, outputChannel);
}



==============================================
FILE: ./src/vscode-extension/fix-and-build.sh
==============================================

#!/bin/bash
# fix-and-build.sh - Script to fix TypeScript errors and build the extension

set -e
echo "🔧 Starting fix and build process for The New Fuse VS Code Extension..."

# Working directory
EXTENSION_DIR="$(pwd)"
echo "Working directory: $EXTENSION_DIR"

# Step 1: Fix problematic file: llm-orchestrator-simple.ts
echo "📝 Fixing llm-orchestrator-simple.ts..."
if grep -q "any: LLMOrchestrator" llm-orchestrator-simple.ts; then
  sed -i '' 's/): any: LLMOrchestrator {/): LLMOrchestrator {/' llm-orchestrator-simple.ts
  echo "✅ Fixed return type in llm-orchestrator-simple.ts"
fi

# Step 2: Update LMAPIBridge import in inter-ai-hub.ts
echo "📝 Fixing inter-ai-hub.ts..."
if grep -q "import { LMAPIBridge } from './lm-api-bridge';" inter-ai-hub.ts; then
  # Fix already exists
  echo "✅ inter-ai-hub.ts already has correct imports"
else
  # Insert the import and update the createInterAIHub function
  sed -i '' 's/import \* as vscode from/import * as vscode from/; s/import { AgentClient } from/import { AgentClient } from/; s/from .\/agent-communication/from .\/agent-communication\nimport { LMAPIBridge } from \.\/lm-api-bridge/' inter-ai-hub.ts
  sed -i '' 's/lmBridge: LMAPIBridge/lmBridge: any/' inter-ai-hub.ts
  sed -i '' 's/return new InterAIHub(context, agentClient, lmBridge)/return new InterAIHub(context, agentClient, lmBridge as LMAPIBridge)/' inter-ai-hub.ts
  echo "✅ Fixed inter-ai-hub.ts"
fi

# Step 3: Check and fix settings-view-provider.ts import path
echo "📝 Checking settings-view-provider.ts..."
mkdir -p "$EXTENSION_DIR/src/views" 2>/dev/null || true
if [ -f "$EXTENSION_DIR/src/views/settings-view-provider.ts" ]; then
  if grep -q "import { LLMProvider } from '../lm-api-bridge';" "$EXTENSION_DIR/src/views/settings-view-provider.ts"; then
    sed -i '' 's/import { LLMProvider } from ..\//import { LLMProvider } from ..\/..\//' "$EXTENSION_DIR/src/views/settings-view-provider.ts"
    echo "✅ Fixed import path in settings-view-provider.ts"
  fi
else
  echo "⚠️ settings-view-provider.ts not found in src/views, will copy from root if available"
  if [ -f "$EXTENSION_DIR/settings-view-provider.ts" ]; then
    cp "$EXTENSION_DIR/settings-view-provider.ts" "$EXTENSION_DIR/src/views/"
    sed -i '' 's/import { LLMProvider } from/import { LLMProvider } from \.\.\/\.\.\//' "$EXTENSION_DIR/src/views/settings-view-provider.ts"
    echo "✅ Copied and fixed settings-view-provider.ts"
  fi
fi

# Step 4: Fix any issues in the chat-interface.ts file
echo "📝 Checking chat-interface.ts..."
mkdir -p "$EXTENSION_DIR/src/chat" 2>/dev/null || true
if [ -f "$EXTENSION_DIR/src/chat/chat-interface.ts" ]; then
  echo "✅ chat-interface.ts exists"
else
  echo "⚠️ chat-interface.ts not found in src/chat, will check if it exists elsewhere"
  # Try to find and copy the chat interface file
  if [ -f "$EXTENSION_DIR/chat-interface.ts" ]; then
    cp "$EXTENSION_DIR/chat-interface.ts" "$EXTENSION_DIR/src/chat/"
    echo "✅ Copied chat-interface.ts to src/chat"
  fi
fi

# Step 5: Fix tsconfig.json to include our new files
echo "📝 Updating TypeScript configuration..."
if grep -q '"rootDir": "src"' tsconfig.json; then
  sed -i '' 's/"rootDir": "src"/"rootDir": "."/' tsconfig.json
  echo "✅ Updated rootDir in tsconfig.json"
fi

if ! grep -q '"include": \["src\/\*\*\/\*", "\*.ts"\]' tsconfig.json; then
  sed -i '' 's/"include": \["src\/\*\*\/\*"\]/"include": \["src\/\*\*\/\*", "*.ts"\]/' tsconfig.json
  echo "✅ Updated include paths in tsconfig.json"
fi

# Step 6: Clean previous build artifacts
echo "🧹 Cleaning previous build..."
rm -rf out
rm -f *.vsix || true

# Step 7: Install dependencies if needed
echo "📦 Checking for dependencies..."
if [ ! -d "node_modules" ]; then
  echo "Installing dependencies..."
  npm install
fi

# Step 8: Compile TypeScript
echo "🚀 Compiling TypeScript..."
npm run compile || true

# Check the number of errors
ERROR_COUNT=$(find . -name "*.ts" -not -path "./node_modules/*" -exec tsc --noEmit --project ./tsconfig.json {} \; 2>&1 | grep -c "error TS")
if [ "$ERROR_COUNT" -gt 0 ]; then
  echo "⚠️ There are still $ERROR_COUNT TypeScript errors, but we'll try to package anyway"
else
  echo "✅ TypeScript compilation successful!"
fi

# Step 9: Package extension
echo "📦 Packaging extension..."
npx @vscode/vsce package || npm install -g @vscode/vsce && vsce package

# Verify .vsix was created
if ls *.vsix 1> /dev/null 2>&1; then
  echo "✅ Successfully created .vsix file:"
  ls -la *.vsix
else
  echo "❌ Failed to create .vsix file"
  exit 1
fi

echo "🎉 Build process completed!"


==============================================
FILE: ./src/vscode-extension/fix-extension.sh
==============================================

#!/bin/bash

echo "Fixing The New Fuse extension installation..."

# Ensure we have the necessary directory structure
mkdir -p out
mkdir -p ai-communication

# Create a reliable extension.js file
cat > out/extension.js << 'EOF'
const vscode = require('vscode');

function activate(context) {
  console.log('The New Fuse extension is active!');
  
  // Register the hello world command
  const helloCommand = vscode.commands.registerCommand('thefuse.helloWorld', () => {
    vscode.window.showInformationMessage('Hello from The New Fuse!');
  });
  
  // Register the AI collaboration command
  const aiCollabCommand = vscode.commands.registerCommand('thefuse.startAICollab', () => {
    vscode.window.showInformationMessage('AI Collaboration initiated!');
    
    vscode.window.showQuickPick([
      'Code Optimization',
      'Bug Finding',
      'Documentation Generation',
      'Code Review'
    ], {
      placeHolder: 'Select an AI collaboration task'
    }).then(selection => {
      if (selection) {
        vscode.window.showInformationMessage(`Starting ${selection} task...`);
      }
    });
  });
  
  // Add status bar items
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse AI Tools";
  statusBarItem.command = 'thefuse.helloWorld';
  statusBarItem.show();
  
  // Register all disposables
  context.subscriptions.push(helloCommand, aiCollabCommand, statusBarItem);
}

function deactivate() {}

module.exports = { activate, deactivate };
EOF

# Create a proper package.json - DON'T specify publisher to avoid the lookup issue
cat > package.json << 'EOF'
{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "main": "./out/extension.js",
  "activationEvents": ["onStartupFinished"],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.helloWorld",
        "title": "Hello from The New Fuse"
      },
      {
        "command": "thefuse.startAICollab",
        "title": "Start AI Collaboration"
      }
    ]
  }
}
EOF

echo "Running the extension directly in development mode (bypassing installation)..."
code --extensionDevelopmentPath="$(pwd)"

echo ""
echo "If VS Code didn't open, run this command manually:"
echo "code --extensionDevelopmentPath=\"$(pwd)\""
echo ""
echo "Note: This method bypasses the normal extension installation process"
echo "and runs the extension in development mode, avoiding the publisher issue."



==============================================
FILE: ./src/vscode-extension/fix-publisher-issue.sh
==============================================

#!/bin/bash

echo "Fixing extension publisher identification issue..."

# Create the essential directory structure
mkdir -p out
mkdir -p ai-communication

# Create a minimal package.json without a publisher field
# This allows VS Code to run the extension in development mode without publisher validation
cat > package.json << 'EOF'
{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "main": "./out/extension.js",
  "activationEvents": ["onStartupFinished"],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.helloWorld",
        "title": "Hello from The New Fuse"
      },
      {
        "command": "thefuse.startAICollab",
        "title": "Start AI Collaboration"
      }
    ]
  }
}
EOF

# Ensure we have a working extension.js
cat > out/extension.js << 'EOF'
const vscode = require('vscode');

function activate(context) {
  console.log('The New Fuse extension is active!');
  
  // Register core commands
  const helloCommand = vscode.commands.registerCommand('thefuse.helloWorld', () => {
    vscode.window.showInformationMessage('Hello from The New Fuse!');
  });
  
  const aiCollabCommand = vscode.commands.registerCommand('thefuse.startAICollab', () => {
    vscode.window.showInformationMessage('AI Collaboration initiated!');
    
    vscode.window.showQuickPick([
      'Code Optimization',
      'Bug Finding',
      'Documentation Generation',
      'Code Review'
    ], {
      placeHolder: 'Select an AI collaboration task'
    }).then(selection => {
      if (selection) {
        vscode.window.showInformationMessage(`Starting ${selection} task...`);
      }
    });
  });
  
  // Add status bar items
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse AI Tools";
  statusBarItem.command = 'thefuse.helloWorld';
  statusBarItem.show();
  
  // Register all disposables
  context.subscriptions.push(helloCommand, aiCollabCommand, statusBarItem);
}

function deactivate() {}

module.exports = { activate, deactivate };
EOF

echo "Running extension in DEVELOPMENT MODE (bypassing the publisher validation)..."

# The critical step: Launch VS Code with the extension in development mode 
# This bypasses publisher validation entirely
code --extensionDevelopmentPath="$(pwd)"

echo ""
echo "NOTE: Running in development mode means you WON'T be able to use the 'Manage Extension' feature"
echo "This is expected and normal for extensions being developed/tested."
echo "All functionality of the extension will still work!"
echo ""
echo "To reload the extension after changes:"
echo "1. Press Cmd+Shift+P (or Ctrl+Shift+P)"
echo "2. Type 'Developer: Reload Window' and press Enter"



==============================================
FILE: ./src/vscode-extension/full-setup.sh
==============================================

#!/bin/bash

echo "======================================================"
echo "  The New Fuse - Full Extension Setup"
echo "======================================================"
echo ""

# Create necessary directory structure
mkdir -p out
mkdir -p test
mkdir -p web-ui
mkdir -p .vscode
mkdir -p ai-communication  # For file-based inter-extension communication

# Configure package.json and typescript configuration
echo "Setting up configurations..."

# Create the example code file for testing if it doesn't exist
if [ ! -f "test/example-code.ts" ]; then
  mkdir -p test
  cp test/example-code.ts test/example-code.ts 2>/dev/null || echo "Creating example code file..."
fi

# Install dependencies
echo "Installing dependencies..."
npm install uuid
npm install --save-dev @types/vscode @types/node @types/uuid typescript

# Compile TypeScript files
echo "Compiling TypeScript files..."
npm run compile

# Check if compilation succeeded
if [ $? -ne 0 ]; then
  echo "⚠️ Compilation failed. Please check for errors in your TypeScript files."
else
  echo "✅ Compilation successful!"
fi

echo ""
echo "============================================================"
echo "  Setup complete! 🎉"
echo "============================================================"
echo ""
echo "To activate the extension in your current VS Code window:"
echo "1. Open the Command Palette (Ctrl+Shift+P or Cmd+Shift+P)"
echo "2. Run \"Developer: Reload Window\""
echo ""
echo "After reloading, the extension will be active in your current window."
echo "Check the status bar for the New Fuse icons."
echo ""



==============================================
FILE: ./src/vscode-extension/inter-ai-hub.ts
==============================================

import * as vscode from 'vscode';
import { AgentClient } from './agent-communication';
import { LMAPIBridge } from './lm-api-bridge';

/**
 * Interface for an AI agent registration
 */
export interface AIAgentRegistration {
  id: string;
  name: string;
  capabilities: string[];
  version: string;
  provider?: string;
  apiType?: string;
  lastSeen: number;
  active: boolean;
}

/**
 * Interface for a communication log entry
 */
export interface CommunicationLogEntry {
  timestamp: number;
  sender: string;
  recipient: string;
  action: string;
  direction: 'outgoing' | 'incoming';
  successful: boolean;
  error?: string;
}

/**
 * Central hub for coordinating AI agent communication
 */
export class InterAIHub {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private lmBridge: LMAPIBridge;
  private outputChannel: vscode.OutputChannel;
  private statusBarItem: vscode.StatusBarItem;
  private communicationLog: CommunicationLogEntry[] = [];
  private agentStatusListeners: ((agents: AIAgentRegistration[]) => void)[] = [];

  constructor(context: vscode.ExtensionContext, agentClient: AgentClient, lmBridge: LMAPIBridge) {
    this.context = context;
    this.agentClient = agentClient;
    this.lmBridge = lmBridge;
    this.outputChannel = vscode.window.createOutputChannel('Inter-AI Hub');
    
    // Status bar item to show connected agents
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 10);
    this.statusBarItem.text = "$(plug) AI Agents: Initializing...";
    this.statusBarItem.tooltip = "Click to view connected AI agents";
    this.statusBarItem.command = 'thefuse.showConnectedAgents';
    this.statusBarItem.show();
    
    // Register commands
    this.registerCommands();
    
    // Start monitoring for agent updates
    this.startAgentMonitoring();
    
    // Subscribe to message events
    this.subscribeToMessages();
  }
  
  /**
   * Register commands related to the Inter-AI Hub
   */
  private registerCommands() {
    // Command to show connected agents
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.showConnectedAgents', () => {
        this.showConnectedAgents();
      })
    );
    
    // Command to view communication log
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.viewCommunicationLog', () => {
        this.showCommunicationLog();
      })
    );
    
    // Command to test connection with an agent
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.testAgentConnection', async (agentId?: string) => {
        return this.testAgentConnection(agentId);
      })
    );
    
    // Command to send a custom message
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.sendCustomMessage', async (recipient?: string, action?: string, payload?: any) => {
        return this.sendCustomMessage(recipient, action, payload);
      })
    );
  }
  
  /**
   * Start monitoring for agent updates
   */
  private startAgentMonitoring() {
    // Check agents every 30 seconds
    setInterval(() => this.updateAgentStatus(), 30000);
    
    // Do an initial update
    this.updateAgentStatus();
  }
  
  /**
   * Subscribe to message events
   */
  private subscribeToMessages() {
    this.agentClient.subscribe(async (message: any) => {
      // Log the message
      this.logCommunication({
        timestamp: Date.now(),
        sender: message.sender,
        recipient: message.recipient,
        action: message.action,
        direction: 'incoming',
        successful: true
      });
      
      // Process the message
      await this.processIncomingMessage(message);
    });
  }
  
  /**
   * Process an incoming message
   */
  private async processIncomingMessage(message: any) {
    // Handle ping/pong messages
    if (message.action === 'ping') {
      await this.agentClient.sendMessage(message.sender, 'pong', {
        requestId: message.id,
        timestamp: Date.now()
      });
    }
    
    // Handle capability requests
    if (message.action === 'getCapabilities') {
      await this.agentClient.sendMessage(message.sender, 'capabilities', {
        requestId: message.id,
        capabilities: ['inter-ai-communication', 'orchestration', 'messaging']
      });
    }
  }
  
  /**
   * Update agent status
   */
  private async updateAgentStatus() {
    try {
      // Get registered agents
      const agents = await this.agentClient.getRegisteredAgents();
      
      // Update status bar with count
      const activeAgents = agents.filter((agent: AIAgentRegistration) => agent.active !== false);
      this.statusBarItem.text = `$(plug) AI Agents: ${activeAgents.length}`;
      
      // Notify listeners
      this.notifyAgentStatusListeners(agents);
      
      this.log(`Updated agent status. ${activeAgents.length} active agents.`);
    } catch (error: any) {
      this.log(`Error updating agent status: ${error.message}`);
    }
  }
  
  /**
   * Show connected agents in a quick pick
   */
  private async showConnectedAgents() {
    try {
      const agents = await this.agentClient.getRegisteredAgents();
      
      // Check if we have any agents
      if (!agents || agents.length === 0) {
        vscode.window.showInformationMessage('No AI agents connected. Try discovering agents first.');
        return;
      }
      
      // Create quick pick items
      const items = (agents as AIAgentRegistration[]).map((agent: AIAgentRegistration) => ({
        label: agent.name || agent.id,
        description: agent.capabilities ? agent.capabilities.join(', ') : 'No capabilities',
        detail: `ID: ${agent.id} | Version: ${agent.version || 'unknown'} | Active: ${agent.active !== false ? 'Yes' : 'No'}`,
        agent
      }));
      
      // Show quick pick
      const selected = await vscode.window.showQuickPick(items as any, {
        placeHolder: 'Select an AI agent to interact with',
        matchOnDescription: true,
        matchOnDetail: true
      });
      
      if (selected) {
        await this.showAgentActions((selected as any).agent);
      }
    } catch (error: any) {
      this.log(`Error showing connected agents: ${error.message}`);
      vscode.window.showErrorMessage(`Error retrieving connected agents: ${error.message}`);
    }
  }
  
  /**
   * Show actions for a specific agent
   */
  private async showAgentActions(agent: AIAgentRegistration) {
    const actions = [
      {
        label: '$(zap) Test Connection',
        description: 'Ping the agent to test connection',
        action: 'test'
      },
      {
        label: '$(comment-discussion) Send Custom Message',
        description: 'Send a custom message to this agent',
        action: 'message'
      },
      {
        label: '$(info) View Capabilities',
        description: 'View detailed capabilities',
        action: 'capabilities'
      }
    ];
    
    const selected = await vscode.window.showQuickPick(actions, {
      placeHolder: `Select an action for ${agent.name || agent.id}`
    });
    
    if (!selected) return;
    
    switch (selected.action) {
      case 'test':
        await this.testAgentConnection(agent.id);
        break;
      case 'message':
        await this.sendCustomMessage(agent.id);
        break;
      case 'capabilities':
        await this.showAgentCapabilities(agent);
        break;
    }
  }
  
  /**
   * Test connection with an agent
   */
  private async testAgentConnection(agentId?: string) {
    try {
      // If no agent ID provided, ask for one
      if (!agentId) {
        const agents = await this.agentClient.getRegisteredAgents();
        const items = (agents as AIAgentRegistration[]).map((agent: AIAgentRegistration) => ({
          label: agent.name || agent.id,
          description: agent.id,
          id: agent.id
        }));
        
        const selected = await vscode.window.showQuickPick(items as any, {
          placeHolder: 'Select an agent to test connection with'
        });
        
        if (!selected) return false;
        
        agentId = (selected as any).id;
      }
      
      // Send a ping message
      this.log(`Testing connection with agent ${agentId}...`);
      const startTime = Date.now();
      
      // Log the outgoing message
      this.logCommunication({
        timestamp: startTime,
        sender: 'thefuse.main',
        recipient: agentId || '',
        action: 'ping',
        direction: 'outgoing',
        successful: true
      });
      
      // Send the ping message
      const success = await this.agentClient.sendMessage(agentId || '', 'ping', {
        timestamp: startTime
      });
      
      if (success) {
        const endTime = Date.now();
        const responseTime = endTime - startTime;
        vscode.window.showInformationMessage(`Successfully connected to ${agentId} (${responseTime}ms)`);
        return true;
      } else {
        vscode.window.showErrorMessage(`Failed to connect to ${agentId}`);
        return false;
      }
    } catch (error: any) {
      this.log(`Error testing connection: ${error.message}`);
      vscode.window.showErrorMessage(`Error testing connection: ${error.message}`);
      return false;
    }
  }
  
  /**
   * Send a custom message to an agent
   */
  private async sendCustomMessage(recipient?: string, action?: string, payload?: any) {
    try {
      // If no recipient provided, ask for one
      if (!recipient) {
        const agents = await this.agentClient.getRegisteredAgents();
        const items = (agents as AIAgentRegistration[]).map((agent: AIAgentRegistration) => ({
          label: agent.name || agent.id,
          description: agent.id,
          id: agent.id
        }));
        
        const selected = await vscode.window.showQuickPick(items as any, {
          placeHolder: 'Select a recipient agent'
        });
        
        if (!selected) return false;
        
        recipient = (selected as any).id;
      }
      
      // If no action provided, ask for one
      if (!action) {
        action = await vscode.window.showInputBox({
          prompt: 'Enter action name',
          placeHolder: 'e.g., generateText, analyzeCode'
        });
        
        if (!action) return false;
      }
      
      // If no payload provided, ask for one
      if (!payload) {
        const payloadInput = await vscode.window.showInputBox({
          prompt: 'Enter payload (JSON)',
          placeHolder: '{"prompt": "Hello world"}'
        });
        
        if (!payloadInput) return false;
        
        try {
          payload = JSON.parse(payloadInput);
        } catch (error) {
          vscode.window.showErrorMessage('Invalid JSON payload');
          return false;
        }
      }
      
      // Log the outgoing message
      this.logCommunication({
        timestamp: Date.now(),
        sender: 'thefuse.main',
        recipient: recipient as string,
        action,
        direction: 'outgoing',
        successful: true
      });
      
      // Send the message
      const success = await this.agentClient.sendMessage(recipient || '', action || '', payload);
      
      if (success) {
        vscode.window.showInformationMessage(`Message sent to ${recipient}`);
        return true;
      } else {
        vscode.window.showErrorMessage(`Failed to send message to ${recipient}`);
        return false;
      }
    } catch (error: any) {
      this.log(`Error sending custom message: ${error.message}`);
      vscode.window.showErrorMessage(`Error sending message: ${error.message}`);
      return false;
    }
  }
  
  /**
   * Show agent capabilities
   */
  private async showAgentCapabilities(agent: AIAgentRegistration) {
    const capabilitiesContent = `# ${agent.name || agent.id} Capabilities

ID: ${agent.id}
Version: ${agent.version || 'unknown'}
Provider: ${agent.provider || 'unknown'}
API Type: ${agent.apiType || 'unknown'}
Last Seen: ${new Date(agent.lastSeen).toLocaleString()}
Active: ${agent.active !== false ? 'Yes' : 'No'}

## Capabilities
${agent.capabilities ? agent.capabilities.map(cap => `- ${cap}`).join('\n') : 'No capabilities reported'}
`;
    
    // Show in editor
    const doc = await vscode.workspace.openTextDocument({
      content: capabilitiesContent,
      language: 'markdown'
    });
    await vscode.window.showTextDocument(doc);
  }
  
  /**
   * Show communication log
   */
  private async showCommunicationLog() {
    if (this.communicationLog.length === 0) {
      vscode.window.showInformationMessage('No communication logged yet');
      return;
    }
    
    // Format log entries
    const logContent = this.communicationLog.map(entry => {
      const timestamp = new Date(entry.timestamp).toLocaleString();
      const direction = entry.direction === 'outgoing' ? '→' : '←';
      const status = entry.successful ? '✓' : '✗';
      return `[${timestamp}] ${status} ${entry.sender} ${direction} ${entry.recipient}: ${entry.action}`;
    }).join('\n');
    
    // Show in editor
    const doc = await vscode.workspace.openTextDocument({
      content: logContent,
      language: 'plaintext'
    });
    await vscode.window.showTextDocument(doc);
  }
  
  /**
   * Log a communication entry
   */
  private logCommunication(entry: CommunicationLogEntry) {
    // Add to log
    this.communicationLog.push(entry);
    
    // Truncate log if it gets too long
    if (this.communicationLog.length > 1000) {
      this.communicationLog = this.communicationLog.slice(-500);
    }
    
    // Log to output channel
    const timestamp = new Date(entry.timestamp).toLocaleString();
    const direction = entry.direction === 'outgoing' ? '→' : '←';
    this.log(`${timestamp} ${entry.sender} ${direction} ${entry.recipient}: ${entry.action}`);
  }
  
  /**
   * Add a listener for agent status changes
   */
  public onAgentStatusChanged(listener: (agents: AIAgentRegistration[]) => void): vscode.Disposable {
    this.agentStatusListeners.push(listener);
    
    return {
      dispose: () => {
        const index = this.agentStatusListeners.indexOf(listener);
        if (index !== -1) {
          this.agentStatusListeners.splice(index, 1);
        }
      }
    };
  }
  
  /**
   * Notify listeners of agent status change
   */
  private notifyAgentStatusListeners(agents: AIAgentRegistration[]) {
    for (const listener of this.agentStatusListeners) {
      listener(agents);
    }
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string) {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }
  
  /**
   * Dispose of resources
   */
  public dispose() {
    this.statusBarItem.dispose();
    this.outputChannel.dispose();
  }
}

// Export factory function
export function createInterAIHub(
  context: vscode.ExtensionContext,
  agentClient: AgentClient,
  lmBridge: any // Changed type to 'any' to be compatible with both implementations
): InterAIHub {
  return new InterAIHub(context, agentClient, lmBridge as LMAPIBridge);
}



==============================================
FILE: ./src/vscode-extension/interfaces/message-transport.tsx
==============================================

import * as vscode from 'vscode';
import { AgentMessage } from '../agent-communication';

export interface MessageTransport {
    initialize(): Promise<void>;
    sendMessage(message: AgentMessage): Promise<boolean>;
    subscribeToMessages(callback: (message: AgentMessage) => Promise<void>): vscode.Disposable;
    dispose(): void;
}


==============================================
FILE: ./src/vscode-extension/launch-commands.js
==============================================

// Simple script to force-register The New Fuse commands
// To use:
// 1. Open VS Code with the extension loaded
// 2. Open the built-in terminal (Terminal > New Terminal)
// 3. Paste and run this code

import vscode from 'vscode';

// Register commands
async function registerCommands() {
  // All core commands are now registered in the main extension.ts file
  // This script only creates a status bar item that links to the main functionality

  // Status bar items
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse - Click to start AI collaboration";
  statusBarItem.command = 'thefuse.startAICollab'; // Link to the main AI collaboration command
  statusBarItem.show();
  
  // Create a secondary status bar item for opening the command palette
  const commandPaletteItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 1);
  commandPaletteItem.text = "$(list-unordered) Commands";
  commandPaletteItem.tooltip = "Open The New Fuse Command Palette";
  commandPaletteItem.command = 'thefuse.openMcpCommandPalette'; // Link to the MCP command palette
  commandPaletteItem.show();
  
  vscode.window.showInformationMessage('The New Fuse commands are now registered!');
  return 'Commands registered';
}

// Execute the function
registerCommands().then(result => {
  console.log(result);
});



==============================================
FILE: ./src/vscode-extension/launch-extension.js
==============================================

import cp from 'child_process';
import path from 'path';
import fs from 'fs';

// Get the current directory
const extensionPath = __dirname;

// Ensure we have a compiled extension (placeholder for tests)
if (!fs.existsSync(path.join(extensionPath, 'out'))) {
  fs.mkdirSync(path.join(extensionPath, 'out'), { recursive: true });
  
  // Create a minimal extension.js in the out directory
  const minimalExtension = `
    import vscode from 'vscode';
    
    function activate(context) {

      // Command registration moved to main extension.ts
      // context.subscriptions.push(disposable);
    }
    
    function deactivate() {}
    
    module.exports = { activate, deactivate };
  `;
  
  fs.writeFileSync(path.join(extensionPath, 'out', 'extension.js'), minimalExtension);
}

// Determine VS Code path based on platform
let vscodePath;
if (process.platform === 'darwin') {
  vscodePath = '/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code';
  if (!fs.existsSync(vscodePath)) {
    vscodePath = 'code'; // Fallback to PATH
  }
} else if (process.platform === 'win32') {
  vscodePath = 'code.cmd';
} else {
  vscodePath = 'code';
}

// Launch VS Code with the extension
const proc = cp.spawn(vscodePath, [
  '--new-window',
  '--extensionDevelopmentPath=' + extensionPath
], {
  stdio: 'inherit'
});

proc.on('error', (err) => {
  console.error('Failed to start VS Code:', err);
});

proc.on('close', (code) => {
  
});



==============================================
FILE: ./src/vscode-extension/launch-extension.sh
==============================================

#!/bin/bash

# Enhanced launch script for The New Fuse VSCode Extension
# This script properly organizes, compiles, and launches the extension

echo "🚀 Preparing The New Fuse VS Code Extension..."

# Ensure we have the correct VS Code path
VSCODE="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
if [ ! -f "$VSCODE" ]; then
  VSCODE="code" # Try using the PATH version if the direct path doesn't exist
fi

# Set directories
EXTENSION_DIR="$(pwd)"
SRC_DIR="$EXTENSION_DIR/src"
OUT_DIR="$EXTENSION_DIR/out"

# Create necessary directories
mkdir -p "$SRC_DIR/chat"
mkdir -p "$SRC_DIR/views"

echo "📁 Ensuring correct file structure..."

# Fix import in the settings view provider file
if [ -f "$SRC_DIR/views/settings-view-provider.ts" ]; then
  # Add vscode import if missing
  if ! grep -q "import \* as vscode from 'vscode';" "$SRC_DIR/views/settings-view-provider.ts"; then
    sed -i '' '1s/^/import * as vscode from '\''vscode'\'';\n/' "$SRC_DIR/views/settings-view-provider.ts"
  fi
  echo "✅ Settings view provider is ready"
fi

# Check if tsconfig.json is set correctly
if [ -f "$EXTENSION_DIR/tsconfig.json" ]; then
  echo "📝 Ensuring TypeScript configuration is correct..."
  # Update rootDir in tsconfig.json if needed
  if grep -q '"rootDir": "src"' "$EXTENSION_DIR/tsconfig.json"; then
    echo "⚙️ Updating TypeScript configuration for our file structure..."
    sed -i '' 's/"rootDir": "src"/"rootDir": "."/' "$EXTENSION_DIR/tsconfig.json"
  fi
  # Make sure include has both src and root TS files
  if ! grep -q '"include": \["src/\*\*/\*", "\*.ts"\]' "$EXTENSION_DIR/tsconfig.json"; then
    sed -i '' 's/"include": \["src\/\*\*\/\*"\]/"include": \["src\/\*\*\/\*", "\*.ts"\]/' "$EXTENSION_DIR/tsconfig.json"
  fi
fi

# Compile the extension
echo "🔨 Compiling the extension..."
npx tsc

# Check if compilation was successful
if [ $? -eq 0 ]; then
  echo "✅ Compilation successful!"
else
  echo "❌ Compilation failed. Please check the errors above."
  exit 1
fi

# Launch VS Code with the extension
echo "🚀 Launching VS Code with The New Fuse Extension..."
"$VSCODE" --extensionDevelopmentPath="$EXTENSION_DIR" "$@"

echo "Extension development session started."


==============================================
FILE: ./src/vscode-extension/launch-vscode.sh
==============================================

#!/bin/bash

echo "Launching VS Code with The New Fuse extension..."

# Find VS Code on different platforms
if [ -x "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code" ]; then
  VSCODE_PATH="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
elif command -v code &> /dev/null; then
  VSCODE_PATH="code"
elif command -v code-insiders &> /dev/null; then
  VSCODE_PATH="code-insiders"
else
  echo "Error: Cannot find VS Code. Please make sure VS Code is installed."
  exit 1
fi

# Launch VS Code with the extension
"$VSCODE_PATH" --new-window --extensionDevelopmentPath="$(pwd)"

echo "VS Code launched with The New Fuse extension."
echo "Use Command Palette (Cmd+Shift+P or Ctrl+Shift+P) and type 'thefuse' to see available commands."



==============================================
FILE: ./src/vscode-extension/launch.sh
==============================================

#!/bin/bash

# Make sure VS Code can find the script and extension
CODE_PATH=""

# Find VS Code binary based on platform
if [ -x "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code" ]; then
  CODE_PATH="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
elif command -v code &> /dev/null; then
  CODE_PATH="code"
else
  echo "Error: VS Code not found. Please make sure VS Code is installed."
  exit 1
fi

# Launch VS Code with the extension
echo "Launching VS Code with The New Fuse extension..."
"$CODE_PATH" --new-window --extensionDevelopmentPath="$(pwd)"

echo "VS Code launched! Use Command Palette (Cmd+Shift+P) and type 'MCP' to see the commands."



==============================================
FILE: ./src/vscode-extension/llm-orchestrator-simple.ts
==============================================

/**
 * Simplified LLM Orchestrator
 */

import * as vscode from 'vscode';

export class LLMOrchestrator {
  private context: vscode.ExtensionContext;
  private statusBarItem: vscode.StatusBarItem;
  private registeredAgents: any[] = [];
  
  constructor(context: vscode.ExtensionContext) {
    this.context = context;
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    this.statusBarItem.text = "$(hubot) AI Agents";
    this.statusBarItem.tooltip = "Manage AI Agents";
    this.statusBarItem.command = 'llm-orchestrator.showAgents';
    this.statusBarItem.show();
    
    // Register commands
    this.registerCommands();
  }
  
  private registerCommands() {
    // Register command to show registered agents
    this.context.subscriptions.push(
      vscode.commands.registerCommand('llm-orchestrator.showAgents', () => {
        this.showAgentsMenu();
      })
    );
    
    // Register command to discover agents
    this.context.subscriptions.push(
      vscode.commands.registerCommand('llm-orchestrator.discoverAgents', () => {
        this.discoverLLMAgents();
      })
    );
  }
  
  private async discoverLLMAgents() {
    // This is a placeholder for actually discovering agents
    this.registeredAgents = [
      {
        id: 'copilot.agent',
        name: 'GitHub Copilot',
        description: 'AI code assistant powered by OpenAI',
        capabilities: ['code-generation', 'code-completion']
      },
      {
        id: 'claude.agent',
        name: 'Claude',
        description: 'Anthropic\'s Claude assistant',
        capabilities: ['text-generation', 'code-explanation']
      }
    ];
    
    vscode.window.showInformationMessage(`Discovered ${this.registeredAgents.length} AI agents.`);
    this.statusBarItem.text = `$(hubot) AI Agents (${this.registeredAgents.length})`;
  }
  
  private async showAgentsMenu() {
    if (this.registeredAgents.length === 0) {
      vscode.window.showInformationMessage('No AI agents registered. Discover agents first.');
      return;
    }
    
    const items = this.registeredAgents.map(agent => ({
      label: agent.name,
      description: agent.description,
      detail: `ID: ${agent.id} | Capabilities: ${agent.capabilities.join(', ')}`,
      agent
    }));
    
    vscode.window.showQuickPick(items, {
      placeHolder: 'Select an AI agent to use',
      title: 'Available AI Agents'
    });
  }
  
  // Get registered agents
  getRegisteredAgents(): any[] {
    return this.registeredAgents;
  }
  
  // Dispose of resources
  dispose() {
    this.statusBarItem.dispose();
  }
}

// Export factory function
export function createLLMOrchestrator(context: vscode.ExtensionContext): LLMOrchestrator {
  return new LLMOrchestrator(context);
}



==============================================
FILE: ./src/vscode-extension/llm-orchestrator.tsx
==============================================

/**
 * LLM Orchestrator for VS Code Extensions
 * 
 * This module coordinates multiple AI LLM extensions in VS Code
 * to enable collaborative AI coding capabilities.
 */

import * as vscode from 'vscode';
import { initializeOrchestrator, createAgentClient, AgentMessage } from './agent-communication';
import * as fs from 'fs';
import * as path from 'path';
import { getErrorMessage } from './utilities';

// Define the LLM Agent interface
export interface LLMAgent {
  id: string;
  name: string;
  description: string;
  capabilities: string[];
  version: string;
  extensionId: string;
  commandId: string;
}

// Interface to track agent tasks
export interface AgentTask {
  id: string;
  agentId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  action: string;
  input: any;
  result?: any;
  startTime: number;
  endTime?: number;
  error?: string;
}

// LLM Orchestrator class
export class LLMOrchestrator {
  private context: vscode.ExtensionContext;
  private agentClient: any;
  private registeredAgents: Map<string, LLMAgent> = new Map();
  private activeTasks: Map<string, AgentTask> = new Map();
  private statusBarItem: vscode.StatusBarItem;
  private outputChannel: vscode.OutputChannel;
  
  constructor(context: vscode.ExtensionContext) {
    this.context = context;
    this.outputChannel = vscode.window.createOutputChannel('LLM Orchestrator');
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    this.statusBarItem.text = "$(hubot) AI Agents";
    this.statusBarItem.tooltip = "Manage AI Agents";
    this.statusBarItem.command = 'llm-orchestrator.showAgents';
    this.statusBarItem.show();
    
    // Initialize communication
    this.initialize();
  }
  
  private async initialize() {
    // Create agent client for this orchestrator
    this.agentClient = createAgentClient(this.context, 'llm-orchestrator', this.outputChannel);
    
    // Register this orchestrator
    await this.agentClient.register(
      'LLM Orchestrator',
      ['orchestration', 'llm-coordination', 'workflow-execution'],
      '1.0.0'
    );
    
    // Load registered agents from storage
    const savedAgents = this.context.globalState.get<LLMAgent[]>('llm-orchestrator.agents', []);
    savedAgents.forEach(agent => {
      this.registeredAgents.set(agent.id, agent);
    });
    
    // Subscribe to messages
    await this.agentClient.subscribe(this.handleMessage.bind(this));
    
    // Register commands
    this.registerCommands();
    
    // Discover available LLM agents in VS Code
    this.discoverLLMAgents();
    
    this.log('LLM Orchestrator initialized');
  }
  
  private registerCommands() {
    // Register command to show registered agents
    this.context.subscriptions.push(
      vscode.commands.registerCommand('llm-orchestrator.showAgents', () => {
        this.showAgentsMenu();
      })
    );
    
    // Register command to discover agents
    this.context.subscriptions.push(
      vscode.commands.registerCommand('llm-orchestrator.discoverAgents', () => {
        this.discoverLLMAgents();
      })
    );
    
    // Register command to execute agent action
    this.context.subscriptions.push(
      vscode.commands.registerCommand('llm-orchestrator.executeAgent', async (agentId: string, action: string, input: any) => {
        return this.executeAgentAction(agentId, action, input);
      })
    );
    
    // Register command to create collaborative task
    this.context.subscriptions.push(
      vscode.commands.registerCommand('llm-orchestrator.createCollaborativeTask', () => {
        this.startCollaborativeTask();
      })
    );
  }
  
  private async handleMessage(message: AgentMessage): Promise<void> {
    this.log(`Received message: ${message.action} from ${message.sender}`);
    
    switch (message.action) {
      case 'register':
        if (message.payload.agent) {
          await this.registerAgent(message.payload.agent);
        }
        break;
        
      case 'taskStatus':
        if (message.payload.taskId) {
          await this.updateTaskStatus(
            message.payload.taskId,
            message.payload.status,
            message.payload.result,
            message.payload.error
          );
        }
        break;
        
      case 'requestAssistance':
        await this.handleAssistanceRequest(message.sender, message.payload);
        break;
        
      default:
        this.log(`Unknown action: ${message.action}`);
    }
  }
  
  private async discoverLLMAgents() {
    this.log('Discovering LLM agents in VS Code...');
    
    // This is a simplified discovery mechanism
    // In a real implementation, we would use VS Code extension API to discover 
    // extensions that declare themselves as LLM agents
    
    // For now, we'll query specific known commands that LLM extensions might expose
    const possibleAgents = [
      { id: 'github.copilot', name: 'GitHub Copilot', commandId: 'github.copilot.generate' },
      { id: 'ms-toolsai.vscode-ai', name: 'Azure AI', commandId: 'vscode-ai.execute' },
      { id: 'anthropic.claude', name: 'Claude', commandId: 'anthropic.claude.generate' },
      { id: 'openai.gpt4', name: 'GPT-4', commandId: 'openai.gpt4.generate' },
      { id: 'codellama.vscode', name: 'Code Llama', commandId: 'codellama.generate' },
      { id: 'codeium.codeium', name: 'Codeium', commandId: 'codeium.generate' }
    ];
    
    for (const agent of possibleAgents) {
      try {
        // Check if the command exists by trying to get its implementation
        // Note: This is not a reliable way to check, but VS Code API has limitations
        const hasCommand = await vscode.commands.getCommands(true)
          .then(commands => commands.includes(agent.commandId));
        
        if (hasCommand) {
          // Create agent entry
          const llmAgent: LLMAgent = {
            id: agent.id,
            name: agent.name,
            description: `${agent.name} AI assistant`,
            capabilities: ['code-generation', 'code-completion', 'code-explanation'],
            version: '1.0.0',
            extensionId: agent.id,
            commandId: agent.commandId
          };
          
          await this.registerAgent(llmAgent);
          this.log(`Discovered agent: ${agent.name}`);
        }
      } catch (error) {
        // Command doesn't exist or can't be executed
        this.log(`Agent ${agent.name} not available: ${getErrorMessage(error)}`);
      }
    }
    
    this.statusBarItem.text = `$(hubot) AI Agents (${this.registeredAgents.size})`;
    
    if (this.registeredAgents.size === 0) {
      vscode.window.showInformationMessage('No LLM agents discovered. Try installing compatible AI extensions.');
    } else {
      vscode.window.showInformationMessage(`Discovered ${this.registeredAgents.size} LLM agents in VS Code.`);
    }
  }
  
  private async registerAgent(agent: LLMAgent): Promise<boolean> {
    // Add to our registry if not already present
    if (!this.registeredAgents.has(agent.id)) {
      this.registeredAgents.set(agent.id, agent);
      
      // Persist to storage
      await this.context.globalState.update(
        'llm-orchestrator.agents', 
        Array.from(this.registeredAgents.values())
      );
      
      this.log(`Registered agent: ${agent.name} (${agent.id})`);
      this.statusBarItem.text = `$(hubot) AI Agents (${this.registeredAgents.size})`;
      
      return true;
    }
    
    return false;
  }
  
  private async executeAgentAction(agentId: string, action: string, input: any): Promise<any> {
    const agent = this.registeredAgents.get(agentId);
    if (!agent) {
      throw new Error(`Agent not found: ${agentId}`);
    }
    
    // Create a task to track this execution
    const taskId = `task-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
    const task: AgentTask = {
      id: taskId,
      agentId,
      action,
      input,
      status: 'pending',
      startTime: Date.now()
    };
    
    this.activeTasks.set(taskId, task);
    
    try {
      // Set task to running
      task.status = 'running';
      
      // Execute the agent's command
      this.log(`Executing ${agent.name} (${action})`);
      
      // Different agents have different command signatures, so we need to handle this
      // This is a simplified approach - in a real implementation we'd need more
      // sophisticated command mapping
      let result;
      
      if (agent.id === 'github.copilot') {
        // GitHub Copilot has a specific command signature
        result = await vscode.commands.executeCommand(agent.commandId, input.prompt, input.context);
      } else if (agent.id === 'ms-toolsai.vscode-ai') {
        // Azure AI might have a different signature
        result = await vscode.commands.executeCommand(agent.commandId, {
          prompt: input.prompt,
          context: input.context,
          options: input.options
        });
      } else {
        // Generic approach for other LLM extensions
        result = await vscode.commands.executeCommand(agent.commandId, input);
      }
      
      // Update task status
      task.status = 'completed';
      task.result = result;
      task.endTime = Date.now();
      
      return result;
    } catch (error) {
      // Update task with error
      task.status = 'failed';
      task.error = getErrorMessage(error);
      task.endTime = Date.now();
      
      this.log(`Execution error (${agent.name}): ${getErrorMessage(error)}`);
      throw error;
    }
  }
  
  private async updateTaskStatus(
    taskId: string,
    status: 'pending' | 'running' | 'completed' | 'failed',
    result?: any,
    error?: string
  ): Promise<void> {
    const task = this.activeTasks.get(taskId);
    if (!task) {
      this.log(`Task not found: ${taskId}`);
      return;
    }
    
    task.status = status;
    
    if (status === 'completed' || status === 'failed') {
      task.endTime = Date.now();
      
      if (status === 'completed') {
        task.result = result;
      } else {
        task.error = error;
      }
    }
  }
  
  private async handleAssistanceRequest(
    senderId: string,
    payload: { task: string, context: any }
  ): Promise<void> {
    // Find an agent that can help with this task
    const availableAgents = Array.from(this.registeredAgents.values())
      .filter(agent => agent.id !== senderId); // Exclude the sender
    
    if (availableAgents.length === 0) {
      await this.agentClient.sendMessage(senderId, 'assistanceResponse', {
        success: false,
        error: 'No other agents available to help'
      });
      return;
    }
    
    // For now, just use the first available agent
    // In a real implementation, we'd select based on capabilities
    const selectedAgent = availableAgents[0];
    
    try {
      // Execute the helper agent
      const result = await this.executeAgentAction(
        selectedAgent.id,
        'assist',
        {
          task: payload.task,
          context: payload.context,
          requesterId: senderId
        }
      );
      
      // Send the result back to the requester
      await this.agentClient.sendMessage(senderId, 'assistanceResponse', {
        success: true,
        agentId: selectedAgent.id,
        result
      });
    } catch (error) {
      await this.agentClient.sendMessage(senderId, 'assistanceResponse', {
        success: false,
        agentId: selectedAgent.id,
        error: error.message
      });
    }
  }
  
  private async showAgentsMenu() {
    if (this.registeredAgents.size === 0) {
      vscode.window.showInformationMessage('No LLM agents registered. Discover agents first.');
      return;
    }
    
    const agents = Array.from(this.registeredAgents.values());
    const items = agents.map(agent => ({
      label: agent.name,
      description: agent.description,
      detail: `ID: ${agent.id} | Capabilities: ${agent.capabilities.join(', ')}`,
      agent
    }));
    
    const selected = await vscode.window.showQuickPick(items, {
      placeHolder: 'Select an AI agent to use',
      title: 'Available AI Agents'
    });
    
    if (selected) {
      this.showAgentActions(selected.agent);
    }
  }
  
  private async showAgentActions(agent: LLMAgent) {
    const actions = [
      { label: '$(code) Generate Code', action: 'generateCode' },
      { label: '$(book) Explain Code', action: 'explainCode' },
      { label: '$(debug) Refactor Code', action: 'refactorCode' },
      { label: '$(question) Ask Question', action: 'askQuestion' },
      { label: '$(trash) Unregister Agent', action: 'unregister' }
    ];
    
    const selected = await vscode.window.showQuickPick(actions, {
      placeHolder: `Select action for ${agent.name}`,
      title: `${agent.name} Actions`
    });
    
    if (!selected) return;
    
    switch (selected.action) {
      case 'generateCode':
        await this.executeCodeGeneration(agent);
        break;
      case 'explainCode':
        await this.executeCodeExplanation(agent);
        break;
      case 'refactorCode':
        await this.executeCodeRefactoring(agent);
        break;
      case 'askQuestion':
        await this.executeAskQuestion(agent);
        break;
      case 'unregister':
        await this.unregisterAgent(agent.id);
        break;
    }
  }
  
  private async executeCodeGeneration(agent: LLMAgent) {
    const prompt = await vscode.window.showInputBox({
      prompt: 'What code would you like to generate?',
      placeHolder: 'e.g., A function to calculate Fibonacci numbers'
    });
    
    if (!prompt) return;
    
    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: `${agent.name} is generating code...`,
        cancellable: false
      }, async (progress) => {
        const result = await this.executeAgentAction(agent.id, 'generateCode', { prompt });
        
        // Create a new document with the result
        const document = await vscode.workspace.openTextDocument({
          content: typeof result === 'string' ? result : JSON.stringify(result, null, 2),
          language: 'javascript' // Default to JavaScript, could be improved
        });
        
        await vscode.window.showTextDocument(document);
      });
    } catch (error) {
      vscode.window.showErrorMessage(`Error: ${getErrorMessage(error)}`);
    }
  }
  
  private async executeCodeExplanation(agent: LLMAgent) {
    // Get current selection or document
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showErrorMessage('No active editor');
      return;
    }
    
    const selection = editor.selection;
    const text = selection.isEmpty 
      ? editor.document.getText() 
      : editor.document.getText(selection);
    
    if (!text) {
      vscode.window.showErrorMessage('No code selected');
      return;
    }
    
    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: `${agent.name} is explaining code...`,
        cancellable: false
      }, async (progress) => {
        const result = await this.executeAgentAction(agent.id, 'explainCode', { 
          code: text,
          language: editor.document.languageId
        });
        
        // Show the explanation in a webview
        const panel = vscode.window.createWebviewPanel(
          'codeExplanation',
          'Code Explanation',
          vscode.ViewColumn.Beside,
          {}
        );
        
        panel.webview.html = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <style>
              body { font-family: sans-serif; padding: 20px; }
              pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; }
              .explanation { line-height: 1.6; }
            </style>
          </head>
          <body>
            <h2>Code Explanation from ${agent.name}</h2>
            <div class="explanation">${typeof result === 'string' ? result : JSON.stringify(result, null, 2)}</div>
          </body>
          </html>
        `;
      });
    } catch (error) {
      vscode.window.showErrorMessage(`Error: ${getErrorMessage(error)}`);
    }
  }
  
  private async executeCodeRefactoring(agent: LLMAgent) {
    // Get current selection or document
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showErrorMessage('No active editor');
      return;
    }
    
    const selection = editor.selection;
    const text = selection.isEmpty 
      ? editor.document.getText() 
      : editor.document.getText(selection);
    
    if (!text) {
      vscode.window.showErrorMessage('No code selected');
      return;
    }
    
    const instructions = await vscode.window.showInputBox({
      prompt: 'Refactoring instructions',
      placeHolder: 'e.g., Make this more efficient, use async/await, etc.'
    });
    
    if (!instructions) return;
    
    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: `${agent.name} is refactoring code...`,
        cancellable: false
      }, async (progress) => {
        const result = await this.executeAgentAction(agent.id, 'refactorCode', { 
          code: text,
          language: editor.document.languageId,
          instructions
        });
        
        // Apply the refactored code
        if (typeof result === 'string') {
          editor.edit(editBuilder => {
            if (selection.isEmpty) {
              // Replace entire document
              const fullRange = new vscode.Range(
                0, 0,
                editor.document.lineCount - 1,
                editor.document.lineAt(editor.document.lineCount - 1).range.end.character
              );
              editBuilder.replace(fullRange, result);
            } else {
              // Replace only the selection
              editBuilder.replace(selection, result);
            }
          });
        }
      });
    } catch (error) {
      vscode.window.showErrorMessage(`Error: ${getErrorMessage(error)}`);
    }
  }
  
  private async executeAskQuestion(agent: LLMAgent) {
    const question = await vscode.window.showInputBox({
      prompt: 'What would you like to ask?',
      placeHolder: 'e.g., How do I implement X? What is the difference between Y and Z?'
    });
    
    if (!question) return;
    
    // Get current file context
    const editor = vscode.window.activeTextEditor;
    const fileContext = editor ? editor.document.getText() : undefined;
    
    try {
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: `${agent.name} is thinking...`,
        cancellable: false
      }, async (progress) => {
        const result = await this.executeAgentAction(agent.id, 'askQuestion', { 
          question,
          fileContext,
          language: editor?.document.languageId
        });
        
        // Show the answer in a webview
        const panel = vscode.window.createWebviewPanel(
          'agentAnswer',
          'AI Answer',
          vscode.ViewColumn.Beside,
          {}
        );
        
        panel.webview.html = `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <style>
              body { font-family: sans-serif; padding: 20px; }
              pre { background-color: #f5f5f5; padding: 10px; border-radius: 5px; }
              .answer { line-height: 1.6; }
            </style>
          </head>
          <body>
            <h2>Answer from ${agent.name}</h2>
            <div class="answer">${typeof result === 'string' ? result : JSON.stringify(result, null, 2)}</div>
          </body>
          </html>
        `;
      });
    } catch (error) {
      vscode.window.showErrorMessage(`Error: ${getErrorMessage(error)}`);
    }
  }
  
  private async unregisterAgent(agentId: string) {
    if (this.registeredAgents.has(agentId)) {
      this.registeredAgents.delete(agentId);
      
      // Update storage
      await this.context.globalState.update(
        'llm-orchestrator.agents', 
        Array.from(this.registeredAgents.values())
      );
      
      this.statusBarItem.text = `$(hubot) AI Agents (${this.registeredAgents.size})`;
      vscode.window.showInformationMessage(`Agent unregistered successfully.`);
    }
  }
  
  private async startCollaborativeTask() {
    if (this.registeredAgents.size < 2) {
      vscode.window.showInformationMessage('Need at least 2 AI agents for collaboration. Please discover more agents.');
      return;
    }
    
    const taskOptions = [
      { label: '$(code) Code Generation & Review', value: 'codeGenerationReview' },
      { label: '$(debug) Bug Fixing & Testing', value: 'bugFixingTesting' },
      { label: '$(book) Documentation & Explanation', value: 'documentationExplanation' },
      { label: '$(pencil) Refactoring & Optimization', value: 'refactoringOptimization' }
    ];
    
    const selectedTask = await vscode.window.showQuickPick(taskOptions, {
      placeHolder: 'Select a collaborative task type',
      title: 'AI Agent Collaboration'
    });
    
    if (!selectedTask) return;
    
    // Implementation for collaborative tasks would be added here
    // This would involve coordinating multiple agents to work together
    vscode.window.showInformationMessage(`Collaborative task ${selectedTask.label} started.`);
    
    // In a real implementation, we'd orchestrate a workflow between multiple agents
  }
  
  private log(message: string) {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }
  
  // Dispose of resources
  dispose() {
    this.statusBarItem.dispose();
    this.outputChannel.dispose();
  }
}

// Export factory function
export function createLLMOrchestrator(context: vscode.ExtensionContext): LLMOrchestrator {
  return new LLMOrchestrator(context);
}



==============================================
FILE: ./src/vscode-extension/llm-provider-manager.ts
==============================================

import * as vscode from 'vscode';
import { LLMProvider } from './lm-api-bridge';

/**
 * Interface for LLM provider configuration
 */
export interface LLMProviderConfig {
  id: string;
  name: string;
  provider: LLMProvider;
  modelName: string;
  apiKey?: string;
  apiEndpoint?: string;
  isDefault?: boolean;
  isCustom?: boolean;
  isBuiltin?: boolean;
}

/**
 * LLMProviderManager handles the registration, selection, and management
 * of LLM providers within the VS Code extension.
 */
export class LLMProviderManager {
  private providers: Map<string, LLMProviderConfig> = new Map();
  private selectedProviderId: string | undefined;
  private statusBarItem: vscode.StatusBarItem;
  private onProviderChangedEmitter = new vscode.EventEmitter<string>();
  private context: vscode.ExtensionContext;
  private outputChannel: vscode.OutputChannel;

  readonly onProviderChanged = this.onProviderChangedEmitter.event;

  constructor(context: vscode.ExtensionContext, outputChannel: vscode.OutputChannel) {
    this.context = context;
    this.outputChannel = outputChannel;
    
    // Create status bar item
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    this.statusBarItem.command = 'thefuse.selectLLMProvider';
    this.statusBarItem.tooltip = 'Select LLM Provider';
    context.subscriptions.push(this.statusBarItem);
    
    // Register commands
    context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.selectLLMProvider', this.showProviderSelectionQuickPick.bind(this))
    );
    context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.addCustomLLMProvider', this.showAddCustomProviderQuickPick.bind(this))
    );
    context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.manageLLMProviders', this.showManageProvidersQuickPick.bind(this))
    );
    
    // Initialize default providers
    this.initializeDefaultProviders();
    
    // Show in status bar
    this.updateStatusBar();
    this.statusBarItem.show();
  }

  /**
   * Initialize the default LLM providers
   */
  private async initializeDefaultProviders() {
    try {
      this.log('Initializing default LLM providers');
      
      // Register VS Code Copilot provider if available
      const isVSCodeCopilotAvailable = await this.checkCopilotAvailability();
      
      if (isVSCodeCopilotAvailable) {
        this.log('GitHub Copilot is available, adding as provider');
        this.registerProvider({
          id: 'vscode-copilot',
          name: 'GitHub Copilot',
          provider: LLMProvider.VSCode,
          modelName: 'copilot',
          isDefault: true,
          isBuiltin: true
        });
      } else {
        this.log('GitHub Copilot is not available');
      }
      
      // Load saved custom providers from extension storage
      try {
        const customProviders = this.context.globalState.get<LLMProviderConfig[]>('thefuse.customLLMProviders', []);
        for (const provider of customProviders) {
          if (!this.providers.has(provider.id)) {
            this.log(`Loading custom provider: ${provider.name}`);
            this.registerProvider({
              ...provider,
              isCustom: true,
              isBuiltin: false
            });
          }
        }
      } catch (err) {
        this.log(`Failed to load custom LLM providers: ${err instanceof Error ? err.message : String(err)}`);
      }
      
      // Add standard provider configurations
      this.registerProvider({
        id: 'openai-gpt4',
        name: 'OpenAI GPT-4',
        provider: LLMProvider.OpenAI,
        modelName: 'gpt-4',
        isDefault: !isVSCodeCopilotAvailable,
        isBuiltin: true
      });
      
      this.registerProvider({
        id: 'openai-gpt35',
        name: 'OpenAI GPT-3.5 Turbo',
        provider: LLMProvider.OpenAI,
        modelName: 'gpt-3.5-turbo',
        isBuiltin: true
      });
      
      this.registerProvider({
        id: 'anthropic-claude3',
        name: 'Anthropic Claude 3 Opus',
        provider: LLMProvider.Anthropic,
        modelName: 'claude-3-opus-20240229',
        isBuiltin: true
      });
      
      this.registerProvider({
        id: 'anthropic-claude3-sonnet',
        name: 'Anthropic Claude 3 Sonnet',
        provider: LLMProvider.Anthropic,
        modelName: 'claude-3-sonnet-20240229',
        isBuiltin: true
      });
      
      // Select default provider
      const defaultProvider = Array.from(this.providers.values()).find(p => p.isDefault);
      if (defaultProvider) {
        this.selectProvider(defaultProvider.id);
      } else if (this.providers.size > 0) {
        this.selectProvider(this.providers.values().next().value.id);
      }
      
      this.log(`Initialized ${this.providers.size} LLM providers`);
    } catch (err) {
      this.log(`Error initializing LLM providers: ${err instanceof Error ? err.message : String(err)}`);
      vscode.window.showErrorMessage('Failed to initialize LLM providers');
    }
  }
  
  /**
   * Check if GitHub Copilot is available in the current VS Code instance
   */
  private async checkCopilotAvailability(): Promise<boolean> {
    try {
      const extensions = vscode.extensions.all;
      const copilotExtension = extensions.find(ext => 
        ext.id === 'GitHub.copilot' || 
        ext.id === 'GitHub.copilot-chat'
      );
      
      if (!copilotExtension) {
        return false;
      }
      
      // Try to execute a Copilot command to check if it's active
      try {
        await vscode.commands.executeCommand('github.copilot.generate', { prompt: 'test' });
        return true;
      } catch (e) {
        // The command might fail but still exist
        return true;
      }
    } catch (err) {
      return false;
    }
  }
  
  /**
   * Register a new LLM provider
   */
  registerProvider(provider: LLMProviderConfig): LLMProviderConfig {
    this.providers.set(provider.id, provider);
    this.updateStatusBar();
    
    // If this is the only provider, select it
    if (this.providers.size === 1) {
      this.selectProvider(provider.id);
    }
    
    return provider;
  }
  
  /**
   * Get a provider by ID
   */
  getProvider(id: string): LLMProviderConfig | undefined {
    return this.providers.get(id);
  }
  
  /**
   * Get all registered providers
   */
  getAllProviders(): LLMProviderConfig[] {
    return Array.from(this.providers.values());
  }
  
  /**
   * Get the currently selected provider
   */
  getSelectedProvider(): LLMProviderConfig | undefined {
    return this.selectedProviderId ? this.providers.get(this.selectedProviderId) : undefined;
  }
  
  /**
   * Select a provider by ID
   */
  selectProvider(id: string): boolean {
    const provider = this.providers.get(id);
    if (!provider) {
      this.log(`Provider with id ${id} not found`);
      return false;
    }
    
    this.selectedProviderId = id;
    this.updateStatusBar();
    this.onProviderChangedEmitter.fire(id);
    
    // Update default LM provider in extension settings
    vscode.workspace.getConfiguration('theFuse').update(
      'defaultLmProvider', 
      provider.provider,
      vscode.ConfigurationTarget.Global
    );
    
    this.log(`Selected LLM provider: ${provider.name} (${id})`);
    return true;
  }
  
  /**
   * Remove a provider by ID
   */
  removeProvider(id: string): boolean {
    const provider = this.providers.get(id);
    if (!provider) {
      return false;
    }
    
    // Don't allow removing built-in providers
    if (provider.isBuiltin) {
      vscode.window.showWarningMessage(`Cannot remove built-in provider ${provider.name}`);
      return false;
    }
    
    this.providers.delete(id);
    
    // Update custom providers in storage
    this.saveCustomProviders();
    
    // If the removed provider was selected, select another one
    if (this.selectedProviderId === id) {
      const defaultProvider = Array.from(this.providers.values()).find(p => p.isDefault);
      if (defaultProvider) {
        this.selectProvider(defaultProvider.id);
      } else if (this.providers.size > 0) {
        this.selectProvider(this.providers.values().next().value.id);
      } else {
        this.selectedProviderId = undefined;
      }
    }
    
    this.updateStatusBar();
    return true;
  }
  
  /**
   * Save custom providers to extension storage
   */
  private saveCustomProviders() {
    const customProviders = Array.from(this.providers.values())
      .filter(p => p.isCustom);
    
    this.context.globalState.update('thefuse.customLLMProviders', customProviders);
    this.log(`Saved ${customProviders.length} custom providers to extension storage`);
  }
  
  /**
   * Show quick pick to select a provider
   */
  private async showProviderSelectionQuickPick() {
    const providerItems = Array.from(this.providers.values()).map(provider => ({
      label: provider.name,
      description: provider.isDefault ? '(Default)' : '',
      detail: `Provider: ${provider.provider}, Model: ${provider.modelName}`,
      provider
    }));
    
    const selectedItem = await vscode.window.showQuickPick(providerItems, {
      placeHolder: 'Select LLM Provider',
      title: 'The New Fuse: Select LLM Provider'
    });
    
    if (selectedItem) {
      this.selectProvider(selectedItem.provider.id);
      vscode.window.showInformationMessage(`Selected LLM provider: ${selectedItem.provider.name}`);
    }
  }
  
  /**
   * Show quick pick to add a custom provider
   */
  private async showAddCustomProviderQuickPick() {
    const providerTypes = [
      { label: 'OpenAI', id: LLMProvider.OpenAI },
      { label: 'Anthropic', id: LLMProvider.Anthropic },
      { label: 'Ollama', id: LLMProvider.Ollama },
      { label: 'Custom', id: LLMProvider.Custom }
    ];
    
    const selectedType = await vscode.window.showQuickPick(providerTypes, {
      placeHolder: 'Select Provider Type',
      title: 'The New Fuse: Add Custom LLM Provider'
    });
    
    if (!selectedType) {
      return;
    }
    
    const name = await vscode.window.showInputBox({
      prompt: 'Enter a name for this provider',
      placeHolder: 'e.g. My GPT-4',
      title: 'Provider Name'
    });
    
    if (!name) {
      return;
    }
    
    const apiKey = await vscode.window.showInputBox({
      prompt: 'Enter your API key',
      password: true,
      title: 'API Key'
    });
    
    if (!apiKey) {
      return;
    }
    
    let modelName = '';
    
    if (selectedType.id === LLMProvider.OpenAI) {
      const models = [
        { label: 'GPT-4', id: 'gpt-4' },
        { label: 'GPT-4 Turbo', id: 'gpt-4-turbo' },
        { label: 'GPT-3.5 Turbo', id: 'gpt-3.5-turbo' },
        { label: 'GPT-4o', id: 'gpt-4o' }
      ];
      
      const selectedModel = await vscode.window.showQuickPick(models, {
        placeHolder: 'Select Model',
        title: 'OpenAI Model'
      });
      
      if (!selectedModel) {
        return;
      }
      
      modelName = selectedModel.id;
    } else if (selectedType.id === LLMProvider.Anthropic) {
      const models = [
        { label: 'Claude 3 Opus', id: 'claude-3-opus-20240229' },
        { label: 'Claude 3 Sonnet', id: 'claude-3-sonnet-20240229' },
        { label: 'Claude 3 Haiku', id: 'claude-3-haiku-20240307' }
      ];
      
      const selectedModel = await vscode.window.showQuickPick(models, {
        placeHolder: 'Select Model',
        title: 'Anthropic Model'
      });
      
      if (!selectedModel) {
        return;
      }
      
      modelName = selectedModel.id;
    } else {
      modelName = await vscode.window.showInputBox({
        prompt: 'Enter model name',
        placeHolder: 'e.g. mistral-7b-instruct',
        title: 'Model Name'
      });
      
      if (!modelName) {
        return;
      }
    }
    
    const apiEndpoint = await vscode.window.showInputBox({
      prompt: 'Enter API endpoint (optional)',
      placeHolder: 'e.g. https://api.openai.com/v1',
      title: 'API Endpoint',
      value: selectedType.id === LLMProvider.OpenAI ? 'https://api.openai.com/v1' :
             selectedType.id === LLMProvider.Anthropic ? 'https://api.anthropic.com' : ''
    });
    
    const id = `custom-${Date.now()}`;
    const newProvider: LLMProviderConfig = {
      id,
      name,
      provider: selectedType.id,
      modelName,
      apiKey,
      apiEndpoint: apiEndpoint || undefined,
      isCustom: true,
      isBuiltin: false
    };
    
    this.registerProvider(newProvider);
    this.saveCustomProviders();
    
    // Set as selected provider
    this.selectProvider(id);
    
    vscode.window.showInformationMessage(`Added custom provider: ${name}`);
  }
  
  /**
   * Show quick pick to manage providers
   */
  private async showManageProvidersQuickPick() {
    const providers = this.getAllProviders();
    const items = providers.map(provider => ({
      label: provider.name,
      description: provider.isDefault ? '(Default)' : 
                   provider.isBuiltin ? '(Built-in)' : 
                   provider.isCustom ? '(Custom)' : '',
      provider
    }));
    
    items.push({ 
      label: '+ Add Custom Provider', 
      description: '',
      provider: { id: 'add-new', name: '', provider: '' as LLMProvider, modelName: '' }
    });
    
    const selectedItem = await vscode.window.showQuickPick(items, {
      placeHolder: 'Manage LLM Providers',
      title: 'The New Fuse: Manage LLM Providers'
    });
    
    if (!selectedItem) {
      return;
    }
    
    if (selectedItem.provider.id === 'add-new') {
      this.showAddCustomProviderQuickPick();
      return;
    }
    
    const options = [
      { label: 'Select', id: 'select' },
      { label: 'Set as Default', id: 'default' }
    ];
    
    if (selectedItem.provider.isCustom) {
      options.push({ label: 'Delete', id: 'delete' });
    }
    
    const action = await vscode.window.showQuickPick(options, {
      placeHolder: `Action for ${selectedItem.provider.name}`,
      title: 'Select Action'
    });
    
    if (!action) {
      return;
    }
    
    switch (action.id) {
      case 'select':
        this.selectProvider(selectedItem.provider.id);
        vscode.window.showInformationMessage(`Selected provider: ${selectedItem.provider.name}`);
        break;
      case 'default':
        // Update all providers to remove default flag
        for (const provider of providers) {
          provider.isDefault = false;
        }
        // Set the selected provider as default
        selectedItem.provider.isDefault = true;
        this.saveCustomProviders();
        this.updateStatusBar();
        vscode.window.showInformationMessage(`Set ${selectedItem.provider.name} as default provider`);
        break;
      case 'delete':
        this.removeProvider(selectedItem.provider.id);
        vscode.window.showInformationMessage(`Removed provider: ${selectedItem.provider.name}`);
        break;
    }
  }
  
  /**
   * Update the status bar item
   */
  private updateStatusBar() {
    const selectedProvider = this.getSelectedProvider();
    if (selectedProvider) {
      this.statusBarItem.text = `$(hubot) ${selectedProvider.name}`;
    } else {
      this.statusBarItem.text = '$(hubot) Select LLM';
    }
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    this.outputChannel.appendLine(`[LLMProviderManager] ${message}`);
  }
  
  /**
   * Generate text with the currently selected provider
   */
  async generateText(prompt: string, options: any = {}): Promise<any> {
    const provider = this.getSelectedProvider();
    if (!provider) {
      throw new Error('No provider selected');
    }
    
    // Implement the text generation logic based on provider type
    this.log(`Generating text with provider: ${provider.name}`);
    
    try {
      let response;
      
      switch (provider.provider) {
        case LLMProvider.OpenAI:
          response = await this.generateOpenAIText(provider, prompt, options);
          break;
        case LLMProvider.Anthropic:
          response = await this.generateAnthropicText(provider, prompt, options);
          break;
        case LLMProvider.Copilot:
          response = await this.generateCopilotText(provider, prompt, options);
          break;
        default:
          throw new Error(`Unsupported provider type: ${provider.provider}`);
      }
      
      return response;
    } catch (error) {
      this.log(`Error generating text: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * Generate a chat completion with the currently selected provider
   */
  async generateChatCompletion(messages: any[], options: any = {}): Promise<any> {
    const provider = this.getSelectedProvider();
    if (!provider) {
      throw new Error('No provider selected');
    }
    
    this.log(`Generating chat completion with provider: ${provider.name}`);
    
    try {
      let response;
      
      switch (provider.provider) {
        case LLMProvider.OpenAI:
          response = await this.generateOpenAIChatCompletion(provider, messages, options);
          break;
        case LLMProvider.Anthropic:
          response = await this.generateAnthropicChatCompletion(provider, messages, options);
          break;
        case LLMProvider.Copilot:
          // Convert chat messages to a prompt for Copilot
          const prompt = this.convertMessagesToPrompt(messages);
          response = await this.generateCopilotText(provider, prompt, options);
          break;
        default:
          throw new Error(`Unsupported provider type: ${provider.provider}`);
      }
      
      return response;
    } catch (error) {
      this.log(`Error generating chat completion: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * Generate code with the currently selected provider
   */
  async generateCode(prompt: string, language: string, options: any = {}): Promise<any> {
    const provider = this.getSelectedProvider();
    if (!provider) {
      throw new Error('No provider selected');
    }
    
    this.log(`Generating code in ${language} with provider: ${provider.name}`);
    
    // Enhance the prompt with language information
    const enhancedPrompt = `Generate ${language} code for: ${prompt}\nOnly respond with valid ${language} code without explanations.`;
    
    // Use the appropriate generation method based on provider type
    try {
      let response;
      
      switch (provider.provider) {
        case LLMProvider.OpenAI:
          response = await this.generateOpenAIText(provider, enhancedPrompt, {
            ...options,
            systemPrompt: `You are an expert ${language} developer. Generate only valid ${language} code without explanations.`
          });
          break;
        case LLMProvider.Anthropic:
          response = await this.generateAnthropicText(provider, enhancedPrompt, {
            ...options,
            systemPrompt: `You are an expert ${language} developer. Generate only valid ${language} code without explanations.`
          });
          break;
        case LLMProvider.Copilot:
          response = await this.generateCopilotText(provider, enhancedPrompt, options);
          break;
        default:
          throw new Error(`Unsupported provider type: ${provider.provider}`);
      }
      
      return response;
    } catch (error) {
      this.log(`Error generating code: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * Helper: Convert chat messages to a prompt string
   */
  private convertMessagesToPrompt(messages: any[]): string {
    return messages.map(msg => {
      const role = msg.role.charAt(0).toUpperCase() + msg.role.slice(1);
      return `${role}: ${msg.content}`;
    }).join('\n\n');
  }
  
  /**
   * Helper: Generate text with OpenAI
   */
  private async generateOpenAIText(provider: LLMProviderConfig, prompt: string, options: any): Promise<any> {
    // Implementation would call the OpenAI API
    // This is a placeholder that would be implemented with actual API calls
    this.log(`OpenAI text generation with model: ${provider.modelName}`);
    
    // For now, return mock response
    return {
      text: `[OpenAI ${provider.modelName} would generate a response to: "${prompt.substring(0, 50)}..."]`,
      provider: 'openai',
      model: provider.modelName
    };
  }
  
  /**
   * Helper: Generate chat completion with OpenAI
   */
  private async generateOpenAIChatCompletion(provider: LLMProviderConfig, messages: any[], options: any): Promise<any> {
    // Implementation would call the OpenAI Chat API
    this.log(`OpenAI chat completion with model: ${provider.modelName}`);
    
    // For now, return mock response
    return {
      text: `[OpenAI ${provider.modelName} would generate a chat response to the provided messages]`,
      provider: 'openai',
      model: provider.modelName
    };
  }
  
  /**
   * Helper: Generate text with Anthropic
   */
  private async generateAnthropicText(provider: LLMProviderConfig, prompt: string, options: any): Promise<any> {
    // Implementation would call the Anthropic API
    this.log(`Anthropic text generation with model: ${provider.modelName}`);
    
    // For now, return mock response
    return {
      text: `[Anthropic ${provider.modelName} would generate a response to: "${prompt.substring(0, 50)}..."]`,
      provider: 'anthropic',
      model: provider.modelName
    };
  }
  
  /**
   * Helper: Generate chat completion with Anthropic
   */
  private async generateAnthropicChatCompletion(provider: LLMProviderConfig, messages: any[], options: any): Promise<any> {
    // Implementation would call the Anthropic API with messages
    this.log(`Anthropic chat completion with model: ${provider.modelName}`);
    
    // For now, return mock response
    return {
      text: `[Anthropic ${provider.modelName} would generate a chat response to the provided messages]`,
      provider: 'anthropic',
      model: provider.modelName
    };
  }
  
  /**
   * Helper: Generate text with GitHub Copilot
   */
  private async generateCopilotText(provider: LLMProviderConfig, prompt: string, options: any): Promise<any> {
    // Attempt to use the Copilot extension's API
    this.log(`Copilot text generation`);
    
    try {
      // Try to call VS Code Copilot extension
      const result = await vscode.commands.executeCommand('github.copilot.generate', { 
        prompt,
        temperature: options.temperature,
        maxTokens: options.maxTokens
      });
      
      return {
        text: result?.text || `[GitHub Copilot would generate a response to: "${prompt.substring(0, 50)}..."]`,
        provider: 'github-copilot',
        model: 'copilot'
      };
    } catch (error) {
      this.log(`Error calling Copilot API: ${error instanceof Error ? error.message : String(error)}`);
      
      // Fall back to a mock response
      return {
        text: `[GitHub Copilot would generate a response to: "${prompt.substring(0, 50)}..."]`,
        provider: 'github-copilot',
        model: 'copilot'
      };
    }
  }
}

/**
 * Create an LLM Provider Manager
 */
export function createLLMProviderManager(
  context: vscode.ExtensionContext,
  outputChannel: vscode.OutputChannel
): LLMProviderManager {
  return new LLMProviderManager(context, outputChannel);
}


==============================================
FILE: ./src/vscode-extension/lm-api-bridge-simple.tsx
==============================================

/**
 * Simplified LM API Bridge
 */

import * as vscode from 'vscode';
import { AgentClient } from './agent-communication-simple';

export interface LMRequestParams {
  prompt: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
}

export interface LMResponse {
  text: string;
  provider: string;
}

export class LMAPIBridge {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient) {
    this.context = context;
    this.agentClient = agentClient;
  }
  
  // Generate text using a mock LM response
  async generateText(params: LMRequestParams): Promise<LMResponse> {
    // For quick testing, just return a mock response
    const response = `Here's a response to: "${params.prompt.substring(0, 50)}..."
    
This is a simulated response since we don't have a real language model API connection.
Temperature: ${params.temperature || 0.7}
Max Tokens: ${params.maxTokens || 100}

You can replace this with actual API calls in a production version.`;
    
    return {
      text: response,
      provider: 'mock-provider'
    };
  }
}

// Export factory function
export function createLMAPIBridge(context: vscode.ExtensionContext, agentClient: AgentClient): LMAPIBridge {
  return new LMAPIBridge(context, agentClient);
}



==============================================
FILE: ./src/vscode-extension/lm-api-bridge.ts
==============================================

import * as vscode from 'vscode';
import fetch from 'node-fetch'; // Import node-fetch

// Simple interface for language model API responses
export interface LMResponse {
  text: string;
  toolCalls?: Array<{
    name: string;
    parameters: any;
  }>;
}

/**
 * Enum for LLM providers
 */
export enum LLMProvider {
  VSCode = 'vscode',
  OpenAI = 'openai',
  Anthropic = 'anthropic',
  Ollama = 'ollama',
  Custom = 'custom'
}

/**
 * Interface for LLM configuration
 */
export interface LLMConfig {
  provider: LLMProvider;
  model: string;
  apiKey?: string;
  endpoint?: string;
}

/**
 * LM API Bridge class for The New Fuse
 */
export class LMAPIBridge {
  private outputChannel: vscode.OutputChannel;
  private context: vscode.ExtensionContext;
  
  constructor(context: vscode.ExtensionContext) {
    this.context = context;
    this.outputChannel = vscode.window.createOutputChannel('The New Fuse LM API');
    
    // Register configuration change listener to update LLM settings
    context.subscriptions.push(
      vscode.workspace.onDidChangeConfiguration(e => {
        if (e.affectsConfiguration('theFuse.llmProvider') || 
            e.affectsConfiguration('theFuse.vscodeModel') ||
            e.affectsConfiguration('theFuse.openAIModel') ||
            e.affectsConfiguration('theFuse.anthropicModel') ||
            e.affectsConfiguration('theFuse.ollamaModel') ||
            e.affectsConfiguration('theFuse.customModelEndpoint')) {
          this.outputChannel.appendLine('LLM configuration changed, updating settings.');
        }
      })
    );
  }

  /**
   * Get current LLM configuration from settings
   */
  getLLMConfig(): LLMConfig {
    const config = vscode.workspace.getConfiguration('theFuse');
    const provider = config.get<LLMProvider>('llmProvider', LLMProvider.VSCode);
    
    let model = '';
    switch (provider) {
      case LLMProvider.VSCode:
        model = config.get<string>('vscodeModel', 'copilot-chat.completion-gpt-4');
        break;
      case LLMProvider.OpenAI:
        model = config.get<string>('openAIModel', 'gpt-4');
        break;
      case LLMProvider.Anthropic:
        model = config.get<string>('anthropicModel', 'claude-3-opus');
        break;
      case LLMProvider.Ollama:
        model = config.get<string>('ollamaModel', 'codellama');
        break;
      case LLMProvider.Custom:
        model = 'custom';
        break;
    }

    const llmConfig: LLMConfig = {
      provider,
      model,
    };

    if (provider === LLMProvider.Custom) {
      llmConfig.endpoint = config.get<string>('customModelEndpoint', '');
      llmConfig.apiKey = config.get<string>('customModelAPIKey', '');
    }

    return llmConfig;
  }

  /**
   * Calls a language model with the given prompt
   */
  async callLM(prompt: string, options: any = {}): Promise<LMResponse> {
    const llmConfig = this.getLLMConfig();
    this.outputChannel.appendLine(`Sending prompt to ${llmConfig.provider} (${llmConfig.model}): ${prompt.substring(0, 100)}...`);
    
    try {
      let response: LMResponse;
      // NOTE: This simple "callLM" is primarily for non-agentic, single-prompt calls.
      // Agentic calls should use "callAgentLM" which handles message history and tools.
      // For simplicity here, we'll wrap the prompt in a basic message structure.
      const messages = [{ role: 'user', content: prompt }];
      // Extract tools from options if provided for providers that support them in this context
      const tools = options?.tools;

      switch (llmConfig.provider) {
        case LLMProvider.VSCode:
          // VSCode LM doesn't handle structured messages well here, pass raw prompt
          response = await this.callVSCodeLM(prompt, llmConfig.model, options);
          break;
        case LLMProvider.OpenAI:
          response = await this.callOpenAILM(messages, llmConfig.model, tools);
          break;
        case LLMProvider.Anthropic:
          response = await this.callAnthropicLM(messages, llmConfig.model, tools);
          break;
        case LLMProvider.Ollama:
          response = await this.callOllamaLM(messages, llmConfig.model, tools);
          break;
        case LLMProvider.Custom:
           response = await this.callCustomLM(messages, llmConfig.endpoint || '', llmConfig.apiKey, tools);
          break;
        default:
          response = await this.simulateResponse(prompt);
          break;
      }
      return response;
    } catch (error: any) {
      this.outputChannel.appendLine(`Error calling LM API: ${error}`);
      // Return an error response object
      return {
        text: `I encountered an error while processing your request. Please check the extension settings and try again. Error: ${error.message}`,
        toolCalls: []
      };
    }
  }

  /**
   * Call VS Code LM API
   */
  private async callVSCodeLM(prompt: string, model: string, options: any = {}): Promise<LMResponse> {
    try {
      // Check if VS Code LM API is available
      // @ts-ignore (The LM API might not be in the types yet)
      if (!vscode.languageModels) {
        this.outputChannel.appendLine('VS Code LM API not available. Make sure you have VS Code 1.85+ and GitHub Copilot installed.');
        return this.simulateResponse(prompt);
      }

      // Select the model from the dropdown setting
      // @ts-ignore
      const lmModel = vscode.languageModels.getLanguageModel(model);
      
      let selectedModel = lmModel;
      if (!selectedModel) {
        this.outputChannel.appendLine(`Selected VS Code LM model "${model}" not found. Falling back to default.`);
        // @ts-ignore
        selectedModel = vscode.languageModels.getLanguageModel('copilot-chat.completion-gpt-4');
        if (!selectedModel) {
          throw new Error('VS Code LM API models not available');
        }
      }
      
      // TODO: Adapt this when VS Code LM API supports tool calling officially
      // For now, assume it only returns text
      // @ts-ignore
      const resultText = await selectedModel.generateText(prompt);
      this.outputChannel.appendLine("Received response from VS Code LM API");
      return { text: resultText, toolCalls: [] }; // Return LMResponse
    } catch (error: any) {
      this.outputChannel.appendLine(`Error calling VS Code LM API: ${error}`);
      // Fall back to simulation if VS Code LM API fails
      return this.simulateResponse(prompt);
    }
  }

  /**
   * Call OpenAI API
   */
  private async callOpenAILM(messages: any[], model: string, tools?: any[]): Promise<LMResponse> {
    const config = vscode.workspace.getConfiguration('theFuse');
    // IMPORTANT: User needs to configure 'theFuse.openAIAPIKey' in VS Code settings
    const apiKey = config.get<string>('openAIAPIKey'); 
    const endpoint = 'https://api.openai.com/v1/chat/completions'; // Standard endpoint

    if (!apiKey) {
      throw new Error('OpenAI API Key not configured. Please set theFuse.openAIAPIKey in your VS Code settings.');
    }

    this.outputChannel.appendLine(`Calling OpenAI API (${model})`);

    const body: any = {
      model: model,
      messages: messages,
    };

    if (tools && tools.length > 0) {
      // Format tools for OpenAI API (functions)
      body.tools = tools.map(t => ({ type: 'function', function: t })); 
      body.tool_choice = 'auto'; // Let the model decide if it needs to call a tool
    }

    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
        },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`OpenAI API error: ${response.status} ${response.statusText} - ${errorBody}`);
      }

      const data = await response.json() as any;
      const choice = data.choices[0];
      const message = choice.message;

      // Parse tool calls if present in the response
      const toolCalls = message.tool_calls?.map((tc: any) => ({
        id: tc.id, // Include the ID for referencing in the subsequent call
        name: tc.function.name,
        parameters: JSON.parse(tc.function.arguments), // Arguments are a JSON string
      })) || [];

      return {
        text: message.content || '', // Text response might be null if only tool calls are made
        toolCalls: toolCalls,
      };
    } catch (error: any) {
      this.outputChannel.appendLine(`Error calling OpenAI API: ${error.message}`);
      throw error; // Re-throw to be caught by the main callAgentLM function
    }
  }

  /**
   * Call Anthropic API
   */
  private async callAnthropicLM(messages: any[], model: string, tools?: any[]): Promise<LMResponse> {
    const config = vscode.workspace.getConfiguration('theFuse');
    // IMPORTANT: User needs to configure 'theFuse.anthropicAPIKey' in VS Code settings
    const apiKey = config.get<string>('anthropicAPIKey'); 
    const endpoint = 'https://api.anthropic.com/v1/messages';

    if (!apiKey) {
      throw new Error('Anthropic API Key not configured. Please set theFuse.anthropicAPIKey in your VS Code settings.');
    }

    this.outputChannel.appendLine(`Calling Anthropic API (${model})`);

    // Separate system prompt and format messages for Anthropic
    let systemPrompt = '';
    const formattedMessages = messages.filter(msg => {
        if (msg.role === 'system') {
            systemPrompt = msg.content;
            return false; // Remove system message from main list
        }
        // Map tool results to the expected 'tool_result' role
        if (msg.role === 'tool') {
            return {
                role: 'user', // Anthropic expects tool results within a 'user' message
                content: [
                    {
                        type: 'tool_result',
                        tool_use_id: msg.toolCallId, // Use the ID from the initial tool_use request
                        content: msg.content // The result content (should be stringified JSON)
                    }
                ]
            };
        }
        return true;
    }).map(msg => {
        // Ensure assistant messages with tool calls are formatted correctly
        if (msg.role === 'assistant' && msg.toolCalls && msg.toolCalls.length > 0) {
            return {
                role: 'assistant',
                content: msg.toolCalls.map((tc: any) => ({
                    type: 'tool_use',
                    id: tc.id,
                    name: tc.name,
                    input: tc.parameters
                }))
                // Include text content if the assistant also provided text
                // Note: Anthropic's API might prefer separate text blocks
                // .concat(msg.content ? [{ type: 'text', text: msg.content }] : [])
            };
        }
        return msg; // Keep user messages and simple assistant messages as is
    });

    const body: any = {
      model: model,
      messages: formattedMessages,
      max_tokens: 4096, // Default max tokens, consider making configurable
    };

    if (systemPrompt) {
        body.system = systemPrompt;
    }

    if (tools && tools.length > 0) {
      // Format tools for Anthropic
      body.tools = tools.map(t => ({ 
          name: t.name,
          description: t.description,
          input_schema: t.parameters // Anthropic uses 'input_schema'
      }));
    }

    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01', // Required header
          'anthropic-beta': 'tools-2024-04-04' // Required for tools beta
        },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`Anthropic API error: ${response.status} ${response.statusText} - ${errorBody}`);
      }

      const data = await response.json() as any;
      
      let responseText = '';
      const toolCalls: any[] = [];

      // Process content blocks from the response
      data.content.forEach((block: any) => {
          if (block.type === 'text') {
              responseText += block.text;
          } else if (block.type === 'tool_use') {
              // Parse tool use requests from the model
              toolCalls.push({
                  id: block.id, // Include the ID for the tool result message
                  name: block.name,
                  parameters: block.input // Anthropic uses 'input'
              });
          }
      });

      return {
        text: responseText,
        toolCalls: toolCalls,
      };
    } catch (error: any) {
      this.outputChannel.appendLine(`Error calling Anthropic API: ${error.message}`);
      throw error;
    }
  }

  /**
   * Call Ollama API
   */
  private async callOllamaLM(messages: any[], model: string, tools?: any[]): Promise<LMResponse> {
    const config = vscode.workspace.getConfiguration('theFuse');
    // IMPORTANT: User needs to configure 'theFuse.ollamaEndpoint' if not default
    const endpoint = config.get<string>('ollamaEndpoint', 'http://localhost:11434/api/chat'); 

    this.outputChannel.appendLine(`Calling Ollama API (${model}) at ${endpoint}`);

    // Ollama's tool support is highly model-dependent and often relies on specific prompting
    // or external libraries like LangChain/LlamaIndex. This is a basic chat completion call.
    // Tool definitions might need to be injected into the system prompt.
    const body: any = {
      model: model,
      messages: messages.filter(m => m.role !== 'tool'), // Filter out tool results for basic chat
      stream: false, // Request full response
    };

    if (tools && tools.length > 0) {
        this.outputChannel.appendLine('Warning: Ollama tool support via this bridge is basic. Tools are defined but may not be used effectively by the model without specific prompting or a supporting library.');
        // Optionally, inject tool definitions into the system prompt if one exists
        const systemMsgIndex = messages.findIndex(m => m.role === 'system');
        const toolDescriptions = tools.map(t => `- ${t.name}: ${t.description} (Parameters: ${JSON.stringify(t.parameters)})`).join('\n');
        const toolPrompt = `\n\nYou have the following tools available:\n${toolDescriptions}\nRespond in JSON format if you need to use a tool, e.g., { "tool_name": "...`;
        if (systemMsgIndex !== -1) {
            // Inject before the first system message
            messages.splice(systemMsgIndex, 0, { role: 'system', content: toolPrompt });
        } else {
            // Otherwise, just prepend to messages
            messages.unshift({ role: 'system', content: toolPrompt });
        }
    }

    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`Ollama API error: ${response.status} ${response.statusText} - ${errorBody}`);
      }

      const data = await response.json() as any;

      // --- Adapt Response Parsing based on Ollama API --- 
      // This is a generic example. Modify based on your API's response structure.
      const responseText = data.text || data.response?.content || data.choices?.[0]?.message?.content || '';
      // Example: Parse tool calls if your API returns them in a specific format
      const toolCalls = data.tool_calls?.map((tc: any) => ({
          id: tc.id || `ollama-tool-${Date.now()}`, // Use ID if provided, else generate
          name: tc.function?.name || tc.name,
          parameters: typeof tc.function?.arguments === 'string' ? JSON.parse(tc.function.arguments) : (tc.parameters || tc.input)
      })) || [];
      // ------------------------------------------------

      return {
        text: responseText,
        toolCalls: toolCalls,
      };
    } catch (error: any) {
      this.outputChannel.appendLine(`Error calling Ollama API: ${error.message}`);
      throw error;
    }
  }

  /**
   * Call Custom LM API
   */
  private async callCustomLM(messages: any[], endpoint: string, apiKey?: string, tools?: any[]): Promise<LMResponse> {
    this.outputChannel.appendLine(`Calling Custom LM API at endpoint: ${endpoint}`);
    // IMPORTANT: User needs to configure 'theFuse.customModelEndpoint' and potentially 'theFuse.customModelAPIKey'

    if (!endpoint) {
        throw new Error('Custom LM API endpoint not configured. Please set theFuse.customModelEndpoint.');
    }

    // --- Adapt Request Body based on Custom API --- 
    // This is a generic example. You MUST modify this section based on 
    // how your specific custom API expects messages and tools.
    const body: any = {
        model: 'custom-model', // Or get from config if applicable
        messages: messages, 
        // Example: Maybe your API expects tools differently
        // tools: tools ? tools.map(t => ({ name: t.name, schema: t.parameters })) : undefined,
        // tool_choice: tools ? 'auto' : undefined,
        // max_tokens: 4096,
    };
    // Add tool definitions if your custom API expects them
    if (tools && tools.length > 0) {
        body.tools = tools; // Adjust formatting as needed by your API
        body.tool_choice = 'auto'; // Adjust as needed
        this.outputChannel.appendLine('Sending tools to custom endpoint (format might need adjustment).');
    }
    // -----------------------------------------------

    const headers: any = {
      'Content-Type': 'application/json',
    };
    if (apiKey) {
      // Add authentication header (e.g., Bearer token, custom header)
      // Modify this based on your API's requirements
      headers['Authorization'] = `Bearer ${apiKey}`; 
      // Or headers['X-API-Key'] = apiKey;
    }

    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(body),
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`Custom LM API error: ${response.status} ${response.statusText} - ${errorBody}`);
      }

      const data = await response.json() as any;

      // --- Adapt Response Parsing based on Custom API --- 
      // This is a generic example. Modify based on your API's response structure.
      const responseText = data.text || data.response?.content || data.choices?.[0]?.message?.content || '';
      // Example: Parse tool calls if your API returns them in a specific format
      const toolCalls = data.tool_calls?.map((tc: any) => ({
          id: tc.id || `custom-tool-${Date.now()}`, // Use ID if provided, else generate
          name: tc.function?.name || tc.name,
          parameters: typeof tc.function?.arguments === 'string' ? JSON.parse(tc.function.arguments) : (tc.parameters || tc.input)
      })) || [];
      // ------------------------------------------------

      return {
        text: responseText,
        toolCalls: toolCalls,
      };
    } catch (error: any) {
      this.outputChannel.appendLine(`Error calling Custom LM API: ${error.message}`);
      throw error;
    }
  }

  /**
   * Simulate an LM response (used as fallback or for testing)
   */
  private async simulateResponse(promptOrMessages: string | any[]): Promise<LMResponse> {
    const config = this.getLLMConfig();
    const inputText = typeof promptOrMessages === 'string' ? promptOrMessages : JSON.stringify(promptOrMessages);
    this.outputChannel.appendLine(`Simulating LM response for ${config.provider}...`);
    await new Promise(resolve => setTimeout(resolve, 300)); // Simulate delay
    
    // Basic simulation, doesn't actually process messages or tools
    return {
      text: `This is a **simulated** response from the ${config.provider} provider for your request: "${inputText.substring(0, 150)}...". Implement the actual API call for real results.`,
      toolCalls: [] // Simulate no tool calls by default
    };
  }

  /**
   * Generate text using the selected LLM provider.
   * This is a convenience method that wraps callLM and extracts text.
   * Consider using callLM directly if you need tool call information.
   */
  async generateText(options: { prompt: string; systemPrompt?: string; }): Promise<LMResponse> {
    // TODO: Incorporate systemPrompt if the underlying API supports it
    // For now, just use the main prompt
    return this.callLM(options.prompt);
  }

  /**
   * Calls the agent-specific language model endpoint.
   * This handles routing to the correct provider and formatting messages/tools.
   */
  async callAgentLM(messages: any[], tools?: any[]): Promise<LMResponse> {
    const llmConfig = this.getLLMConfig();
    this.outputChannel.appendLine(`Routing agent request to ${llmConfig.provider} (${llmConfig.model}) with ${tools?.length || 0} tools.`);
    // Avoid logging potentially sensitive API keys or large message bodies
    // this.outputChannel.appendLine("Messages: ${JSON.stringify(messages, null, 2)}"); 
    // if (tools) { this.outputChannel.appendLine("Tools: ${JSON.stringify(tools, null, 2)}"); }

    try {
      switch (llmConfig.provider) {
        case LLMProvider.OpenAI:
          return await this.callOpenAILM(messages, llmConfig.model, tools);
        case LLMProvider.Anthropic:
          return await this.callAnthropicLM(messages, llmConfig.model, tools);
        case LLMProvider.Ollama:
          return await this.callOllamaLM(messages, llmConfig.model, tools);
        case LLMProvider.Custom:
          return await this.callCustomLM(messages, llmConfig.endpoint || '', llmConfig.apiKey, tools);
        case LLMProvider.VSCode:
          // VSCode LM API currently lacks robust support for structured chat history and tools.
          // Concatenate messages into a single prompt as a basic workaround.
          this.outputChannel.appendLine('Warning: VS Code LM provider has limited support for agentic chat history and tools. Concatenating messages.');
          const prompt = messages.map(m => {
              let content = `${m.role}: ${m.content}`;
              if (m.role === 'assistant' && m.toolCalls && m.toolCalls.length > 0) {
                  content += `\nRequested Tools: ${JSON.stringify(m.toolCalls)}`;
              }
              if (m.role === 'tool') {
                  content = `Tool Result (ID: ${m.toolCallId}, Name: ${m.name}): ${m.content}`;
              }
              return content;
          }).join('\n\n');
          // Include tool definitions in the prompt for VSCode LM
          let toolPrompt = '';
          if (tools && tools.length > 0) {
              const toolDescriptions = tools.map(t => `- ${t.name}: ${t.description} (Parameters: ${JSON.stringify(t.parameters)})`).join('\n');
              toolPrompt = `\n\nYou have the following tools available:\n${toolDescriptions}\nRespond in JSON format if you need to use a tool, e.g., { "tool_name": "...`;
          }
          // Pass tools in options, though the underlying call might not use them effectively yet
          return await this.callVSCodeLM(prompt + toolPrompt, llmConfig.model, { tools }); 
        default:
          this.outputChannel.appendLine(`Unsupported provider for agent call: ${llmConfig.provider}. Simulating.`);
          return this.simulateResponse(messages); // Simulate based on messages
      }
    } catch (error: any) {
      this.outputChannel.appendLine(`Error during agent LM call (${llmConfig.provider}): ${error.message}`);
      // Provide a user-friendly error message in the response
      return {
        text: `Sorry, I encountered an error communicating with the ${llmConfig.provider} API: ${error.message}. Please check your API key and endpoint settings in VS Code.`,
        toolCalls: []
      };
    }
  }
}

// Note: The extractToolCalls method was removed as parsing is now handled within each provider's call method.

/**
 * Factory function to create and expose the LMAPIBridge instance.
 */
export function createLMAPIBridge(context: vscode.ExtensionContext): LMAPIBridge {
  return new LMAPIBridge(context);
}


==============================================
FILE: ./src/vscode-extension/lm-api-bridge.tsx
==============================================

import * as vscode from 'vscode';
import { AgentClient } from './agent-communication';
import { LLMProviderManager, LLMProviderConfig } from './llm-provider-manager';

/**
 * Interface for language model request parameters
 */
export interface LMRequestParams {
  prompt: string;
  model?: string;
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
  stopSequences?: string[];
  options?: Record<string, any>;
  llmProviderId?: string; // New field to explicitly specify a provider
}

/**
 * Interface for a language model response
 */
export interface LMResponse {
  text: string;
  provider: string;
  model?: string;
  usage?: {
    promptTokens?: number;
    completionTokens?: number;
    totalTokens?: number;
  };
  metadata?: Record<string, any>;
}

/**
 * Language model API providers
 */
export enum LMProvider {
  Mock = 'mock',
  Copilot = 'copilot',
  Anthropic = 'anthropic',
  OpenAI = 'openai',
  HuggingFace = 'huggingface',
  Local = 'local'
}

/**
 * Bridge for language model integrations
 * 
 * This class provides a unified interface to various language model APIs
 */
export class LMAPIBridge {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private outputChannel: vscode.OutputChannel;
  private providerManager: LLMProviderManager;
  
  constructor(
    context: vscode.ExtensionContext, 
    agentClient: AgentClient, 
    providerManager: LLMProviderManager,
    outputChannel?: vscode.OutputChannel
  ) {
    this.context = context;
    this.agentClient = agentClient;
    this.providerManager = providerManager;
    this.outputChannel = outputChannel || vscode.window.createOutputChannel('LM API Bridge');
    
    // Register as an agent
    this.agentClient.register('LM API Bridge', ['text-generation', 'lm-api'], '1.0.0')
      .then(() => {
        this.log('Registered as agent');
      })
      .catch(err => {
        this.log(`Error registering agent: ${err.message}`);
      });
    
    // Subscribe to relevant messages
    this.agentClient.subscribe(this.handleMessage.bind(this));
    
    // Register commands
    this.registerCommands();
    
    // Listen for provider changes
    this.providerManager.onProviderChanged((providerId) => {
      const provider = this.providerManager.getProvider(providerId);
      if (provider) {
        this.log(`LLM provider changed to: ${provider.name}`);
      }
    });
    
    this.log('LM API Bridge initialized');
  }
  
  /**
   * Register commands
   */
  private registerCommands() {
    // Register a command to generate text
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.lm.generate', async (params: LMRequestParams) => {
        return this.generateText(params);
      })
    );
  }
  
  /**
   * Handle incoming messages
   */
  private async handleMessage(message: any): Promise<void> {
    if (message.action === 'lm.generate') {
      try {
        const result = await this.generateText(message.payload);
        await this.agentClient.sendMessage(message.sender, 'lm.generateResponse', {
          requestId: message.payload.requestId,
          result
        });
      } catch (error) {
        await this.agentClient.sendMessage(message.sender, 'lm.generateResponse', {
          requestId: message.payload.requestId,
          error: error.message
        });
      }
    }
  }
  
  /**
   * Generate text using the specified or default language model
   */
  async generateText(params: LMRequestParams): Promise<LMResponse> {
    let provider: LLMProviderConfig | undefined;
    
    if (params.llmProviderId) {
      // If a specific provider ID is specified, use it
      provider = this.providerManager.getProvider(params.llmProviderId);
      if (!provider) {
        this.log(`Provider with ID ${params.llmProviderId} not found, using default`);
      }
    }
    
    // If no provider was found by ID (or none specified), use the currently selected provider
    if (!provider) {
      provider = this.providerManager.getSelectedProvider();
    }
    
    // If we still don't have a provider, use mock provider
    if (!provider) {
      this.log('No provider available, using mock provider');
      return this.generateWithMockProvider(params);
    }
    
    this.log(`Generating text using provider: ${provider.name} (${provider.provider})`);
    
    try {
      switch (provider.provider) {
        case LMProvider.Copilot:
          return await this.generateWithCopilot(params, provider);
          
        case LMProvider.Anthropic:
          return await this.generateWithAnthropic(params, provider);
          
        case LMProvider.OpenAI:
          return await this.generateWithOpenAI(params, provider);
          
        case LMProvider.HuggingFace:
          return await this.generateWithHuggingFace(params, provider);
          
        case LMProvider.Local:
          return await this.generateWithLocalModel(params, provider);
          
        case LMProvider.Mock:
        default:
          return this.generateWithMockProvider(params);
      }
    } catch (error) {
      this.log(`Error generating text: ${error instanceof Error ? error.message : String(error)}`);
      
      // Fall back to mock provider on error
      return this.generateWithMockProvider(params);
    }
  }
  
  /**
   * Generate text using GitHub Copilot
   */
  private async generateWithCopilot(
    params: LMRequestParams, 
    provider: LLMProviderConfig
  ): Promise<LMResponse> {
    // Check if Copilot is available
    const copilotExtension = vscode.extensions.all.find(ext => 
      ext.id === 'GitHub.copilot' || 
      ext.id === 'GitHub.copilot-chat'
    );
    
    if (!copilotExtension) {
      throw new Error('GitHub Copilot extension is not installed or not active');
    }
    
    try {
      // Try to use VS Code's built-in Copilot API
      const vscodeApiVersion = parseInt(process.versions.vscode.split('.')[0], 10);
      
      // VS Code 1.85+ (stable as of December 2023) supports built-in Copilot API
      if (vscodeApiVersion >= 1.85) {
        this.log('Using VS Code native Copilot API');
        
        // If github.copilot.generate command exists (VS Code 1.85+)
        try {
          // Try the GitHub Copilot extension - this might change with future versions
          const result = await vscode.commands.executeCommand('github.copilot.generate', {
            prompt: params.prompt,
            temperature: params.temperature,
            maxTokens: params.maxTokens,
            systemPrompt: params.systemPrompt,
            stopSequences: params.stopSequences
          });
          
          if (result && typeof result === 'string') {
            return {
              text: result,
              provider: 'copilot',
              model: 'github-copilot'
            };
          }
        } catch (e) {
          this.log(`Error with github.copilot.generate: ${e instanceof Error ? e.message : String(e)}`);
        }
      }
      
      // Fall back to the chat-based approach
      try {
        this.log('Falling back to Copilot Chat API');
        
        const chatMessage = params.systemPrompt 
          ? `${params.systemPrompt}\n\n${params.prompt}`
          : params.prompt;
          
        const chatResult = await vscode.commands.executeCommand('github.copilot.chat', chatMessage);
        
        if (chatResult && typeof chatResult === 'string') {
          return {
            text: chatResult,
            provider: 'copilot',
            model: 'github-copilot'
          };
        }
      } catch (e) {
        this.log(`Error with github.copilot.chat: ${e instanceof Error ? e.message : String(e)}`);
      }
      
      // If all methods fail, throw an error
      throw new Error('Failed to generate with Copilot');
    } catch (error) {
      this.log(`Copilot generation error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * Generate text using Anthropic
   */
  private async generateWithAnthropic(
    params: LMRequestParams, 
    provider: LLMProviderConfig
  ): Promise<LMResponse> {
    this.log(`Using Anthropic API with model: ${provider.modelName}`);
    
    if (!provider.apiKey) {
      throw new Error('Anthropic API key is required');
    }
    
    try {
      // In a real implementation, we would use the Anthropic API
      // For now, we'll use a mock implementation
      const mockResult = this.generateWithMockProvider(params);
      mockResult.provider = 'anthropic';
      mockResult.model = provider.modelName;
      mockResult.text = `Note: This is a simulated ${provider.modelName} response.\n\n${mockResult.text}`;
      return mockResult;
    } catch (error) {
      this.log(`Anthropic API error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * Generate text using OpenAI
   */
  private async generateWithOpenAI(
    params: LMRequestParams, 
    provider: LLMProviderConfig
  ): Promise<LMResponse> {
    this.log(`Using OpenAI API with model: ${provider.modelName}`);
    
    if (!provider.apiKey) {
      throw new Error('OpenAI API key is required');
    }
    
    try {
      // In a real implementation, we would use the OpenAI API
      // For now, we'll use a mock implementation
      const mockResult = this.generateWithMockProvider(params);
      mockResult.provider = 'openai';
      mockResult.model = provider.modelName;
      mockResult.text = `Note: This is a simulated ${provider.modelName} response.\n\n${mockResult.text}`;
      return mockResult;
    } catch (error) {
      this.log(`OpenAI API error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * Generate text using Hugging Face
   */
  private async generateWithHuggingFace(
    params: LMRequestParams, 
    provider: LLMProviderConfig
  ): Promise<LMResponse> {
    this.log(`Using HuggingFace API with model: ${provider.modelName}`);
    
    if (!provider.apiKey) {
      throw new Error('HuggingFace API key is required');
    }
    
    try {
      // In a real implementation, we would use the HuggingFace API
      // For now, we'll use a mock implementation
      const mockResult = this.generateWithMockProvider(params);
      mockResult.provider = 'huggingface';
      mockResult.model = provider.modelName;
      mockResult.text = `Note: This is a simulated ${provider.modelName} response.\n\n${mockResult.text}`;
      return mockResult;
    } catch (error) {
      this.log(`HuggingFace API error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * Generate text using a local model
   */
  private async generateWithLocalModel(
    params: LMRequestParams, 
    provider: LLMProviderConfig
  ): Promise<LMResponse> {
    this.log(`Using local model: ${provider.modelName}`);
    
    try {
      // In a real implementation, we would call a local API
      // For now, we'll use a mock implementation
      const mockResult = this.generateWithMockProvider(params);
      mockResult.provider = 'local';
      mockResult.model = provider.modelName;
      mockResult.text = `Note: This is a simulated ${provider.modelName} local model response.\n\n${mockResult.text}`;
      return mockResult;
    } catch (error) {
      this.log(`Local model error: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * Generate text using a mock provider
   */
  private generateWithMockProvider(params: LMRequestParams): LMResponse {
    this.log('Using mock provider for text generation');
    
    // Create a simplistic response based on the prompt
    const promptLines = params.prompt.split('\n');
    const promptSummary = promptLines.length > 1 
      ? promptLines[0] + '...' 
      : params.prompt;
    
    // Generate deterministic but varied responses based on the prompt hash
    const promptHash = this.hashString(params.prompt);
    const responseOptions = [
      `Here's a response to your query about "${promptSummary}":\n\nBased on the information provided, I would suggest considering the following approach...\n\n1. First, analyze the requirements\n2. Then, design a solution\n3. Finally, implement step by step`,
      
      `Regarding "${promptSummary}":\n\nThere are several ways to address this. The most efficient would be to...\n\nConsider using a modular approach with these components:\n- Component A for handling input\n- Component B for processing\n- Component C for output formatting`,
      
      `I've analyzed your question about "${promptSummary}" and here's what I think:\n\nThe key insight is understanding the underlying patterns. I recommend:\n\n\`\`\`\nconst solution = analyzePattern(input);\nreturn optimize(solution);\n\`\`\`\n\nThis approach will give you the best results because it separates concerns and makes testing easier.`
    ];
    
    // Select a response based on prompt hash
    const selectedResponse = responseOptions[promptHash % responseOptions.length];
    
    return {
      text: selectedResponse,
      provider: 'mock',
      model: 'mock-model',
      usage: {
        promptTokens: params.prompt.length / 4,
        completionTokens: selectedResponse.length / 4,
        totalTokens: (params.prompt.length + selectedResponse.length) / 4
      },
      metadata: {
        temperature: params.temperature || 0.7,
        maxTokens: params.maxTokens || 500
      }
    };
  }
  
  /**
   * Simple hash function for a string
   */
  private hashString(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash);
  }
  
  /**
   * Get LLM configuration
   */
  getLLMConfig(): { provider: string; model: string } {
    const selectedProvider = this.providerManager.getSelectedProvider();
    return {
      provider: selectedProvider?.provider?.toString() || LMProvider.Mock,
      model: selectedProvider?.modelName || 'mock-model'
    };
  }
  
  /**
   * Call VS Code's LM API if available
   */
  async callVSCodeLM(params: LMRequestParams): Promise<string> {
    try {
      const vscodeResult = await this.generateWithCopilot(params, {
        id: 'vscode-copilot',
        name: 'GitHub Copilot',
        provider: LMProvider.Copilot,
        modelName: 'copilot'
      });
      return vscodeResult.text;
    } catch (error) {
      this.log(`Error calling VS Code LM: ${error instanceof Error ? error.message : String(error)}`);
      const fallbackResult = await this.generateText(params);
      return fallbackResult.text;
    }
  }
  
  /**
   * Call a language model
   */
  async callLM(params: LMRequestParams): Promise<string> {
    try {
      const result = await this.generateText(params);
      return result.text;
    } catch (error) {
      this.log(`Error calling LM: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  
  /**
   * Extract tool calls from a response (simplified placeholder)
   */
  extractToolCalls(response: string): any[] {
    // This would be a more sophisticated function in a real implementation
    // For now, just look for basic patterns
    const toolCallRegex = /\{\s*"tool"\s*:\s*"([^"]+)"\s*,\s*"params"\s*:\s*(\{[^}]+\})\s*\}/g;
    const matches = [];
    let match;
    
    while ((match = toolCallRegex.exec(response)) !== null) {
      try {
        const tool = match[1];
        const paramsStr = match[2];
        const params = JSON.parse(paramsStr);
        
        matches.push({ tool, params });
      } catch (e) {
        this.log(`Error parsing tool call: ${e instanceof Error ? e.message : String(e)}`);
      }
    }
    
    return matches;
  }
  
  /**
   * Get model information
   */
  getModelInfo(modelId: string): any {
    // This would provide more detailed information in a real implementation
    const provider = this.providerManager.getAllProviders().find(p => p.modelName === modelId);
    
    if (provider) {
      return {
        id: provider.modelName,
        provider: provider.provider,
        contextWindow: provider.provider === LMProvider.OpenAI && provider.modelName.includes('gpt-4') ? 8192 :
                       provider.provider === LMProvider.OpenAI ? 4096 :
                       provider.provider === LMProvider.Anthropic ? 16384 :
                       provider.provider === LMProvider.Copilot ? 8192 : 2048,
        maxTokens: 1024,
        supportsFunctionCalling: provider.provider === LMProvider.OpenAI || provider.provider === LMProvider.Anthropic
      };
    }
    
    return {
      id: modelId,
      provider: 'unknown',
      contextWindow: 2048,
      maxTokens: 1024,
      supportsFunctionCalling: false
    };
  }
  
  /**
   * Validate a response (placeholder)
   */
  validateResponse(response: string): boolean {
    // This would be more sophisticated in a real implementation
    return !!response && response.length > 0;
  }
  
  /**
   * Handle errors
   */
  handleError(error: any): string {
    const message = error instanceof Error ? error.message : String(error);
    this.log(`Error in LM API: ${message}`);
    return `An error occurred: ${message}`;
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }
}

/**
 * Create an LM API Bridge
 */
export function createLMAPIBridge(
  context: vscode.ExtensionContext,
  agentClient: AgentClient,
  providerManager: LLMProviderManager,
  outputChannel?: vscode.OutputChannel
): LMAPIBridge {
  return new LMAPIBridge(context, agentClient, providerManager, outputChannel);
}



==============================================
FILE: ./src/vscode-extension/master-command-center.ts
==============================================

import * as vscode from 'vscode';

/**
 * Master Command Center
 * 
 * This class provides a centralized interface for accessing all commands in The New Fuse.
 * It creates a webview panel that displays available commands and allows users to execute them.
 */
export class MasterCommandCenter {
  private context: vscode.ExtensionContext;
  private panel: vscode.WebviewPanel | undefined;
  
  /**
   * Constructor
   * @param context VS Code extension context
   */
  constructor(context: vscode.ExtensionContext) {
    this.context = context;
  }
  
  /**
   * Show the Master Command Center
   */
  public async show(): Promise<void> {
    // Create and show panel
    this.panel = vscode.window.createWebviewPanel(
      'masterCommandCenter',
      'The New Fuse Command Center',
      vscode.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true
      }
    );
    
    // Set HTML content
    this.panel.webview.html = this.getWebviewContent();
    
    // Handle messages from the webview
    this.panel.webview.onDidReceiveMessage(async (message) => {
      if (message.command === 'executeCommand') {
        try {
          await vscode.commands.executeCommand(message.commandId, ...message.args);
        } catch (error) {
          vscode.window.showErrorMessage(`Error executing command ${message.commandId}: ${error.message}`);
        }
      }
    });
    
    // Clean up resources when the panel is closed
    this.panel.onDidDispose(() => {
      this.panel = undefined;
    });
  }
  
  /**
   * Get the HTML content for the webview
   */
  private getWebviewContent(): string {
    // Get all registered commands
    const commands = [
      { id: 'thefuse.startAICollab', title: 'Start AI Collaboration', description: 'Start a new AI collaboration session' },
      { id: 'thefuse.openChatPanel', title: 'Open Chat Panel', description: 'Open the chat interface' },
      { id: 'thefuse.mcp.showTools', title: 'Show MCP Tools', description: 'Show available MCP tools' },
      { id: 'thefuse.mcp.initialize', title: 'Initialize MCP', description: 'Initialize the MCP integration' },
      { id: 'thefuse.showAgents', title: 'Show Agents', description: 'Show discovered AI agents' },
      { id: 'thefuse.discoverAgents', title: 'Discover Agents', description: 'Discover available AI agents' },
      { id: 'thefuse.openWorkflowBuilder', title: 'Open Workflow Builder', description: 'Open the workflow builder interface' },
      { id: 'thefuse.showLog', title: 'Show Log', description: 'Show The New Fuse log' }
    ];
    
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>The New Fuse Command Center</title>
        <style>
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            padding: 20px;
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
          }
          h1 {
            color: var(--vscode-editor-foreground);
            border-bottom: 1px solid var(--vscode-panel-border);
            padding-bottom: 10px;
          }
          .command-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
          }
          .command-item {
            padding: 10px;
            margin-bottom: 8px;
            background-color: var(--vscode-editor-inactiveSelectionBackground);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
          }
          .command-item:hover {
            background-color: var(--vscode-editor-selectionBackground);
          }
          .command-title {
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
          }
          .command-description {
            font-size: 0.9em;
            opacity: 0.8;
          }
          .command-id {
            font-family: monospace;
            font-size: 0.8em;
            color: var(--vscode-textPreformat-foreground);
            display: block;
            margin-top: 5px;
          }
          .search-box {
            width: 100%;
            padding: 8px;
            margin-bottom: 15px;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            border-radius: 4px;
          }
        </style>
      </head>
      <body>
        <h1>The New Fuse Command Center</h1>
        <input type="text" class="search-box" placeholder="Search commands..." id="searchBox">
        
        <ul class="command-list" id="commandList">
          ${commands.map(cmd => `
            <li class="command-item" data-command-id="${cmd.id}">
              <span class="command-title">${cmd.title}</span>
              <span class="command-description">${cmd.description}</span>
              <span class="command-id">${cmd.id}</span>
            </li>
          `).join('')}
        </ul>
        
        <script>
          (function() {
            const vscode = acquireVsCodeApi();
            const commandItems = document.querySelectorAll('.command-item');
            const searchBox = document.getElementById('searchBox');
            
            // Handle command click
            commandItems.forEach(item => {
              item.addEventListener('click', () => {
                const commandId = item.getAttribute('data-command-id');
                vscode.postMessage({
                  command: 'executeCommand',
                  commandId: commandId,
                  args: []
                });
              });
            });
            
            // Handle search
            searchBox.addEventListener('input', () => {
              const searchTerm = searchBox.value.toLowerCase();
              commandItems.forEach(item => {
                const title = item.querySelector('.command-title').textContent.toLowerCase();
                const description = item.querySelector('.command-description').textContent.toLowerCase();
                const id = item.querySelector('.command-id').textContent.toLowerCase();
                
                if (title.includes(searchTerm) || description.includes(searchTerm) || id.includes(searchTerm)) {
                  item.style.display = 'block';
                } else {
                  item.style.display = 'none';
                }
              });
            });
          })();
        </script>
      </body>
      </html>
    `;
  }
}

/**
 * Register the Master Command Center command
 * @param context VS Code extension context
 */
export function registerMasterCommandCenter(context: vscode.ExtensionContext): vscode.Disposable {
  const masterCommandCenter = new MasterCommandCenter(context);
  
  // Register the command
  const disposable = vscode.commands.registerCommand('thefuse.openMasterCommandCenter', async () => {
    await masterCommandCenter.show();
  });
  
  // Add to subscriptions
  context.subscriptions.push(disposable);
  
  // Create status bar item
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(list-selection) Commands";
  statusBarItem.tooltip = "Open The New Fuse Command Center";
  statusBarItem.command = 'thefuse.openMasterCommandCenter';
  statusBarItem.show();
  
  // Add status bar item to subscriptions
  context.subscriptions.push(statusBarItem);
  
  return disposable;
}


==============================================
FILE: ./src/vscode-extension/mcp-integration.ts
==============================================

import * as vscode from 'vscode';
import { MCPManager } from './mcp-integration/mcp-manager';
import { MCPClient } from './mcp-integration/mcp-client';
import { registerMCPServerView } from './mcp-integration/mcp-server-view';

// AgentMCPIntegration class for handling interaction between agents and MCP tools
class AgentMCPIntegration {
  private mcpManager: MCPManager;
  private lmBridge: any; // LM Bridge service

  constructor(mcpManager: MCPManager, lmBridge: any) {
    this.mcpManager = mcpManager;
    this.lmBridge = lmBridge;
  }

  // Get available tools for an agent
  async getToolsForAgent(): Promise<any[]> {
    try {
      const mcpTools = await this.mcpManager.getTools();
      
      // Convert MCP tools to a format that agents can use
      return mcpTools.map(tool => ({
        name: `mcp.${tool.serverName}.${tool.tool.name}`,
        description: tool.tool.description,
        parameters: tool.tool.parameters,
        execute: async (params: any) => {
          return await this.mcpManager.executeTool(tool.serverId, tool.tool.name, params);
        }
      }));
    } catch (error) {
      console.error('Error getting MCP tools for agent:', error);
      return [];
    }
  }

  // Execute an MCP tool
  async executeTool(toolName: string, parameters: any): Promise<any> {
    const parts = toolName.split('.');
    if (parts.length < 3 || parts[0] !== 'mcp') {
      throw new Error(`Invalid MCP tool name: ${toolName}`);
    }
    
    const serverName = parts[1];
    const actualToolName = parts.slice(2).join('.');
    
    // Find server ID from name
    const servers = this.mcpManager.getServers();
    const server = servers.find(s => s.name === serverName);
    
    if (!server) {
      throw new Error(`MCP server "${serverName}" not found`);
    }
    
    return await this.mcpManager.executeTool(server.id, actualToolName, parameters);
  }
}

// Main function to register MCP integration
export function registerMCPIntegration(
  context: vscode.ExtensionContext,
  lmBridge: any
): { mcpManager: MCPManager; agentIntegration: AgentMCPIntegration } {
  // Create MCP Manager
  const mcpManager = new MCPManager(context);
  
  // Create Agent MCP Integration
  const agentIntegration = new AgentMCPIntegration(mcpManager, lmBridge);
  
  // Register MCP Server View
  const serverViewDisposables = registerMCPServerView(context);
  serverViewDisposables.forEach(d => context.subscriptions.push(d));
  
  // Register commands
  context.subscriptions.push(
    vscode.commands.registerCommand('thefuse.mcp.initialize', async () => {
      try {
        vscode.window.showInformationMessage('Initializing MCP integration...');
        await mcpManager.initialize();
        vscode.window.showInformationMessage('MCP integration initialized successfully');
      } catch (error: any) {
        vscode.window.showErrorMessage(`Failed to initialize MCP integration: ${error.message}`);
      }
    })
  );
  
  context.subscriptions.push(
    vscode.commands.registerCommand('thefuse.mcp.showTools', async () => {
      const servers = mcpManager.getServers();
      
      if (servers.length === 0) {
        vscode.window.showInformationMessage('No MCP servers registered. Run "Initialize MCP Integration" first.');
        return;
      }
      
      const serverItems = servers.map(server => ({
        label: server.name,
        description: `${server.status} - ${server.url}`,
        server
      }));
      
      const selected = await vscode.window.showQuickPick(serverItems, {
        placeHolder: 'Select an MCP server to view tools',
      });
      
      if (!selected) return;
      
      const server = selected.server;
      const tools = Object.entries(server.tools || {});
      
      if (tools.length === 0) {
        vscode.window.showInformationMessage(`No tools available from "${server.name}"`);
        return;
      }
      
      const toolItems = tools.map(([name, tool]) => ({
        label: name,
        description: (tool as any).description,
        detail: `Parameters: ${Object.keys((tool as any).parameters || {}).join(', ')}`
      }));
      
      const selectedTool = await vscode.window.showQuickPick(toolItems, {
        placeHolder: 'Select a tool to view details',
      });
      
      if (!selectedTool) return;
      
      // Show tool details
      vscode.window.showInformationMessage(`Selected tool: ${selectedTool.label}`);
    })
  );
  
  context.subscriptions.push(
    vscode.commands.registerCommand('thefuse.mcp.testTool', async () => {
      await mcpManager.showToolTestDialog();
    })
  );
  
  // Add new marketplace browsing command
  context.subscriptions.push(
    vscode.commands.registerCommand('thefuse.mcp.browseMarketplace', async () => {
      await mcpManager.showMarketplaceBrowser();
    })
  );
  
  // Add command to add a server from marketplace
  context.subscriptions.push(
    vscode.commands.registerCommand('thefuse.mcp.addServerFromMarketplace', async () => {
      await mcpManager.addServerFromMarketplace();
    })
  );
  
  context.subscriptions.push(
    vscode.commands.registerCommand('thefuse.mcp.askAgent', async () => {
      if (!lmBridge) {
        vscode.window.showErrorMessage('LM Bridge is not available');
        return;
      }
      
      let tools: any[] = [];
      try {
        tools = await agentIntegration.getToolsForAgent();
      } catch (error: any) {
        vscode.window.showErrorMessage(`Failed to get MCP tools for agent: ${error.message}`);
        return;
      }
      
      if (tools.length === 0) {
        vscode.window.showInformationMessage('No MCP tools available for agents at the moment.');
        // Optionally, still allow asking without tools?
        // return;
      }
      
      const prompt = await vscode.window.showInputBox({
        placeHolder: 'What would you like the agent to do?',
        prompt: `The agent has access to ${tools.length} MCP tool(s). Enter your request:`
      });
      
      if (!prompt) return;
      
      vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "Asking Agent...",
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0, message: "Sending request..." });
        
        try {
          // --- Integration with LM Bridge --- 
          // Assuming lmBridge has a method like askAgent(prompt, tools)
          // The exact method name and signature might differ.
          if (typeof lmBridge.askAgent === 'function') {
            progress.report({ increment: 50, message: "Waiting for response..." });
            const response = await lmBridge.askAgent(prompt, tools);
            
            // Display the response (e.g., in a new editor, output channel, or chat view)
            // For now, just show an information message
            vscode.window.showInformationMessage(`Agent Response: ${JSON.stringify(response)}`); 
            // TODO: Integrate with a proper display mechanism like the chat view
            
          } else {
            throw new Error('LM Bridge does not have an askAgent method.');
          }
          // --- End Integration --- 
          
          progress.report({ increment: 100, message: "Completed." });
          // Keep the success message brief or remove if response is shown elsewhere
          // vscode.window.showInformationMessage('Agent execution completed'); 
        } catch (error: any) {
          console.error('Error during agent execution:', error);
          vscode.window.showErrorMessage(`Agent execution failed: ${error.message}`);
        }
      });
    })
  );

  return { mcpManager, agentIntegration };
}


==============================================
FILE: ./src/vscode-extension/mcp-integration/README.md
==============================================

# MCP Integration for The New Fuse

This module integrates the Model Context Protocol (MCP) with The New Fuse extension.

## What is MCP?

The Model Context Protocol (MCP) is a standard for providing external tools (like web search, file system access, database queries, etc.) to Large Language Models (LLMs) and AI agents. It promotes tool reusability and simplifies integration.

## Components

- **MCPClient**: Connects to MCP servers via stdio and handles JSON-RPC communication
- **MCPManager**: Manages MCP server processes and tool discovery in VS Code
- **MCPAgentIntegration**: Connects MCP tools with the AI agent system

## Configuration

MCP servers are configured in `mcp_config.json`. A default configuration is created automatically if none exists.

### Example Configuration

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "--allow-dir", "./data"
      ]
    },
    "brave-search": {
      "command": "docker",
      "args": [
        "run",
        "--rm",
        "-i",
        "-e", "BRAVE_API_KEY",
        "modelcontextprotocol/brave-search"
      ],
      "env": {
        "BRAVE_API_KEY": "YOUR_ACTUAL_BRAVE_SEARCH_API_KEY"
      }
    }
  }
}
```

## Commands

The following VS Code commands are available:

- `thefuse.mcp.initialize`: Initialize MCP integration
- `thefuse.mcp.showTools`: Show available MCP tools
- `thefuse.mcp.testTool`: Test a specific MCP tool
- `thefuse.mcp.askAgent`: Ask the agent a question that might use MCP tools
- `thefuse.openMcpCommandPalette`: Open a quick pick menu with MCP commands

## Usage

1. Click the MCP icon in the status bar (`$(tools) MCP`) or run the `Open MCP Command Palette` command
2. Select `Initialize MCP` to start the integration
3. After initialization, select `Show MCP Tools` to see available tools
4. Use `Ask Agent with MCP Tools` to ask a question that might use tools

## Examples

- "List files in the data directory"
- "Search the web for TypeScript MCP implementation"
- "Run SQL query SELECT * FROM users LIMIT 10"

## Troubleshooting

If you encounter issues:

1. Check the "MCP Integration" output channel for logs
2. Verify MCP servers are properly configured in mcp_config.json
3. Ensure required dependencies (npx, docker) are installed
4. Try reinitializing with the `thefuse.mcp.initialize` command



==============================================
FILE: ./src/vscode-extension/mcp-integration/agent-integration.tsx
==============================================

import * as vscode from 'vscode';
import { MCPManager } from './mcp-manager';
import { AgentTool } from './mcp-client';
import { LMAPIBridge } from '../lm-api-bridge';

/**
 * MCP AI Agent Integration
 * 
 * This class integrates MCP tools with our AI agent system.
 */
export class MCPAgentIntegration {
    private mcpManager: MCPManager;
    private lmBridge: LMAPIBridge;
    private context: vscode.ExtensionContext;
    private outputChannel: vscode.OutputChannel;
    private toolsDisposable: vscode.Disposable | null = null;

    constructor(
        context: vscode.ExtensionContext, 
        mcpManager: MCPManager, 
        lmBridge: LMAPIBridge
    ) {
        this.context = context;
        this.mcpManager = mcpManager;
        this.lmBridge = lmBridge;
        this.outputChannel = vscode.window.createOutputChannel('MCP Agent Integration');
        
        // Listen for tool changes
        this.toolsDisposable = this.mcpManager.onToolsChanged(tools => {
            this.handleToolsChanged(tools);
        });
        
        // Register commands
        this.registerCommands();
    }

    /**
     * Register commands for agent integration
     */
    private registerCommands() {
        // Register a command to ask the agent to use a tool
        this.context.subscriptions.push(
            vscode.commands.registerCommand('thefuse.mcp.askAgent', async (query?: string) => {
                return this.askAgent(query);
            })
        );
    }

    /**
     * Handle changes to available tools
     */
    private handleToolsChanged(tools: AgentTool[]) {
        this.log(`Tool list updated: ${tools.length} tools available`);
        
        // This would be where we update the agent's tool list
        // For now, we'll just log the tools
        tools.forEach(tool => {
            this.log(`Tool: ${tool.name} - ${tool.description}`);
        });
    }

    /**
     * Ask the agent a question that might require tool use
     */
    async askAgent(query?: string): Promise<string> {
        // If no query is provided, ask the user
        if (!query) {
            query = await vscode.window.showInputBox({
                prompt: 'What would you like to ask the AI?',
                placeHolder: 'e.g., List files in the data directory'
            });
            
            if (!query) {
                return ''; // User cancelled
            }
        }
        
        this.log(`Agent query: ${query}`);
        
        try {
            // Get available tools
            const tools = this.mcpManager.getTools();
            
            if (tools.length === 0) {
                this.log('No tools available for the agent to use');
                
                // Just use the LM directly without tool access
                const response = await this.lmBridge.generateText({
                    prompt: query,
                    systemPrompt: 'You are a helpful assistant. Answer the user query.'
                });
                
                return response.text;
            }
            
            // In a real implementation, we would:
            // 1. Format the tools for the agent to understand
            // 2. Send the query and tools to the agent
            // 3. The agent would decide if it needs to use a tool
            // 4. If it does, it would call the tool and use the result in its response
            
            // For this example, we'll use a simple heuristic:
            // Check if the query might require using a file tool
            if (tools.some(t => t.name.includes('file') || t.name.includes('list_files')) &&
                (query.includes('file') || query.includes('list') || query.includes('directory'))) {
                
                // Get the list_files tool
                const listFilesTool = tools.find(t => t.name === 'list_files' || t.name.includes('list_files'));
                
                if (listFilesTool) {
                    this.log('Using list_files tool to respond to query');
                    
                    try {
                        // Determine directory from query or use default
                        let directory = './data';
                        if (query.includes('directory') || query.includes('folder')) {
                            // This is overly simplistic - in a real implementation,
                            // the agent would use more sophisticated parsing
                            const match = query.match(/in\s+(\S+)/);
                            if (match && match[1]) {
                                directory = match[1];
                            }
                        }
                        
                        // Execute the tool
                        const result = await listFilesTool.execute({ path: directory });
                        
                        // Generate a response using the tool results
                        const toolResultPrompt = `
The user asked: "${query}"

I used a file listing tool with the path "${directory}" and got these results:
${JSON.stringify(result, null, 2)}

Provide a helpful response to the user's query based on these results.`;
                        
                        const response = await this.lmBridge.generateText({
                            prompt: toolResultPrompt,
                            systemPrompt: 'You are a helpful assistant with access to external tools. Explain what you did and what you found.'
                        });
                        
                        return response.text;
                    } catch (error: any) {
                        this.log(`Error using list_files tool: ${error.message}`);
                        // Fall back to regular response
                    }
                }
            }
            
            // For database queries
            if (tools.some(t => t.name.includes('query') || t.name.includes('sql')) &&
                (query.includes('database') || query.includes('sql') || query.includes('query'))) {
                
                // Get the query tool
                const queryTool = tools.find(t => t.name === 'query' || t.name.includes('query'));
                
                if (queryTool) {
                    this.log('Using database query tool to respond to query');
                    
                    // Show SQL input dialog
                    const sqlQuery = await vscode.window.showInputBox({
                        prompt: 'Enter SQL query to execute',
                        placeHolder: 'SELECT * FROM my_table LIMIT 10'
                    });
                    
                    if (sqlQuery) {
                        try {
                            // Execute the tool
                            const result = await queryTool.execute({ query: sqlQuery });
                            
                            // Generate a response using the tool results
                            const toolResultPrompt = `
The user asked: "${query}"

I used a database query tool to execute this SQL:
${sqlQuery}

And got these results:
${JSON.stringify(result, null, 2)}

Provide a helpful response to the user's query based on these results.`;
                            
                            const response = await this.lmBridge.generateText({
                                prompt: toolResultPrompt,
                                systemPrompt: 'You are a helpful assistant with access to external tools. Explain the database query results clearly.'
                            });
                            
                            return response.text;
                        } catch (error: any) {
                            this.log(`Error using query tool: ${error.message}`);
                            // Fall back to regular response
                        }
                    }
                }
            }
            
            // For web search
            if (tools.some(t => t.name.includes('search') || t.name.includes('brave_search')) &&
                (query.includes('search') || query.includes('web') || query.includes('find online'))) {
                
                // Get the search tool
                const searchTool = tools.find(t => t.name === 'brave_search' || t.name.includes('search'));
                
                if (searchTool) {
                    this.log('Using web search tool to respond to query');
                    
                    try {
                        // Extract search query
                        let searchQuery = query;
                        if (query.includes('search for')) {
                            const match = query.match(/search for\s+(.+)/i);
                            if (match && match[1]) {
                                searchQuery = match[1];
                            }
                        }
                        
                        // Execute the tool
                        const result = await searchTool.execute({ query: searchQuery });
                        
                        // Generate a response using the tool results
                        const toolResultPrompt = `
The user asked: "${query}"

I used a web search tool to search for "${searchQuery}" and got these results:
${JSON.stringify(result, null, 2)}

Summarize the most relevant information to answer the user's query based on these search results.`;
                        
                        const response = await this.lmBridge.generateText({
                            prompt: toolResultPrompt,
                            systemPrompt: 'You are a helpful assistant with access to external tools. Summarize web search results clearly and concisely.'
                        });
                        
                        return response.text;
                    } catch (error: any) {
                        this.log(`Error using search tool: ${error.message}`);
                        // Fall back to regular response
                    }
                }
            }
            
            // Default case - no tool used or tool failed
            // Use the LM to generate a direct response
            this.log('No specific tool matched or tool execution failed, using direct response');
            
            // Create a more detailed prompt that lists available tools
            const toolsDescription = tools.map(t => `- ${t.name}: ${t.description}`).join('\n');
            
            const enhancedPrompt = `
User query: "${query}"

I have access to these tools but didn't need to use them for this query:
${toolsDescription}

Please provide a direct and helpful response to the user's query.`;
            
            const response = await this.lmBridge.generateText({
                prompt: enhancedPrompt,
                systemPrompt: 'You are a helpful assistant with access to external tools. Provide direct answers when tools aren\'t needed.'
            });
            
            return response.text;
        } catch (error: any) {
            this.log(`Error asking agent: ${error.message}`);
            return `I encountered an error while processing your request: ${error.message}`;
        }
    }

    /**
     * Log a message to the output channel
     */
    private log(message: string): void {
        const timestamp = new Date().toISOString();
        this.outputChannel.appendLine(`[${timestamp}] ${message}`);
    }

    /**
     * Dispose of resources
     */
    dispose(): void {
        if (this.toolsDisposable) {
            this.toolsDisposable.dispose();
        }
        this.outputChannel.dispose();
    }
}



==============================================
FILE: ./src/vscode-extension/mcp-integration/index.ts
==============================================

import * as vscode from 'vscode';
import { MCPManager } from './mcp-manager';
import { MCPAgentIntegration } from './agent-integration';
import { LMAPIBridge } from '../lm-api-bridge';
import { registerComponentAnalysisTool } from './component-analysis-tool';
import { registerMCPServerView } from './mcp-server-view';

/**
 * Register MCP integration with the VS Code extension
 */
export function registerMCPIntegration(
    context: vscode.ExtensionContext,
    lmBridge: LMAPIBridge
): { mcpManager: MCPManager; agentIntegration: MCPAgentIntegration } {
    // Create the MCP Manager
    const mcpManager = new MCPManager(context);

    // Create the Agent Integration
    const agentIntegration = new MCPAgentIntegration(context, mcpManager, lmBridge);

    // Register Component Analysis Tool
    const componentAnalysisTool = registerComponentAnalysisTool(context, mcpManager);

    // Register MCP Server View
    const serverViewSubscriptions = registerMCPServerView(context);
    serverViewSubscriptions.forEach(subscription => {
        context.subscriptions.push(subscription);
    });

    // Register commands with proper implementations
    context.subscriptions.push(
        vscode.commands.registerCommand('thefuse.mcp.initialize', async () => {
            try {
                await mcpManager.initialize();
                return true;
            } catch (error) {
                vscode.window.showErrorMessage(`MCP initialization failed: ${error.message}`);
                return false;
            }
        }),

        vscode.commands.registerCommand('thefuse.mcp.showTools', async () => {
            try {
                const tools = await mcpManager.getTools();
                if (!tools.length) {
                    vscode.window.showInformationMessage('No MCP tools available. Try initializing MCP first.');
                    return;
                }
                return mcpManager.showToolsQuickPick();
            } catch (error) {
                vscode.window.showErrorMessage(`Failed to show MCP tools: ${error.message}`);
            }
        }),

        vscode.commands.registerCommand('thefuse.mcp.testTool', async () => {
            try {
                return mcpManager.showToolTestDialog();
            } catch (error) {
                vscode.window.showErrorMessage(`Tool test failed: ${error.message}`);
            }
        }),

        vscode.commands.registerCommand('thefuse.mcp.askAgent', async () => {
            try {
                return agentIntegration.showAskDialog();
            } catch (error) {
                vscode.window.showErrorMessage(`Agent query failed: ${error.message}`);
            }
        }),

        // Add marketplace-related commands
        vscode.commands.registerCommand('thefuse.mcp.browseMarketplace', async () => {
            try {
                await mcpManager.showMarketplaceBrowser();
            } catch (error) {
                vscode.window.showErrorMessage(`Failed to browse MCP marketplace: ${error.message}`);
            }
        }),

        vscode.commands.registerCommand('thefuse.mcp.addServerFromMarketplace', async (serverId) => {
            try {
                await mcpManager.addServerFromMarketplace(serverId);
            } catch (error) {
                vscode.window.showErrorMessage(`Failed to add MCP server: ${error.message}`);
            }
        })
    );

    return { mcpManager, agentIntegration };
}



==============================================
FILE: ./src/vscode-extension/mcp-integration/mcp-client.tsx
==============================================

import { spawn, ChildProcessWithoutNullStreams } from 'child_process';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as vscode from 'vscode';

// --- Interfaces for MCP Communication (JSON-RPC) ---
interface JsonRpcRequest {
    jsonrpc: '2.0';
    method: string;
    params?: any;
    id: number;
}

interface JsonRpcResponse {
    jsonrpc: '2.0';
    result?: any;
    error?: { code: number; message: string; data?: any };
    id: number;
}

// --- Interface for MCP Tool Definition (as received from server) ---
interface McpToolInfo {
    name: string;
    description: string;
    inputSchema: any; // JSON Schema for input parameters
}

// --- Interface for the Tool format that our agent expects ---
export interface AgentTool {
    name: string;
    description: string;
    parameters: any;
    execute: (args: Record<string, any>) => Promise<any>;
}

// --- Configuration Interfaces ---
interface ServerConfig {
    command: string;
    args: string[];
    env?: Record<string, string>;
}

interface McpConfig {
    mcpServers: Record<string, ServerConfig>;
}

/**
 * A simple async exit stack for resource management
 */
class AsyncExitStack {
    private callbacks: (() => Promise<void>)[] = [];

    async use(callback: () => Promise<void>): Promise<void> {
        this.callbacks.push(callback);
    }

    async close(): Promise<void> {
        // Execute callbacks in reverse order (LIFO)
        for (let i = this.callbacks.length - 1; i >= 0; i--) {
            try {
                await this.callbacks[i]();
            } catch (error) {
                console.error("Error during exit stack execution:", error);
            }
        }
        this.callbacks = [];
    }
}

// --- MCPServer Class ---
class MCPServer {
    public name: string;
    private config: ServerConfig;
    private process: ChildProcessWithoutNullStreams | null = null;
    private requestCounter = 0;
    private pendingRequests = new Map<number, { resolve: (value: any) => void; reject: (reason?: any) => void }>();
    private exitStack: AsyncExitStack;
    private isInitialized = false;
    private outputChannel: vscode.OutputChannel;

    constructor(name: string, config: ServerConfig, exitStack: AsyncExitStack, outputChannel: vscode.OutputChannel) {
        this.name = name;
        this.config = config;
        this.exitStack = exitStack;
        this.outputChannel = outputChannel;
        this.log(`Prepared server: ${this.name}`);
    }

    async initialize(): Promise<void> {
        if (this.isInitialized) return;
        this.log(`Initializing...`);

        const command = this.config.command;
        const args = this.config.args || [];
        const env = { ...process.env, ...(this.config.env || {}) };

        try {
            this.process = spawn(command, args, {
                stdio: ['pipe', 'pipe', 'pipe'], // Use pipes for stdin, stdout, stderr
                env: env,
                shell: true // May be needed for commands like docker, npx
            });

            this.isInitialized = true;
            this.log(`Process spawned (PID: ${this.process.pid})`);

            // Handle stdout (responses from server)
            this.process.stdout.on('data', (data) => {
                // MCP uses JSON lines, split by newline
                data.toString().trim().split('\n').forEach((line: string) => {
                    if (!line) return;
                    try {
                        const response: JsonRpcResponse = JSON.parse(line);
                        this.handleResponse(response);
                    } catch (e) {
                        this.log(`Error parsing JSON response: ${line}`, true);
                    }
                });
            });

            // Handle stderr (errors/logs from server)
            this.process.stderr.on('data', (data) => {
                this.log(`STDERR: ${data.toString().trim()}`, true);
            });

            // Handle process exit
            this.process.on('close', (code) => {
                this.log(`Process exited with code ${code}`);
                this.isInitialized = false;
                this.process = null;
                // Reject any pending requests on close
                this.pendingRequests.forEach(({ reject }) => reject(new Error(`Server ${this.name} process exited.`)));
                this.pendingRequests.clear();
            });

            this.process.on('error', (err) => {
                this.log(`Failed to start process: ${err.message}`, true);
                this.isInitialized = false;
                this.process = null;
                this.pendingRequests.forEach(({ reject }) => reject(new Error(`Server ${this.name} process error.`)));
                this.pendingRequests.clear();
                throw err; // Re-throw after logging
            });

            // Register cleanup for this specific process
            await this.exitStack.use(async () => {
                await this.cleanup();
            });

            // Wait a brief moment for server to be ready
            await new Promise(resolve => setTimeout(resolve, 1000)); 
            this.log(`Initialization complete.`);

        } catch (error: any) {
            this.log(`Failed during initialization: ${error.message}`, true);
            this.isInitialized = false; // Ensure state is correct on failure
            throw error; // Re-throw
        }
    }

    private sendRequest(method: string, params?: any): Promise<any> {
        if (!this.process || !this.process.stdin.writable) {
            return Promise.reject(new Error(`Server ${this.name} process is not running or stdin is not writable.`));
        }

        const id = ++this.requestCounter;
        const request: JsonRpcRequest = {
            jsonrpc: '2.0',
            method,
            params,
            id,
        };
        const requestString = JSON.stringify(request) + '\n'; // MCP uses JSON lines

        return new Promise((resolve, reject) => {
            this.pendingRequests.set(id, { resolve, reject });
            this.process!.stdin.write(requestString, (err) => {
                if (err) {
                    this.log(`Error writing to stdin: ${err.message}`, true);
                    this.pendingRequests.delete(id);
                    reject(err);
                }
            });

            // Timeout for requests
            setTimeout(() => {
                if (this.pendingRequests.has(id)) {
                    this.log(`Request ${id} (${method}) timed out.`, true);
                    this.pendingRequests.get(id)?.reject(new Error('Request timed out'));
                    this.pendingRequests.delete(id);
                }
            }, 15000); // 15 second timeout
        });
    }

    private handleResponse(response: JsonRpcResponse): void {
        const promiseCallbacks = this.pendingRequests.get(response.id);
        if (promiseCallbacks) {
            if (response.error) {
                this.log(`Received error response: ${response.error.message}`, true);
                promiseCallbacks.reject(new Error(`MCP Error (${response.error.code}): ${response.error.message}`));
            } else {
                promiseCallbacks.resolve(response.result);
            }
            this.pendingRequests.delete(response.id);
        } else {
            this.log(`Received response for unknown request ID: ${response.id}`, true);
        }
    }

    async list_tools(): Promise<McpToolInfo[]> {
        if (!this.isInitialized) {
            this.log(`Attempted list_tools before initialization. Initializing now.`);
            await this.initialize(); // Attempt to initialize if not already
        }
        try {
            const result = await this.sendRequest('list_tools');
            return result?.tools || [];
        } catch (error: any) {
            this.log(`Error during list_tools: ${error.message}`, true);
            return []; // Return empty list on error
        }
    }

    async call_tool(toolName: string, args: any): Promise<any> {
        if (!this.isInitialized) throw new Error(`Server ${this.name} is not initialized.`);
        this.log(`Calling tool: ${toolName}`);
        try {
            const result = await this.sendRequest('call_tool', { tool_name: toolName, arguments: args });
            this.log(`Tool ${toolName} executed successfully`);
            return result; // The actual result from the tool
        } catch (error: any) {
            this.log(`Error calling tool ${toolName}: ${error.message}`, true);
            throw error; // Re-throw error to be handled by the agent
        }
    }

    async cleanup(): Promise<void> {
        if (this.process) {
            this.log(`Cleaning up process (PID: ${this.process.pid})...`);
            this.process.stdin.end(); // Close stdin first
            this.process.kill('SIGTERM'); // Send TERM signal
            // Wait a short period before forceful kill
            await new Promise(resolve => setTimeout(resolve, 500)); 
            if (!this.process.killed) {
                this.log(`Process did not exit gracefully, sending SIGKILL.`, true);
                this.process.kill('SIGKILL'); // Force kill if necessary
            }
            this.process = null;
            this.isInitialized = false;
            this.log(`Cleanup complete.`);
        }
    }

    // Convert MCP tool to agent tool format
    createAgentTool(mcpTool: McpToolInfo): AgentTool {
        const execute = async (args: Record<string, any>): Promise<any> => {
            return this.call_tool(mcpTool.name, args);
        };

        return {
            name: mcpTool.name,
            description: mcpTool.description,
            parameters: mcpTool.inputSchema,
            execute: execute,
        };
    }

    private log(message: string, isError: boolean = false): void {
        const prefix = `[MCPServer-${this.name}]`;
        if (isError) {
            this.outputChannel.appendLine(`${prefix} ERROR: ${message}`);
        } else {
            this.outputChannel.appendLine(`${prefix} ${message}`);
        }
    }
}

// --- MCPClient Class ---
export class MCPClient {
    private servers: MCPServer[] = [];
    private config: McpConfig | null = null;
    private exitStack = new AsyncExitStack();
    private allTools: AgentTool[] = []; // Store converted tools
    private outputChannel: vscode.OutputChannel;
    private isInitialized: boolean = false;

    constructor(outputChannel?: vscode.OutputChannel) {
        this.outputChannel = outputChannel || vscode.window.createOutputChannel('MCP Client');
        this.log("MCP Client initialized");
        
        // Graceful shutdown handling when used outside of VS Code
        if (typeof process !== 'undefined') {
            process.on('SIGINT', () => this.handleShutdownSignal('SIGINT'));
            process.on('SIGTERM', () => this.handleShutdownSignal('SIGTERM'));
        }
    }

    async loadServers(configPath: string): Promise<void> {
        try {
            const absoluteConfigPath = path.resolve(configPath);
            this.log(`Loading configuration from: ${absoluteConfigPath}`);
            const configData = await fs.readFile(absoluteConfigPath, 'utf8');
            this.config = JSON.parse(configData) as McpConfig;
            this.log("Configuration loaded");

            this.servers = []; // Clear previous servers if reloading
            if (this.config?.mcpServers) {
                for (const [name, serverConfig] of Object.entries(this.config.mcpServers)) {
                    const server = new MCPServer(name, serverConfig, this.exitStack, this.outputChannel);
                    this.servers.push(server);
                }
                this.log(`Loaded ${this.servers.length} server configurations`);
            } else {
                this.log("No 'mcpServers' found in configuration", true);
            }

        } catch (error: any) {
            this.log(`Error loading or parsing configuration file '${configPath}': ${error.message}`, true);
            this.config = null;
            this.servers = [];
            throw new Error(`Failed to load MCP configuration from ${configPath}`);
        }
    }

    async start(): Promise<AgentTool[]> {
        this.log("Starting server connections and discovering tools...");
        this.allTools = []; // Reset tools list
        const toolPromises: Promise<AgentTool[]>[] = [];

        for (const server of this.servers) {
            const startAndDiscover = async (): Promise<AgentTool[]> => {
                try {
                    await server.initialize(); // Ensure initialized
                    const mcpTools = await server.list_tools();
                    this.log(`Found ${mcpTools.length} tools for server: ${server.name}`);
                    return mcpTools.map(mcpTool => server.createAgentTool(mcpTool));
                } catch (e: any) {
                    this.log(`Failed to start or get tools from server ${server.name}: ${e.message}`, true);
                    return []; // Return empty array if a server fails
                }
            };
            toolPromises.push(startAndDiscover());
        }

        // Wait for all servers to start and tools to be discovered concurrently
        const results = await Promise.all(toolPromises);
        results.forEach(serverTools => this.allTools.push(...serverTools));

        this.log(`Total tools discovered and converted: ${this.allTools.length}`);
        this.isInitialized = true;
        return this.allTools;
    }

    async cleanup(): Promise<void> {
        this.log("Cleaning up all server connections...");
        await this.exitStack.close(); // This will call the cleanup for each registered server
        this.isInitialized = false;
        this.log("All resources cleaned up");
    }

    // Get all discovered tools
    getTools(): AgentTool[] {
        return [...this.allTools]; // Return a copy
    }

    // Check if the client is initialized
    isReady(): boolean {
        return this.isInitialized;
    }

    // Log helper
    private log(message: string, isError: boolean = false): void {
        const prefix = '[MCPClient]';
        if (isError) {
            this.outputChannel.appendLine(`${prefix} ERROR: ${message}`);
        } else {
            this.outputChannel.appendLine(`${prefix} ${message}`);
        }
    }

    // Handle shutdown signals
    private async handleShutdownSignal(signal: string): Promise<void> {
        this.log(`Received ${signal}. Cleaning up resources...`);
        await this.cleanup();
        if (typeof process !== 'undefined') {
            process.exit(0);
        }
    }
}

/**
 * Function to load MCP configuration from package settings
 */
export async function loadMcpConfigFromSettings(): Promise<string> {
    // Try to get the config path from settings
    const configPath = vscode.workspace.getConfiguration('theFuse').get<string>('mcpConfigPath');
    
    if (configPath) {
        return configPath;
    }
    
    // If not specified, use the default location
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (workspaceFolder) {
        return path.join(workspaceFolder.uri.fsPath, 'mcp_config.json');
    }
    
    // Fallback to extension directory
    const extensionPath = vscode.extensions.getExtension('thefuse.the-new-fuse-vscode')?.extensionPath;
    if (extensionPath) {
        return path.join(extensionPath, 'mcp_config.json');
    }
    
    throw new Error('Could not determine MCP configuration path. Please specify it in settings.');
}



==============================================
FILE: ./src/vscode-extension/mcp-integration/mcp-manager.ts
==============================================

import * as vscode from 'vscode';
import * as fs from 'fs/promises';
import * as path from 'path';
import { MCPMarketplaceService } from './mcp-marketplace';
import { loadMcpConfigFromSettings } from './mcp-client';

/**
 * Interface for MCP Server
 */
interface MCPServer {
    id: string;
    name: string;
    description?: string;
    url: string;
    apiKey?: string;
    status: 'registered' | 'unregistered' | 'unavailable';
    tools?: Record<string, any>;
}

/**
 * Manager for MCP servers and integration
 */
export class MCPManager {
    private servers: Map<string, MCPServer> = new Map();
    private context: vscode.ExtensionContext;
    private statusBarItem: vscode.StatusBarItem;
    private outputChannel: vscode.OutputChannel;
    private isInitialized: boolean = false;
    private marketplaceService: MCPMarketplaceService;

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
        this.outputChannel = vscode.window.createOutputChannel('MCP Integration');
        this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
        this.statusBarItem.text = 'MCP: Initializing...';
        this.statusBarItem.tooltip = 'The New Fuse MCP Integration';
        this.statusBarItem.command = 'thefuse.mcp.showTools';
        this.statusBarItem.show();
        
        // Initialize the marketplace service
        this.marketplaceService = new MCPMarketplaceService(this.outputChannel);
        
        // Load registered servers from extension storage
        this.loadServers();
        
        // Auto-initialize if configured
        const autoInit = vscode.workspace.getConfiguration('theFuse').get<boolean>('autoInitializeMcp');
        if (autoInit) {
            this.initialize().catch(err => {
                console.error('Auto-initialization failed:', err);
            });
        }
    }

    /**
     * Initialize MCP integration
     */
    async initialize(): Promise<boolean> {
        try {
            this.statusBarItem.text = 'MCP: Initializing...';
            
            // Check if local MCP server is running
            const server = await this.registerServer('http://localhost:3000');
            
            // Update status bar
            this.updateStatusBar();
            
            this.isInitialized = true;
            return true;
        } catch (error: any) {
            this.statusBarItem.text = 'MCP: Error';
            this.statusBarItem.tooltip = `Error: ${error.message}`;
            this.isInitialized = false;
            console.error('MCP initialization failed:', error);
            throw error;
        }
    }
    
    /**
     * Load registered servers from extension storage
     */
    private loadServers(): void {
        const storedServers = this.context.globalState.get<Record<string, MCPServer>>('mcpServers');
        if (storedServers) {
            Object.values(storedServers).forEach(server => {
                this.servers.set(server.id, server);
            });
        }
        this.updateStatusBar();
    }
    
    /**
     * Save registered servers to extension storage
     */
    private saveServers(): void {
        const serversObj: Record<string, MCPServer> = {};
        this.servers.forEach((server, id) => {
            serversObj[id] = server;
        });
        this.context.globalState.update('mcpServers', serversObj);
    }
    
    /**
     * Update the status bar to reflect current MCP server status
     */
    private updateStatusBar(): void {
        if (this.servers.size === 0) {
            this.statusBarItem.text = 'MCP: No Servers';
            this.statusBarItem.tooltip = 'No MCP servers registered';
            return;
        }
        
        const availableServers = Array.from(this.servers.values())
            .filter(s => s.status === 'registered')
            .length;
            
        if (availableServers === 0) {
            this.statusBarItem.text = 'MCP: No Connection';
            this.statusBarItem.tooltip = 'No MCP servers connected';
        } else {
            this.statusBarItem.text = `MCP: ${availableServers} Server${availableServers !== 1 ? 's' : ''}`;
            this.statusBarItem.tooltip = `${availableServers} MCP server${availableServers !== 1 ? 's' : ''} connected`;
        }
    }
    
    /**
     * Register a new MCP server
     */
    async registerServer(url: string, autoRegister: boolean = true): Promise<MCPServer> {
        try {
            // Validate URL
            new URL(url);
            
            // Generate an ID for the server
            const serverId = `mcp-server-${Date.now()}`;
            
            // Create server object
            const server: MCPServer = {
                id: serverId,
                name: 'MCP Server',
                url,
                status: 'unregistered'
            };
            
            // If autoRegister, attempt to register with the server
            if (autoRegister) {
                try {
                    // In a real implementation, this would call the server's registration endpoint
                    server.name = 'The New Fuse MCP Server';
                    server.apiKey = 'sample-api-key';
                    server.status = 'registered';
                    
                    // Fetch available tools
                    await this.fetchServerTools(server);
                } catch (regError) {
                    console.warn('Auto-registration failed, server added as unregistered');
                }
            }
            
            // Add to our collection of servers
            this.servers.set(server.id, server);
            this.saveServers();
            this.updateStatusBar();
            
            return server;
        } catch (error: any) {
            console.error('Error registering MCP server:', error);
            throw new Error(`Failed to register MCP server at ${url}: ${error.message}`);
        }
    }
    
    /**
     * Fetch available tools from an MCP server
     */
    async fetchServerTools(server: MCPServer): Promise<void> {
        try {
            // In a real implementation, this would fetch tools from the server's API
            // Mock some tools for demonstration
            server.tools = {
                'readFile': {
                    name: 'readFile',
                    description: 'Read a file from the workspace',
                    parameters: {
                        filePath: {
                            type: 'string',
                            description: 'Path to the file'
                        }
                    }
                },
                'writeFile': {
                    name: 'writeFile',
                    description: 'Write content to a file in the workspace',
                    parameters: {
                        filePath: {
                            type: 'string',
                            description: 'Path to the file'
                        },
                        content: {
                            type: 'string',
                            description: 'Content to write'
                        }
                    }
                }
            };
        } catch (error: any) {
            console.error(`Error fetching tools from ${server.name}:`, error);
            server.status = 'unavailable';
            this.updateStatusBar();
        }
    }
    
    /**
     * Execute a tool on an MCP server
     */
    async executeTool(serverId: string, toolName: string, parameters: any): Promise<any> {
        const server = this.servers.get(serverId);
        if (!server) {
            throw new Error(`MCP server with ID ${serverId} not found`);
        }
        
        if (server.status !== 'registered') {
            throw new Error(`MCP server ${server.name} is not properly registered`);
        }
        
        try {
            // In a real implementation, this would call the server's tool execution endpoint
            // For demonstration, mock a response
            return {
                success: true,
                data: {
                    result: `Executed ${toolName} with parameters: ${JSON.stringify(parameters)}`
                }
            };
        } catch (error: any) {
            console.error(`Error executing tool ${toolName} on ${server.name}:`, error);
            throw new Error(`Tool execution failed: ${error.message}`);
        }
    }
    
    /**
     * Get all registered servers
     */
    getServers(): MCPServer[] {
        return Array.from(this.servers.values());
    }
    
    /**
     * Get all available tools from all registered servers
     */
    async getTools(): Promise<{ serverId: string; serverName: string; tool: any }[]> {
        const result: { serverId: string; serverName: string; tool: any }[] = [];
        
        for (const server of this.servers.values()) {
            if (server.status === 'registered' && server.tools) {
                for (const [toolName, tool] of Object.entries(server.tools)) {
                    result.push({
                        serverId: server.id,
                        serverName: server.name,
                        tool: {
                            name: toolName,
                            ...tool
                        }
                    });
                }
            }
        }
        
        return result;
    }
    
    /**
     * Show a QuickPick with available tools
     */
    async showToolsQuickPick(): Promise<void> {
        const tools = await this.getTools();
        
        if (tools.length === 0) {
            vscode.window.showInformationMessage('No MCP tools available');
            return;
        }
        
        const items = tools.map(t => ({
            label: t.tool.name,
            description: `[${t.serverName}]`,
            detail: t.tool.description,
            tool: t
        }));
        
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select an MCP tool'
        });
        
        if (!selected) return;
        
        // Show tool details
        this.showToolDetails(selected.tool);
    }
    
    /**
     * Show details for a specific tool
     */
    private async showToolDetails(toolInfo: { serverId: string; serverName: string; tool: any }): Promise<void> {
        const panel = vscode.window.createWebviewPanel(
            'mcpToolDetails',
            `Tool: ${toolInfo.tool.name}`,
            vscode.ViewColumn.One,
            {}
        );
        
        // Generate parameter inputs HTML
        let parametersHtml = '';
        if (toolInfo.tool.parameters) {
            parametersHtml = `
                <h2>Parameters</h2>
                <ul>
                    ${Object.entries(toolInfo.tool.parameters).map(([name, param]: [string, any]) => `
                        <li>
                            <strong>${name}</strong>: ${param.type}
                            ${param.description ? `<br><span>${param.description}</span>` : ''}
                        </li>
                    `).join('')}
                </ul>
            `;
        }
        
        panel.webview.html = `
            <html>
                <head>
                    <style>
                        body { font-family: var(--vscode-font-family); padding: 10px; }
                        h1 { color: var(--vscode-editor-foreground); }
                        pre { background-color: var(--vscode-editor-background); padding: 10px; }
                    </style>
                </head>
                <body>
                    <h1>${toolInfo.tool.name}</h1>
                    <p>${toolInfo.tool.description}</p>
                    ${parametersHtml}
                    <h2>Server</h2>
                    <p>${toolInfo.serverName}</p>
                </body>
            </html>
        `;
    }
    
    /**
     * Show a dialog to test a tool
     */
    async showToolTestDialog(): Promise<void> {
        // Get all servers
        const servers = this.getServers();
        
        if (servers.length === 0) {
            vscode.window.showInformationMessage('No MCP servers registered. Initialize MCP first.');
            return;
        }
        
        // Create server picker
        const serverItems = servers.map(server => ({
            label: server.name,
            description: `${server.status} - ${server.url}`,
            server
        }));
        
        const selected = await vscode.window.showQuickPick(serverItems, {
            placeHolder: 'Select an MCP server',
        });
        
        if (!selected) return;
        
        const server = selected.server;
        const tools = Object.entries(server.tools || {});
        
        if (tools.length === 0) {
            vscode.window.showInformationMessage(`No tools available from "${server.name}"`);
            return;
        }
        
        // Create tool picker
        const toolItems = tools.map(([name, tool]) => ({
            label: name,
            description: tool.description,
            detail: `Parameters: ${Object.keys(tool.parameters || {}).join(', ')}`,
            tool: { name, ...tool }
        }));
        
        const selectedTool = await vscode.window.showQuickPick(toolItems, {
            placeHolder: 'Select a tool to test',
        });
        
        if (!selectedTool) return;
        
        // Collect parameters
        const parameters: Record<string, any> = {};
        for (const [name, param] of Object.entries<any>(selectedTool.tool.parameters || {})) {
            const value = await vscode.window.showInputBox({
                prompt: `Enter parameter: ${name}`,
                placeHolder: param.description || '',
                ignoreFocusOut: true
            });
            
            if (value === undefined) return; // User cancelled
            parameters[name] = value;
        }
        
        // Execute the tool
        try {
            const result = await this.executeTool(server.id, selectedTool.tool.name, parameters);
            
            // Show result
            const resultPanel = vscode.window.createWebviewPanel(
                'mcpToolResult',
                `Result: ${selectedTool.tool.name}`,
                vscode.ViewColumn.One,
                {}
            );
            
            resultPanel.webview.html = `
                <html>
                    <head>
                        <style>
                            body { font-family: var(--vscode-font-family); padding: 10px; }
                            h1 { color: var(--vscode-editor-foreground); }
                            pre { background-color: var(--vscode-editor-background); padding: 10px; }
                        </style>
                    </head>
                    <body>
                        <h1>Result: ${selectedTool.tool.name}</h1>
                        <h2>Server: ${server.name}</h2>
                        <h3>Parameters</h3>
                        <pre>${JSON.stringify(parameters, null, 2)}</pre>
                        <h3>Result</h3>
                        <pre>${JSON.stringify(result, null, 2)}</pre>
                    </body>
                </html>
            `;
        } catch (error: any) {
            vscode.window.showErrorMessage(`Tool execution failed: ${error.message}`);
        }
    }
    
    /**
     * Log a message to the output channel
     */
    private log(message: string, isError: boolean = false): void {
        const timestamp = new Date().toISOString();
        const prefix = isError ? '[ERROR]' : '[INFO]';
        
        this.outputChannel.appendLine(`${prefix} ${timestamp} - ${message}`);
        
        if (isError) {
            console.error(message);
        }
    }
    
    /**
     * Show the marketplace browser
     */
    async showMarketplaceBrowser(): Promise<void> {
        try {
            // Get all servers from marketplace
            const servers = await this.marketplaceService.getAllServers();
            
            if (servers.length === 0) {
                vscode.window.showInformationMessage('No MCP servers found in the marketplace');
                return;
            }
            
            // Group servers by category for better organization
            const serversByCategory: { [category: string]: any[] } = {};
            servers.forEach(server => {
                if (!serversByCategory[server.category]) {
                    serversByCategory[server.category] = [];
                }
                serversByCategory[server.category].push({
                    label: server.name,
                    description: `v${server.version} | ${server.publisher}`,
                    detail: server.description,
                    server
                });
            });
            
            // Create category picker
            const categories = Object.keys(serversByCategory).map(category => ({
                label: `$(folder) ${category}`,
                category
            }));
            
            const selectedCategory = await vscode.window.showQuickPick(categories, {
                placeHolder: 'Select a category of MCP servers',
                matchOnDescription: true
            });
            
            if (!selectedCategory) return;
            
            // Show servers in the selected category
            const serversInCategory = serversByCategory[selectedCategory.category];
            const selectedServer = await vscode.window.showQuickPick(serversInCategory, {
                placeHolder: `Select an MCP server from ${selectedCategory.category}`,
                matchOnDescription: true
            });
            
            if (!selectedServer) return;
            
            // Show server details
            await this.showServerDetails(selectedServer.server);
        } catch (error: any) {
            this.log(`Error browsing marketplace: ${error.message}`, true);
            vscode.window.showErrorMessage(`Failed to browse MCP marketplace: ${error.message}`);
        }
    }
    
    /**
     * Show details for a specific server
     */
    async showServerDetails(server: any): Promise<void> {
        const actions = ['Add to Configuration', 'View Details', 'Cancel'];
        const selection = await vscode.window.showQuickPick(actions, {
            placeHolder: `${server.name} - ${server.description}`
        });
        
        if (!selection) return;
        
        switch (selection) {
            case 'Add to Configuration':
                await this.addServerFromMarketplace(server.id);
                break;
            case 'View Details':
                // Create a markdown document with server details
                const detailsContent = `# ${server.name} v${server.version}

**Publisher:** ${server.publisher}  
**Category:** ${server.category}  
**Rating:** ${'★'.repeat(Math.floor(server.rating))}${'☆'.repeat(5 - Math.floor(server.rating))} (${server.rating})  
**Downloads:** ${server.downloads.toLocaleString()}  
**Last Updated:** ${server.lastUpdated}

## Description
${server.description}

## Capabilities
${server.capabilities.map((cap: string) => `- ${cap}`).join('\n')}

## Installation
\`\`\`
${server.installCommand} ${server.args.join(' ')}
\`\`\`

${server.requiresConfiguration ? '## Configuration Required\n\nThis MCP server requires additional configuration.' : ''}
`;
                const doc = await vscode.workspace.openTextDocument({
                    content: detailsContent,
                    language: 'markdown'
                });
                await vscode.window.showTextDocument(doc);
                break;
            case 'Cancel':
            default:
                return;
        }
    }
    
    /**
     * Add a server from the marketplace to the local configuration
     */
    async addServerFromMarketplace(serverId?: string): Promise<boolean> {
        try {
            // If no server ID provided, show QuickPick of all servers
            if (!serverId) {
                const servers = await this.marketplaceService.getAllServers();
                const serverItems = servers.map(server => ({
                    label: server.name,
                    description: `${server.publisher} | ${server.category}`,
                    detail: server.description,
                    server
                }));
                
                const selected = await vscode.window.showQuickPick(serverItems, {
                    placeHolder: 'Select an MCP server to add',
                    matchOnDescription: true
                });
                
                if (!selected) return false;
                serverId = selected.server.id;
            }
            
            // Get server details
            const server = await this.marketplaceService.getServerDetails(serverId);
            if (!server) {
                throw new Error(`Server with ID ${serverId} not found in marketplace`);
            }
            
            // If server requires configuration, prompt user for values
            if (server.requiresConfiguration && server.configurationSchema) {
                const configItems = [];
                for (const [key, config] of Object.entries<any>(server.configurationSchema.properties)) {
                    configItems.push({
                        key,
                        description: config.description,
                        required: server.configurationSchema.required?.includes(key) || false,
                        type: config.type
                    });
                }
                
                // Prompt for each required configuration item
                const config: Record<string, string> = {};
                for (const item of configItems) {
                    if (item.required) {
                        const value = await vscode.window.showInputBox({
                            prompt: `Enter ${item.key}`,
                            placeHolder: item.description,
                            ignoreFocusOut: true
                        });
                        
                        if (value === undefined) {
                            // User cancelled
                            return false;
                        }
                        
                        config[item.key] = value;
                    }
                }
                
                // Update server args with config values
                if (Object.keys(config).length > 0) {
                    // Deep copy the server to avoid modifying the original
                    server.env = { ...config };
                }
            }
            
            // Get config path
            const configPath = await loadMcpConfigFromSettings();
            
            // Add server to config
            const success = await this.marketplaceService.addServerToConfig(server, configPath);
            
            if (success) {
                vscode.window.showInformationMessage(`Added MCP server: ${server.name}`);
                
                // Refresh the server view
                await vscode.commands.executeCommand('thefuse.mcp.refreshServerList');
                
                return true;
            } else {
                vscode.window.showInformationMessage(`MCP server ${server.name} already exists in configuration`);
                return false;
            }
        } catch (error: any) {
            this.log(`Error adding server from marketplace: ${error.message}`, true);
            vscode.window.showErrorMessage(`Failed to add MCP server: ${error.message}`);
            return false;
        }
    }
}


==============================================
FILE: ./src/vscode-extension/mcp-integration/mcp-manager.tsx
==============================================

import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { MCPClient, AgentTool, loadMcpConfigFromSettings } from './mcp-client';
import { ErrorHandler, MCPError, ErrorCode } from '../core/error-handling';
import { TelemetryService } from '../core/telemetry';
import { MCPTool } from './types';
import { WebhookManager } from '../../packages/core/src/mcp/WebhookManager';

/**
 * MCP Manager - Responsible for managing MCP client and integrating with VS Code
 */
export class MCPManager implements vscode.Disposable {
    private client: MCPClient;
    private context: vscode.ExtensionContext;
    private outputChannel: vscode.OutputChannel;
    private statusBarItem: vscode.StatusBarItem;
    private tools: AgentTool[] = [];
    private isInitialized: boolean = false;
    private inProgress: boolean = false;
    private listeners: ((tools: AgentTool[]) => void)[] = [];
    private disposables: vscode.Disposable[] = [];
    private errorHandler: ErrorHandler;
    private telemetry: TelemetryService;
    private webhookManager: WebhookManager;

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
        this.outputChannel = vscode.window.createOutputChannel('MCP Integration');
        this.client = new MCPClient(this.outputChannel);
        this.errorHandler = ErrorHandler.getInstance();
        this.telemetry = TelemetryService.getInstance();
        this.initializeStatusBar();
        this.webhookManager = new WebhookManager();

        // Register commands
        this.registerCommands();
    }

    private initializeStatusBar(): void {
        this.statusBarItem = vscode.window.createStatusBarItem(
            vscode.StatusBarAlignment.Right,
            100
        );
        this.statusBarItem.text = "MCP: $(sync~spin) Initializing...";
        this.statusBarItem.command = 'thefuse.mcp.showTools';
        this.disposables.push(this.statusBarItem);
    }

    /**
     * Initialize the MCP Manager
     */
    async initialize(): Promise<boolean> {
        if (this.isInitialized) {
            return true;
        }

        if (this.inProgress) {
            vscode.window.showInformationMessage('MCP initialization already in progress');
            return false;
        }

        this.inProgress = true;
        this.statusBarItem.text = '$(sync~spin) MCP: Initializing...';

        try {
            // Get config path
            let configPath: string;
            try {
                configPath = await loadMcpConfigFromSettings();
            } catch (error) {
                // If we couldn't determine the path, try to create a default config
                configPath = await this.createDefaultConfig();
            }

            // Check if the config file exists
            if (!fs.existsSync(configPath)) {
                this.log(`Config file not found at ${configPath}. Creating default config.`);
                configPath = await this.createDefaultConfig();
            }

            // Load server configurations
            this.log(`Loading MCP servers from ${configPath}`);
            await this.client.loadServers(configPath);

            // Start MCP client and get tools
            this.tools = await this.client.start();

            // Update status based on tool count
            if (this.tools.length > 0) {
                this.statusBarItem.text = `$(tools) MCP: ${this.tools.length} Tools`;
                this.log(`MCP initialized with ${this.tools.length} tools`);
                vscode.window.showInformationMessage(`MCP initialized with ${this.tools.length} tools`);
            } else {
                this.statusBarItem.text = '$(tools) MCP: No Tools';
                this.log('MCP initialized but no tools were found');
                vscode.window.showWarningMessage('MCP initialized but no tools were found. Check your configuration.');
            }

            this.isInitialized = true;

            // Notify listeners
            this.notifyListeners();

            return true;
        } catch (error: any) {
            this.statusBarItem.text = '$(error) MCP: Error';
            this.log(`Error initializing MCP: ${error.message}`, true);
            vscode.window.showErrorMessage(`Failed to initialize MCP: ${error.message}`);
            return false;
        } finally {
            this.inProgress = false;
        }
    }

    /**
     * Create a default MCP configuration file
     */
    private async createDefaultConfig(): Promise<string> {
        // Determine the config location
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        const configDir = workspaceFolder
            ? workspaceFolder.uri.fsPath
            : this.context.extensionPath;

        const configPath = path.join(configDir, 'mcp_config.json');

        // Create example config
        const defaultConfig = {
            mcpServers: {
                filesystem: {
                    command: 'npx',
                    args: [
                        '-y',
                        '@modelcontextprotocol/server-filesystem',
                        '--allow-dir', './data'
                    ]
                },
                shell: {
                    command: 'npx',
                    args: [
                        '-y',
                        '@modelcontextprotocol/server-shell',
                        '--allow-commands', 'ls,cat,grep,find,echo,pwd'
                    ]
                },
                http: {
                    command: 'npx',
                    args: [
                        '-y',
                        '@modelcontextprotocol/server-http',
                        '--allow-hosts', 'api.github.com,api.openai.com'
                    ]
                },
                'code-analysis': {
                    command: 'npx',
                    args: [
                        '-y',
                        '@modelcontextprotocol/server-code-analysis',
                        '--allow-dir', './'
                    ]
                },
                'vector-db': {
                    command: 'npx',
                    args: [
                        '-y',
                        '@modelcontextprotocol/server-vector-db',
                        '--db-path', './data/vector-db'
                    ]
                }
            }
        };

        // Write the default config
        await fs.promises.writeFile(
            configPath,
            JSON.stringify(defaultConfig, null, 2),
            'utf8'
        );

        this.log(`Created default MCP config at ${configPath}`);

        // Also create the data directory if it doesn't exist
        const dataDir = path.join(configDir, 'data');
        if (!fs.existsSync(dataDir)) {
            await fs.promises.mkdir(dataDir, { recursive: true });

            // Add a README to the data directory
            const readmePath = path.join(dataDir, 'README.md');
            const readmeContent = `# MCP FileSystem Data Directory

This directory is used by the MCP filesystem tool.
Files placed here will be accessible to the AI agent through the filesystem MCP server.`;

            await fs.promises.writeFile(readmePath, readmeContent, 'utf8');
        }

        return configPath;
    }

    /**
     * Register commands related to MCP
     */
    private registerCommands() {
        // Command to show available MCP tools
        this.context.subscriptions.push(
            vscode.commands.registerCommand('thefuse.mcp.showTools', () => {
                this.showToolsQuickPick();
            })
        );

        // Command to manually initialize MCP
        this.context.subscriptions.push(
            vscode.commands.registerCommand('thefuse.mcp.initialize', () => {
                return this.initialize();
            })
        );

        // Command to test a specific tool
        this.context.subscriptions.push(
            vscode.commands.registerCommand('thefuse.mcp.testTool', async (toolName?: string) => {
                return this.testTool(toolName);
            })
        );

        // Command to execute a tool
        this.context.subscriptions.push(
            vscode.commands.registerCommand('thefuse.mcp.executeTool', async (toolName: string, args: Record<string, any>) => {
                return this.executeTool(toolName, args);
            })
        );

        // Command to open the MCP Tools UI
        this.context.subscriptions.push(
            vscode.commands.registerCommand('thefuse.mcp.openToolsUI', () => {
                return this.openToolsUI();
            })
        );

        // Command to manage webhooks
        this.context.subscriptions.push(
            vscode.commands.registerCommand('thefuse.mcp.manageWebhooks', async (toolName?: string) => {
                return this.manageWebhooks(toolName);
            })
        );

        // Command to test webhook delivery
        this.context.subscriptions.push(
            vscode.commands.registerCommand('thefuse.mcp.testWebhook', async (toolName?: string, webhookId?: string) => {
                return this.testWebhook(toolName, webhookId);
            })
        );
    }

    /**
     * Show a QuickPick of available tools
     */
    private async showToolsQuickPick() {
        if (!this.isInitialized) {
            const shouldInit = await vscode.window.showWarningMessage(
                'MCP is not initialized. Do you want to initialize it now?',
                'Yes', 'No'
            );

            if (shouldInit === 'Yes') {
                const success = await this.initialize();
                if (!success) return;
            } else {
                return;
            }
        }

        if (this.tools.length === 0) {
            vscode.window.showInformationMessage('No MCP tools available');
            return;
        }

        const items = this.tools.map(tool => ({
            label: tool.name,
            description: tool.description,
            detail: `Parameters: ${JSON.stringify(tool.parameters)}`,
            tool
        }));

        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select an MCP tool to test',
            matchOnDescription: true
        });

        if (selected) {
            await this.testTool(selected.tool.name);
        }
    }

    /**
     * Test a specific tool
     */
    private async testTool(toolName?: string) {
        if (!this.isInitialized) {
            vscode.window.showWarningMessage('MCP is not initialized. Initialize it first.');
            return null;
        }

        if (!toolName) {
            // If no tool name provided, show QuickPick
            await this.showToolsQuickPick();
            return null;
        }

        // Find the tool
        const tool = this.tools.find(t => t.name === toolName);
        if (!tool) {
            vscode.window.showErrorMessage(`Tool "${toolName}" not found`);
            return null;
        }

        try {
            // Show an input box for JSON arguments
            const inputArgs = await vscode.window.showInputBox({
                prompt: `Enter arguments for "${tool.name}" as JSON`,
                placeHolder: '{}'
            });

            if (inputArgs === undefined) {
                return null; // User cancelled
            }

            // Parse the arguments
            const args = inputArgs ? JSON.parse(inputArgs) : {};

            // Execute the tool
            this.log(`Testing tool "${tool.name}" with args: ${JSON.stringify(args)}`);
            const result = await tool.execute(args);

            // Show the result
            const resultDoc = await vscode.workspace.openTextDocument({
                content: JSON.stringify(result, null, 2),
                language: 'json'
            });

            await vscode.window.showTextDocument(resultDoc);
            return result;
        } catch (error: any) {
            this.log(`Error testing tool "${tool.name}": ${error.message}`, true);
            vscode.window.showErrorMessage(`Error testing tool: ${error.message}`);
            return null;
        }
    }

    /**
     * Execute a tool with the given arguments
     */
    async executeTool(toolName: string, args: Record<string, any>): Promise<any> {
        if (!this.isInitialized) {
            throw new Error('MCP is not initialized');
        }

        const tool = this.tools.find(t => t.name === toolName);
        if (!tool) {
            throw new Error(`Tool "${toolName}" not found`);
        }

        try {
            this.log(`Executing tool "${tool.name}" with args: ${JSON.stringify(args)}`);
            const result = await tool.execute(args);
            return result;
        } catch (error: any) {
            this.log(`Error executing tool "${tool.name}": ${error.message}`, true);
            throw error;
        }
    }

    /**
     * Open the enhanced MCP Tools UI
     */
    private async openToolsUI() {
        const panel = vscode.window.createWebviewPanel(
            'mcpToolsUI',
            'MCP Tools Dashboard',
            vscode.ViewColumn.One,
            {
                enableScripts: true,
                retainContextWhenHidden: true
            }
        );

        // Get current tools and webhooks
        const tools = this.tools;
        const webhooks = this.tools.reduce((acc, tool) => ({
            ...acc,
            [tool.name]: this.webhookManager.getWebhooks(tool.name)
        }), {});

        // Set up the HTML content
        panel.webview.html = this.getToolsUIHtml(panel.webview, tools, webhooks);

        // Handle messages from the webview
        panel.webview.onDidReceiveMessage(async message => {
            try {
                switch (message.command) {
                    case 'executeTool':
                        await this.executeTool(message.toolName, message.params);
                        break;
                    case 'registerWebhook':
                        await this.webhookManager.registerWebhook(message.toolName, message.config);
                        break;
                    case 'removeWebhook':
                        await this.webhookManager.removeWebhook(message.toolName, message.webhookId);
                        break;
                }
            } catch (error) {
                vscode.window.showErrorMessage(error.message);
            }
        });
    }

    /**
     * Manage webhooks for a tool
     */
    private async manageWebhooks(toolName?: string) {
        if (!toolName) {
            const tools = this.tools.map(t => ({
                label: t.name,
                description: t.description
            }));

            const selected = await vscode.window.showQuickPick(tools, {
                placeHolder: 'Select a tool to manage webhooks'
            });

            if (!selected) return;
            toolName = selected.label;
        }

        const webhooks = this.webhookManager.getWebhooks(toolName);
        const action = await vscode.window.showQuickPick([
            { label: 'Add Webhook', value: 'add' },
            { label: 'Remove Webhook', value: 'remove', description: `${webhooks.length} configured` },
            { label: 'Test Webhook', value: 'test' }
        ], {
            placeHolder: `Manage webhooks for ${toolName}`
        });

        if (!action) return;

        switch (action.value) {
            case 'add':
                await this.addWebhook(toolName);
                break;
            case 'remove':
                await this.removeWebhook(toolName);
                break;
            case 'test':
                await this.testWebhook(toolName);
                break;
        }
    }

    /**
     * Add a new webhook
     */
    private async addWebhook(toolName: string) {
        const url = await vscode.window.showInputBox({
            prompt: 'Enter webhook URL',
            placeHolder: 'https://example.com/webhook'
        });

        if (!url) return;

        const events = await vscode.window.showInputBox({
            prompt: 'Enter events to trigger webhook (comma-separated)',
            placeHolder: 'success, error, *',
            value: '*'
        });

        if (!events) return;

        const secret = await vscode.window.showInputBox({
            prompt: 'Enter webhook secret (optional)',
            password: true
        });

        await this.webhookManager.registerWebhook(toolName, {
            url,
            events: events.split(',').map(e => e.trim()),
            secret
        });

        vscode.window.showInformationMessage(`Webhook registered for ${toolName}`);
    }

    /**
     * Remove a webhook
     */
    private async removeWebhook(toolName: string) {
        const webhooks = this.webhookManager.getWebhooks(toolName);
        if (webhooks.length === 0) {
            vscode.window.showInformationMessage(`No webhooks configured for ${toolName}`);
            return;
        }

        const selected = await vscode.window.showQuickPick(
            webhooks.map(w => ({
                label: w.url,
                description: `Events: ${w.events.join(', ')}`
            })),
            { placeHolder: 'Select webhook to remove' }
        );

        if (!selected) return;

        await this.webhookManager.removeWebhook(toolName, selected.label);
        vscode.window.showInformationMessage(`Webhook removed from ${toolName}`);
    }

    /**
     * Test webhook delivery
     */
    private async testWebhook(toolName?: string, webhookId?: string) {
        if (!toolName) {
            const tools = this.tools.map(t => ({
                label: t.name,
                description: t.description
            }));

            const selected = await vscode.window.showQuickPick(tools, {
                placeHolder: 'Select a tool to test webhook'
            });

            if (!selected) return;
            toolName = selected.label;
        }

        const webhooks = this.webhookManager.getWebhooks(toolName);
        if (webhooks.length === 0) {
            vscode.window.showInformationMessage(`No webhooks configured for ${toolName}`);
            return;
        }

        if (!webhookId) {
            const selected = await vscode.window.showQuickPick(
                webhooks.map(w => ({
                    label: w.url,
                    description: `Events: ${w.events.join(', ')}`
                })),
                { placeHolder: 'Select webhook to test' }
            );

            if (!selected) return;
            webhookId = selected.label;
        }

        try {
            await this.webhookManager.triggerWebhooks(toolName, 'test', {
                message: 'Test webhook delivery',
                timestamp: Date.now()
            });
            vscode.window.showInformationMessage('Webhook test triggered successfully');
        } catch (error) {
            vscode.window.showErrorMessage(`Webhook test failed: ${error.message}`);
        }
    }

    /**
     * Get all available tools
     */
    getTools(): AgentTool[] {
        return [...this.tools];
    }

    /**
     * Add a listener for tool changes
     */
    onToolsChanged(listener: (tools: AgentTool[]) => void): vscode.Disposable {
        this.listeners.push(listener);

        // Return a disposable to remove the listener
        return {
            dispose: () => {
                const index = this.listeners.indexOf(listener);
                if (index !== -1) {
                    this.listeners.splice(index, 1);
                }
            }
        };
    }

    /**
     * Notify all listeners of tool changes
     */
    private notifyListeners() {
        for (const listener of this.listeners) {
            listener(this.getTools());
        }
    }

    /**
     * Log a message to the output channel
     */
    private log(message: string, isError: boolean = false): void {
        const timestamp = new Date().toISOString();
        const prefix = '[MCPManager]';

        if (isError) {
            this.outputChannel.appendLine(`${timestamp} ${prefix} ERROR: ${message}`);
        } else {
            this.outputChannel.appendLine(`${timestamp} ${prefix} ${message}`);
        }
    }

    /**
     * Dispose of resources
     */
    async dispose() {
        try {
            // Cleanup resources
            for (const disposable of this.disposables) {
                disposable.dispose();
            }

            // Cleanup MCP resources
            await this.client.cleanup();

            this.telemetry.trackEvent('mcp_disposed');
            await this.telemetry.flush();

        } catch (error) {
            await this.errorHandler.handleError(error, 'MCP disposal');
        }
    }
}



==============================================
FILE: ./src/vscode-extension/mcp-integration/mcp-marketplace-commands.ts
==============================================

import * as vscode from 'vscode';

/**
 * Command to open the MCP server marketplace
 */
export function registerMCPMarketplaceCommands(context: vscode.ExtensionContext) {
  // Register the command to open the marketplace
  context.subscriptions.push(
    vscode.commands.registerCommand('thefuse.openMCPMarketplace', () => {
      MCPMarketplacePanel.createOrShow(context);
    })
  );
}

/**
 * MCP Marketplace Panel
 */
class MCPMarketplacePanel {
  public static currentPanel: MCPMarketplacePanel | undefined;
  private readonly _panel: vscode.WebviewPanel;
  private readonly _extensionUri: vscode.Uri;
  private _disposables: vscode.Disposable[] = [];

  public static createOrShow(context: vscode.ExtensionContext) {
    const column = vscode.window.activeTextEditor
      ? vscode.window.activeTextEditor.viewColumn
      : undefined;

    // If we already have a panel, show it
    if (MCPMarketplacePanel.currentPanel) {
      MCPMarketplacePanel.currentPanel._panel.reveal(column);
      return;
    }

    // Otherwise, create a new panel
    const panel = vscode.window.createWebviewPanel(
      'mcpMarketplace',
      'MCP Server Marketplace',
      column || vscode.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          vscode.Uri.joinPath(context.extensionUri, 'media')
        ]
      }
    );

    MCPMarketplacePanel.currentPanel = new MCPMarketplacePanel(panel, context.extensionUri);
  }

  private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {
    this._panel = panel;
    this._extensionUri = extensionUri;

    // Set the webview's initial html content
    this._update();

    // Listen for when the panel is disposed
    // This happens when the user closes the panel or when the panel is closed programmatically
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

    // Update the content based on view changes
    this._panel.onDidChangeViewState(
      e => {
        if (this._panel.visible) {
          this._update();
        }
      },
      null,
      this._disposables
    );

    // Handle messages from the webview
    this._panel.webview.onDidReceiveMessage(
      async message => {
        switch (message.command) {
          case 'viewDetails':
            await this._showServerDetails(message.serverId);
            break;
          case 'installServer':
            await this._installServer(message.serverId);
            break;
          case 'search':
            await this._searchServers(message.query);
            break;
          case 'refresh':
            await this._refreshServers();
            break;
          case 'openDocs':
            await this._openServerDocs();
            break;
        }
      },
      null,
      this._disposables
    );
  }

  private async _showServerDetails(serverId: string) {
    // Fetch server details
    const server = await this._fetchServerDetails(serverId);
    if (!server) {
      vscode.window.showErrorMessage(`Server with ID ${serverId} not found`);
      return;
    }

    // Create a new panel for server details
    const panel = vscode.window.createWebviewPanel(
      'mcpServerDetails',
      `${server.name} - MCP Server`,
      vscode.ViewColumn.One,
      {
        enableScripts: true
      }
    );

    panel.webview.html = getServerDetailsWebviewHtml(panel.webview, { extensionUri: this._extensionUri }, server);

    // Handle messages from the webview
    panel.webview.onDidReceiveMessage(
      async message => {
        switch (message.command) {
          case 'installServer':
            await this._installServer(server.id);
            break;
          case 'openDocs':
            vscode.env.openExternal(vscode.Uri.parse(server.documentationUrl));
            break;
        }
      },
      undefined,
      this._disposables
    );
  }

  private async _installServer(serverId: string) {
    try {
      // Fetch server details
      const server = await this._fetchServerDetails(serverId);
      if (!server) {
        vscode.window.showErrorMessage(`Server with ID ${serverId} not found`);
        return;
      }

      // Check if configuration is required
      let config = {};
      if (server.requiresConfiguration) {
        // Prompt for configuration
        const configValues = await this._promptForConfiguration(server);
        if (!configValues) {
          // User cancelled
          return;
        }
        config = configValues;
      }

      // Show progress during installation
      await vscode.window.withProgress(
        {
          location: vscode.ProgressLocation.Notification,
          title: `Installing ${server.name}`,
          cancellable: false
        },
        async progress => {
          progress.report({ increment: 0, message: 'Starting installation...' });

          // Simulate installation steps
          await new Promise(resolve => setTimeout(resolve, 1000));
          progress.report({ increment: 30, message: 'Downloading server...' });

          await new Promise(resolve => setTimeout(resolve, 1500));
          progress.report({ increment: 30, message: 'Installing dependencies...' });

          await new Promise(resolve => setTimeout(resolve, 1000));
          progress.report({ increment: 30, message: 'Configuring server...' });

          await new Promise(resolve => setTimeout(resolve, 500));
          progress.report({ increment: 10, message: 'Finalizing installation...' });

          // Complete the installation
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      );

      vscode.window.showInformationMessage(`Successfully installed ${server.name}`);

      // Refresh the server list
      this._refreshServers();
    } catch (error) {
      vscode.window.showErrorMessage(`Failed to install server: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private async _promptForConfiguration(server: any): Promise<any | undefined> {
    // This would be replaced with actual configuration prompts based on the server's schema
    const config: Record<string, any> = {};

    if (!server.configurationSchema || !server.configurationSchema.properties) {
      return config;
    }

    for (const [key, prop] of Object.entries<any>(server.configurationSchema.properties)) {
      const isRequired = server.configurationSchema.required?.includes(key) || false;
      const value = await vscode.window.showInputBox({
        prompt: `Enter ${key}${isRequired ? ' (required)' : ''}`,
        placeHolder: prop.description || key,
        ignoreFocusOut: true,
        password: prop.format === 'password'
      });

      if (isRequired && !value) {
        vscode.window.showErrorMessage(`${key} is required`);
        return undefined;
      }

      if (value !== undefined) {
        config[key] = value;
      }
    }

    return config;
  }

  private async _searchServers(query: string) {
    // This would be replaced with actual search functionality
    const servers = await this._fetchServers();
    const filteredServers = servers.filter(server =>
      server.name.toLowerCase().includes(query.toLowerCase()) ||
      server.description.toLowerCase().includes(query.toLowerCase()) ||
      server.publisher.toLowerCase().includes(query.toLowerCase())
    );

    // Update the webview with filtered servers
    this._panel.webview.postMessage({
      command: 'updateServers',
      servers: filteredServers
    });
  }

  private async _refreshServers() {
    const servers = await this._fetchServers();
    this._panel.webview.postMessage({
      command: 'updateServers',
      servers
    });
  }

  private async _openServerDocs() {
    // This would open documentation for the currently viewed server
    vscode.env.openExternal(vscode.Uri.parse('https://example.com/docs'));
  }

  private async _fetchServers(): Promise<any[]> {
    // This would be replaced with actual API calls to fetch servers
    return [
      {
        id: 'mcp-server-1',
        name: 'MCP Standard Server',
        publisher: 'The New Fuse',
        version: '1.0.0',
        description: 'Standard MCP server with support for all core MCP features',
        rating: 4.5,
        downloads: 12500,
        category: 'Core',
        capabilities: ['Tool Calling', 'Agent Communication', 'Workflow Execution'],
        lastUpdated: '2023-12-15',
        installCommand: 'npm install',
        args: ['-g', '@the-new-fuse/mcp-server'],
        requiresConfiguration: false
      },
      {
        id: 'mcp-server-2',
        name: 'MCP Enterprise Server',
        publisher: 'The New Fuse',
        version: '1.2.0',
        description: 'Enterprise-grade MCP server with advanced security and scaling features',
        rating: 4.8,
        downloads: 8700,
        category: 'Enterprise',
        capabilities: ['Tool Calling', 'Agent Communication', 'Workflow Execution', 'Rate Limiting', 'Advanced Auth'],
        lastUpdated: '2023-12-20',
        installCommand: 'npm install',
        args: ['-g', '@the-new-fuse/mcp-enterprise-server'],
        requiresConfiguration: true,
        configurationSchema: {
          properties: {
            apiKey: {
              type: 'string',
              description: 'API Key for authentication',
              format: 'password'
            },
            port: {
              type: 'number',
              description: 'Port to run the server on',
              default: 3000
            }
          },
          required: ['apiKey']
        }
      },
      {
        id: 'mcp-server-3',
        name: 'MCP Development Server',
        publisher: 'The New Fuse',
        version: '0.9.0',
        description: 'Lightweight MCP server for local development with hot reloading',
        rating: 4.2,
        downloads: 15800,
        category: 'Development',
        capabilities: ['Tool Calling', 'Agent Communication', 'Hot Reloading', 'Debug Mode'],
        lastUpdated: '2023-12-10',
        installCommand: 'npm install',
        args: ['-g', '@the-new-fuse/mcp-dev-server'],
        requiresConfiguration: false
      }
    ];
  }

  private async _fetchServerDetails(serverId: string): Promise<any | undefined> {
    const servers = await this._fetchServers();
    return servers.find(server => server.id === serverId);
  }

  private _update() {
    const webview = this._panel.webview;
    this._panel.title = "MCP Server Marketplace";
    this._panel.webview.html = this._getHtmlForWebview(webview);
    this._refreshServers();
  }

  private _getHtmlForWebview(webview: vscode.Webview) {
    return `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>MCP Server Marketplace</title>
        <style>
            body {
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
                padding: 20px;
            }
            .header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
            }
            .search-container {
                display: flex;
                margin-bottom: 20px;
            }
            .search-container input {
                flex-grow: 1;
                padding: 8px;
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border: 1px solid var(--vscode-input-border);
            }
            .search-container button {
                margin-left: 10px;
            }
            .server-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 20px;
            }
            .server-card {
                background-color: var(--vscode-editor-inactiveSelectionBackground);
                border-radius: 5px;
                padding: 15px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
            .server-card h3 {
                margin-top: 0;
                margin-bottom: 5px;
            }
            .publisher {
                color: var(--vscode-descriptionForeground);
                font-size: 12px;
                margin-bottom: 10px;
            }
            .description {
                margin-bottom: 15px;
                font-size: 14px;
            }
            .meta {
                display: flex;
                justify-content: space-between;
                font-size: 12px;
                color: var(--vscode-descriptionForeground);
                margin-bottom: 15px;
            }
            .actions {
                display: flex;
                justify-content: space-between;
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                border: none;
                padding: 8px 12px;
                cursor: pointer;
                border-radius: 2px;
            }
            button.secondary {
                background-color: transparent;
                border: 1px solid var(--vscode-button-background);
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
            .rating {
                color: #e6b800;
            }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>MCP Server Marketplace</h1>
            <button id="refresh-button">Refresh</button>
        </div>
        
        <div class="search-container">
            <input type="text" id="search-input" placeholder="Search for MCP servers...">
            <button id="search-button">Search</button>
        </div>
        
        <div id="serverGrid" class="server-grid">
            <p>Loading servers...</p>
        </div>
        
        <script>
            const vscode = acquireVsCodeApi();
            
            // Handle refresh button
            document.getElementById('refresh-button').addEventListener('click', () => {
                vscode.postMessage({ command: 'refresh' });
            });
            
            // Handle search
            document.getElementById('search-button').addEventListener('click', () => {
                const query = document.getElementById('search-input').value;
                vscode.postMessage({ command: 'search', query });
            });
            
            // Handle enter key in search input
            document.getElementById('search-input').addEventListener('keyup', (event) => {
                if (event.key === 'Enter') {
                    const query = document.getElementById('search-input').value;
                    vscode.postMessage({ command: 'search', query });
                }
            });
            
            // Handle messages from the extension
            window.addEventListener('message', (event) => {
                const message = event.data;
                
                switch (message.command) {
                    case 'updateServers':
                        updateServerGrid(message.servers);
                        break;
                }
            });
            
            function updateServerGrid(servers) {
                const serverGrid = document.getElementById('serverGrid');
                
                if (servers.length === 0) {
                    serverGrid.innerHTML = '<p>No servers found matching your search.</p>';
                    return;
                }
                
                const serverItems = servers.map(server => \`
                    <div class="server-card">
                        <h3>\${server.name}</h3>
                        <p class="publisher">\${server.publisher} | v\${server.version}</p>
                        <p class="description">\${server.description}</p>
                        <div class="meta">
                            <span class="rating">★ \${server.rating.toFixed(1)}</span>
                            <span class="downloads">\${server.downloads.toLocaleString()} downloads</span>
                        </div>
                        <div class="actions">
                            <button class="view-details" onclick="viewDetails('\${server.id}')">View Details</button>
                            <button class="install" onclick="installServer('\${server.id}')">Install</button>
                        </div>
                    </div>
                \`).join('');
                
                serverGrid.innerHTML = serverItems;
            }
        </script>
    </body>
    </html>
    `;
  }

  public dispose() {
    MCPMarketplacePanel.currentPanel = undefined;

    // Clean up our resources
    this._panel.dispose();

    while (this._disposables.length) {
      const x = this._disposables.pop();
      if (x) {
        x.dispose();
      }
    }
  }
}

/**
 * Get HTML for server details webview
 */
function getServerDetailsWebviewHtml(webview: vscode.Webview, context: vscode.ExtensionContext, server: any): string {
    const capabilities = server.capabilities.map((cap: string) => `<li>${cap}</li>`).join('');
    
    let configSection = '';
    if (server.requiresConfiguration && server.configurationSchema) {
        const configProps = Object.entries(server.configurationSchema.properties).map(([key, prop]: [string, any]) => {
            const isRequired = server.configurationSchema.required?.includes(key) || false;
            return `
                <tr>
                    <td><strong>${key}</strong>${isRequired ? ' <span class="required">*</span>' : ''}</td>
                    <td>${prop.description || ''}</td>
                    <td>${prop.type}</td>
                </tr>
            `;
        }).join('');
        
        configSection = `
            <h3>Configuration Required</h3>
            <p>This server requires the following configuration during installation:</p>
            <table class="config-table">
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Description</th>
                        <th>Type</th>
                    </tr>
                </thead>
                <tbody>
                    ${configProps}
                </tbody>
            </table>
        `;
    }
    
    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${server.name}</title>
        <style>
            body {
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                background-color: var(--vscode-editor-background);
                padding: 20px;
                line-height: 1.5;
            }
            .header {
                margin-bottom: 20px;
            }
            .publisher {
                color: var(--vscode-descriptionForeground);
            }
            .description {
                margin-bottom: 20px;
            }
            .meta {
                display: flex;
                justify-content: space-between;
                margin-bottom: 20px;
                font-size: 14px;
                color: var(--vscode-descriptionForeground);
            }
            .command {
                background-color: var(--vscode-textCodeBlock-background);
                padding: 12px;
                border-radius: 4px;
                font-family: monospace;
                overflow-x: auto;
                margin-bottom: 20px;
            }
            .capabilities {
                margin-bottom: 20px;
            }
            .config-table {
                width: 100%;
                border-collapse: collapse;
                margin-bottom: 20px;
            }
            .config-table th, .config-table td {
                border: 1px solid var(--vscode-panel-border);
                padding: 8px;
                text-align: left;
            }
            .config-table th {
                background-color: var(--vscode-list-hoverBackground);
            }
            .required {
                color: var(--vscode-errorForeground);
            }
            .actions {
                display: flex;
                gap: 16px;
                margin-top: 20px;
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                border: none;
                padding: 8px 16px;
                cursor: pointer;
                border-radius: 2px;
            }
            button.secondary {
                background-color: transparent;
                border: 1px solid var(--vscode-button-background);
            }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>${server.name}</h1>
            <div class="publisher">
                <span>${server.publisher}</span> | 
                <span>Version ${server.version}</span> | 
                <span>${server.category}</span>
            </div>
        </div>
        
        <div class="description">
            <h3>Description</h3>
            <p>${server.description}</p>
        </div>
        
        <div class="capabilities">
            <h3>Capabilities</h3>
            <ul>
                ${capabilities}
            </ul>
        </div>
        
        <div class="installation">
            <h3>Installation Command</h3>
            <div class="command">
                ${server.installCommand} ${server.args.join(' ')}
            </div>
        </div>
        
        ${configSection}
        
        <div class="meta">
            <span>★ ${server.rating.toFixed(1)}/5.0</span>
            <span>${server.downloads.toLocaleString()} downloads</span>
            <span>Last updated: ${server.lastUpdated}</span>
        </div>
        
        <div class="actions">
            <button id="installButton">Install Server</button>
            <button id="docsButton" class="secondary">View Documentation</button>
        </div>
        
        <script>
            const vscode = acquireVsCodeApi();
            
            document.getElementById('installButton').addEventListener('click', () => {
                vscode.postMessage({ command: 'installServer' });
            });
            
            document.getElementById('docsButton').addEventListener('click', () => {
                vscode.postMessage({ command: 'openDocs' });
            });
        </script>
    </body>
    </html>
    `;
}



==============================================
FILE: ./src/vscode-extension/mcp-integration/mcp-marketplace-view.ts
==============================================

import * as vscode from 'vscode';
import { MCPMarketplaceService, MCPMarketplaceServer } from './mcp-marketplace';
import * as path from 'path';
import * as fs from 'fs';

/**
 * Tree item representing a marketplace category
 */
class MarketplaceCategoryTreeItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly servers: MCPMarketplaceServer[]
    ) {
        super(
            label,
            vscode.TreeItemCollapsibleState.Expanded
        );
        this.contextValue = 'marketplaceCategory';
        this.iconPath = new vscode.ThemeIcon('symbol-folder');
    }
}

/**
 * Tree item representing a marketplace server
 */
class MarketplaceServerTreeItem extends vscode.TreeItem {
    constructor(
        public readonly server: MCPMarketplaceServer
    ) {
        super(
            server.name,
            vscode.TreeItemCollapsibleState.Collapsed
        );
        this.description = `v${server.version} by ${server.publisher}`;
        this.tooltip = new vscode.MarkdownString(
            `# ${server.name}\n\n` +
            `${server.description}\n\n` +
            `- **Version:** ${server.version}\n` +
            `- **Publisher:** ${server.publisher}\n` +
            `- **Category:** ${server.category}\n` +
            `- **Rating:** ${'★'.repeat(Math.round(server.rating))}\n` +
            `- **Downloads:** ${server.downloads.toLocaleString()}\n\n` +
            `## Capabilities\n` +
            server.capabilities.map(cap => `- ${cap}`).join('\n')
        );
        this.contextValue = 'marketplaceServer';
        
        // Set icon based on server category
        let iconName: string;
        switch (server.category.toLowerCase()) {
            case 'development tools':
                iconName = 'tools';
                break;
            case 'file management':
                iconName = 'file-directory';
                break;
            case 'system tools':
                iconName = 'terminal';
                break;
            case 'web':
                iconName = 'globe';
                break;
            case 'databases':
                iconName = 'database';
                break;
            default:
                iconName = 'package';
                break;
        }
        this.iconPath = new vscode.ThemeIcon(iconName);
    }
}

/**
 * Tree item representing a server detail (property)
 */
class ServerDetailTreeItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly value: string
    ) {
        super(label);
        this.description = value;
        this.contextValue = 'marketplaceServerDetail';
    }
}

/**
 * Tree data provider for the MCP Marketplace view
 */
export class MCPMarketplaceViewProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<vscode.TreeItem | undefined | null | void> = new vscode.EventEmitter<vscode.TreeItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<vscode.TreeItem | undefined | null | void> = this._onDidChangeTreeData.event;
    
    private marketplaceService: MCPMarketplaceService;
    private servers: MCPMarketplaceServer[] = [];
    private searchQuery: string = '';
    
    constructor(
        private readonly outputChannel: vscode.OutputChannel,
        private readonly extensionContext: vscode.ExtensionContext
    ) {
        this.marketplaceService = new MCPMarketplaceService(outputChannel);
        this.refreshServers();
    }
    
    /**
     * Refreshes the server list from the marketplace
     */
    async refreshServers(): Promise<void> {
        try {
            if (this.searchQuery) {
                this.servers = await this.marketplaceService.searchServers(this.searchQuery);
            } else {
                this.servers = await this.marketplaceService.getAllServers();
            }
            this._onDidChangeTreeData.fire();
        } catch (error) {
            this.outputChannel.appendLine(`[MCP Marketplace] Error refreshing servers: ${error}`);
            vscode.window.showErrorMessage(`Failed to load MCP servers: ${error}`);
        }
    }
    
    /**
     * Sets a search query to filter servers
     */
    setSearchQuery(query: string): void {
        this.searchQuery = query;
        this.refreshServers();
    }
    
    /**
     * Clears the search query
     */
    clearSearch(): void {
        this.searchQuery = '';
        this.refreshServers();
    }
    
    /**
     * Gets the parent of a tree item
     */
    getParent(element: vscode.TreeItem): vscode.ProviderResult<vscode.TreeItem> {
        return null;
    }
    
    /**
     * Gets tree item for a given element
     */
    getTreeItem(element: vscode.TreeItem): vscode.TreeItem {
        return element;
    }
    
    /**
     * Gets child elements for a given element or root
     */
    getChildren(element?: vscode.TreeItem): vscode.ProviderResult<vscode.TreeItem[]> {
        if (!element) {
            if (this.searchQuery) {
                // When searching, show flat list of servers
                return this.servers.map(server => new MarketplaceServerTreeItem(server));
            } else {
                // Otherwise organize by category
                const categories = new Map<string, MCPMarketplaceServer[]>();
                
                // Group servers by category
                for (const server of this.servers) {
                    if (!categories.has(server.category)) {
                        categories.set(server.category, []);
                    }
                    categories.get(server.category)!.push(server);
                }
                
                // Sort categories alphabetically
                return Array.from(categories.entries())
                    .sort(([a], [b]) => a.localeCompare(b))
                    .map(([category, servers]) => new MarketplaceCategoryTreeItem(category, servers));
            }
        }
        
        if (element instanceof MarketplaceCategoryTreeItem) {
            // Show servers in this category
            return element.servers.map(server => new MarketplaceServerTreeItem(server));
        }
        
        if (element instanceof MarketplaceServerTreeItem) {
            // Show details for this server
            const server = element.server;
            const details: ServerDetailTreeItem[] = [];
            
            details.push(new ServerDetailTreeItem('Description', server.description));
            details.push(new ServerDetailTreeItem('Version', server.version));
            details.push(new ServerDetailTreeItem('Publisher', server.publisher));
            details.push(new ServerDetailTreeItem('Rating', '★'.repeat(Math.round(server.rating))));
            details.push(new ServerDetailTreeItem('Downloads', server.downloads.toLocaleString()));
            details.push(new ServerDetailTreeItem('Last Updated', server.lastUpdated));
            details.push(new ServerDetailTreeItem('Capabilities', server.capabilities.join(', ')));
            
            return details;
        }
        
        return [];
    }
    
    /**
     * Installs a server from the marketplace
     */
    async installServer(serverItem: MarketplaceServerTreeItem): Promise<void> {
        try {
            this.outputChannel.appendLine(`[MCP Marketplace] Installing server: ${serverItem.server.name}`);
            
            // Show progress notification
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: `Installing MCP Server: ${serverItem.server.name}`,
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0, message: 'Preparing installation...' });
                
                // Check if we need to create a definitions directory
                const definitionsDir = path.join(this.extensionContext.extensionPath, 'server-definitions');
                if (!fs.existsSync(definitionsDir)) {
                    fs.mkdirSync(definitionsDir, { recursive: true });
                }
                
                // Download or create server definition files
                progress.report({ increment: 30, message: 'Downloading server definition...' });
                await this.marketplaceService.downloadServerDefinition(serverItem.server, definitionsDir);
                
                // Get the MCP config path
                const configPath = path.join(this.extensionContext.globalStorageUri.fsPath, 'mcp-config.json');
                
                // Make sure the directory exists
                const configDir = path.dirname(configPath);
                if (!fs.existsSync(configDir)) {
                    fs.mkdirSync(configDir, { recursive: true });
                }
                
                // Create the config file if it doesn't exist
                if (!fs.existsSync(configPath)) {
                    fs.writeFileSync(configPath, JSON.stringify({ servers: [] }, null, 2));
                }
                
                // Add server to the configuration
                progress.report({ increment: 60, message: 'Adding server to configuration...' });
                await this.marketplaceService.addServerToConfig(serverItem.server, configPath);
                
                progress.report({ increment: 100, message: 'Installation complete' });
            });
            
            // Show success message with button to open MCP panel
            const result = await vscode.window.showInformationMessage(
                `Successfully installed MCP server: ${serverItem.server.name}`,
                'Open MCP Panel'
            );
            
            if (result === 'Open MCP Panel') {
                // Execute command to show MCP panel
                await vscode.commands.executeCommand('thefuse.mcp.showTools');
            }
        } catch (error) {
            this.outputChannel.appendLine(`[MCP Marketplace] Error installing server: ${error}`);
            vscode.window.showErrorMessage(`Failed to install MCP server: ${error}`);
        }
    }
}

/**
 * Registers the MCP marketplace view
 */
export function registerMCPMarketplaceView(context: vscode.ExtensionContext, outputChannel: vscode.OutputChannel): vscode.TreeView<vscode.TreeItem> {
    const marketplaceViewProvider = new MCPMarketplaceViewProvider(outputChannel, context);
    
    // Register the tree data provider
    const treeView = vscode.window.createTreeView('thefuse-mcp-marketplace', {
        treeDataProvider: marketplaceViewProvider,
        showCollapseAll: true
    });
    
    // Register command to refresh the marketplace
    context.subscriptions.push(vscode.commands.registerCommand('thefuse.mcp.marketplace.refresh', () => {
        marketplaceViewProvider.refreshServers();
    }));
    
    // Register command to search the marketplace
    context.subscriptions.push(vscode.commands.registerCommand('thefuse.mcp.marketplace.search', async () => {
        const query = await vscode.window.showInputBox({
            placeHolder: 'Search MCP servers by name, description, or capability',
            prompt: 'Enter search terms'
        });
        
        if (query !== undefined) {
            marketplaceViewProvider.setSearchQuery(query);
        }
    }));
    
    // Register command to clear search
    context.subscriptions.push(vscode.commands.registerCommand('thefuse.mcp.marketplace.clearSearch', () => {
        marketplaceViewProvider.clearSearch();
    }));
    
    // Register command to install a server
    context.subscriptions.push(vscode.commands.registerCommand('thefuse.mcp.marketplace.install', (item: MarketplaceServerTreeItem) => {
        marketplaceViewProvider.installServer(item);
    }));
    
    return treeView;
}


==============================================
FILE: ./src/vscode-extension/mcp-integration/mcp-marketplace.ts
==============================================

import * as vscode from 'vscode';
import * as fs from 'fs/promises';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';

/**
 * MCP marketplace server interface
 */
interface MCPMarketplaceServer {
    id: string;
    name: string;
    description: string;
    version: string;
    publisher: string;
    category: string;
    rating: number;
    downloads: number;
    lastUpdated: string;
    installCommand: string;
    args: string[];
    capabilities: string[];
    requiresConfiguration: boolean;
    configurationSchema?: {
        type: string;
        required?: string[];
        properties: Record<string, any>;
    };
}

/**
 * Service for interacting with the MCP marketplace
 */
export class MCPMarketplaceService {
    private apiBaseUrl: string;
    private cacheExpiryMs = 3600000; // 1 hour in milliseconds
    private cachedServers: { timestamp: number; servers: MCPMarketplaceServer[] } | null = null;
    private outputChannel: vscode.OutputChannel;
    
    constructor(outputChannel: vscode.OutputChannel) {
        this.outputChannel = outputChannel;
        
        // Get API URL from settings
        const config = vscode.workspace.getConfiguration('theFuse');
        this.apiBaseUrl = config.get<string>('mcpMarketplaceUrl') || 'https://mcp.marketplace.api/servers';
    }
    
    /**
     * Log a message to the output channel
     */
    private log(message: string, isError: boolean = false): void {
        const timestamp = new Date().toISOString();
        this.outputChannel.appendLine(`[MCP Marketplace] ${timestamp} ${isError ? 'ERROR: ' : ''}${message}`);
        
        if (isError) {
            console.error(`[MCP Marketplace] ${message}`);
        }
    }
    
    /**
     * Fetches all MCP servers from the marketplace
     */
    async getAllServers(): Promise<MCPMarketplaceServer[]> {
        try {
            this.log('Fetching all MCP servers from marketplace...');
            
            // In a real implementation, this would fetch from the API
            // const response = await fetch(`${this.marketplaceApiUrl}/servers`);
            // if (!response.ok) {
            //     throw new Error(`API request failed with status ${response.status}`);
            // }
            // const data = await response.json();
            // return data as MCPMarketplaceServer[];
            
            // For demonstration, use mock data
            return this.getMockServers();
        } catch (error) {
            this.log(`Error fetching servers: ${error}`);
            throw error;
        }
    }
    
    /**
     * Searches for MCP servers in the marketplace
     */
    async searchServers(query: string): Promise<MCPMarketplaceServer[]> {
        try {
            if (!query) {
                return this.getAllServers();
            }
            
            this.log(`Searching MCP servers with query: ${query}`);
            
            // In a real implementation, this would fetch from the API
            // const response = await fetch(`${this.marketplaceApiUrl}/servers/search?q=${encodeURIComponent(query)}`);
            // if (!response.ok) {
            //     throw new Error(`API request failed with status ${response.status}`);
            // }
            // const data = await response.json();
            // return data as MCPMarketplaceServer[];
            
            // For demonstration, filter mock data
            const allServers = await this.getMockServers();
            const lowerQuery = query.toLowerCase();
            
            return allServers.filter(server => 
                server.name.toLowerCase().includes(lowerQuery) ||
                server.description.toLowerCase().includes(lowerQuery) ||
                server.publisher.toLowerCase().includes(lowerQuery) ||
                server.category.toLowerCase().includes(lowerQuery) ||
                server.capabilities.some(cap => cap.toLowerCase().includes(lowerQuery))
            );
        } catch (error) {
            this.log(`Error searching servers: ${error}`);
            return [];
        }
    }
    
    /**
     * Fetches a specific MCP server from the marketplace by ID
     */
    async getServerById(id: string): Promise<MCPMarketplaceServer | null> {
        try {
            this.log(`Fetching MCP server with ID: ${id}`);
            
            // In a real implementation, this would fetch from the API
            // const response = await fetch(`${this.marketplaceApiUrl}/servers/${id}`);
            // if (!response.ok) {
            //     throw new Error(`API request failed with status ${response.status}`);
            // }
            // const data = await response.json();
            // return data as MCPMarketplaceServer;
            
            // For demonstration, find in mock data
            const allServers = await this.getMockServers();
            return allServers.find(server => server.id === id) || null;
        } catch (error) {
            this.log(`Error fetching server by ID: ${error}`);
            return null;
        }
    }

    /**
     * Alias for getServerById, used for API consistency 
     */
    async getServerDetails(id: string): Promise<MCPMarketplaceServer | null> {
        return this.getServerById(id);
    }
    
    /**
     * Fetches the most popular MCP servers from the marketplace
     */
    async getPopularServers(limit: number = 5): Promise<MCPMarketplaceServer[]> {
        try {
            this.log(`Fetching top ${limit} popular MCP servers`);
            
            // In a real implementation, this would fetch from the API
            // const response = await fetch(`${this.marketplaceApiUrl}/servers/popular?limit=${limit}`);
            // if (!response.ok) {
            //     throw new Error(`API request failed with status ${response.status}`);
            // }
            // const data = await response.json();
            // return data as MCPMarketplaceServer[];
            
            // For demonstration, sort mock data by downloads
            const allServers = await this.getMockServers();
            return allServers
                .sort((a, b) => b.downloads - a.downloads)
                .slice(0, limit);
        } catch (error) {
            this.log(`Error fetching popular servers: ${error}`);
            return [];
        }
    }
    
    /**
     * Adds a server to the MCP configuration file
     */
    async addServerToConfig(server: MCPMarketplaceServer, configPath: string): Promise<boolean> {
        try {
            this.log(`Adding server ${server.name} to MCP configuration at ${configPath}`);
            
            // Read the existing configuration
            const configContent = await fs.readFile(configPath, 'utf8');
            const config = JSON.parse(configContent);
            
            // Check if servers array exists
            if (!config.servers) {
                config.servers = [];
            }
            
            // Check if server already exists
            const existingServerIndex = config.servers.findIndex((s: any) => 
                s.id === server.id || (s.command === server.installCommand && s.args && 
                s.args.length > 0 && s.args[0] === server.args[0])
            );
            
            if (existingServerIndex >= 0) {
                this.log(`Server ${server.name} is already in the configuration`);
                return false;
            }
            
            // Create server configuration
            const serverConfig = {
                id: server.id || uuidv4(),
                name: server.name,
                command: server.installCommand,
                args: server.args,
                env: server.env || {},
                autoStart: false,
                description: server.description
            };
            
            // Add server to configuration
            config.servers.push(serverConfig);
            
            // Save updated configuration
            await fs.writeFile(configPath, JSON.stringify(config, null, 2), 'utf8');
            
            this.log(`Successfully added server ${server.name} to MCP configuration`);
            return true;
        } catch (error) {
            this.log(`Error adding server to config: ${error}`);
            throw error;
        }
    }
    
    /**
     * Downloads server definition files if needed
     */
    async downloadServerDefinition(server: MCPMarketplaceServer, destFolder: string): Promise<string | null> {
        try {
            // This is a placeholder for downloading any additional files needed for the server
            // In a real implementation, this would download definition files or packages
            
            this.log(`Downloading definition files for server ${server.name} to ${destFolder}`);
            
            // For demonstration, just create a simple JSON definition file
            const definitionPath = path.join(destFolder, `${server.id}.json`);
            const definition = {
                id: server.id,
                name: server.name,
                version: server.version,
                publisher: server.publisher,
                capabilities: server.capabilities,
                configSchema: server.configurationSchema
            };
            
            await fs.writeFile(definitionPath, JSON.stringify(definition, null, 2));
            
            this.log(`Created definition file at ${definitionPath}`);
            return definitionPath;
        } catch (error) {
            this.log(`Error downloading server definition: ${error}`);
            return null;
        }
    }
    
    /**
     * Gets mock servers for development
     */
    private async getMockServers(): Promise<MCPMarketplaceServer[]> {
        return [
            {
                id: 'vscode-mcp-server',
                name: 'VS Code MCP Server',
                description: 'Enables AI agents to interact with Visual Studio Code through the Model Context Protocol',
                version: '1.2.0',
                publisher: 'MCP Foundation',
                category: 'Development Tools',
                rating: 4.8,
                downloads: 12503,
                lastUpdated: '2025-04-01',
                installCommand: 'npx',
                args: ['@modelcontextprotocol/vscode-mcp-server'],
                capabilities: ['Code editing', 'File operations', 'Terminal commands', 'Diagnostics'],
                requiresConfiguration: false
            },
            {
                id: 'filesystem-mcp-server',
                name: 'Filesystem MCP Server',
                description: 'Provides secure filesystem access for AI agents through the Model Context Protocol',
                version: '0.9.5',
                publisher: 'MCP Foundation',
                category: 'File Management',
                rating: 4.6,
                downloads: 8921,
                lastUpdated: '2025-03-15',
                installCommand: 'npx',
                args: ['@modelcontextprotocol/server-filesystem', '--allow-dir', './data'],
                capabilities: ['File read', 'File write', 'Directory listing', 'File search'],
                requiresConfiguration: true,
                configurationSchema: {
                    type: 'object',
                    required: ['allowedDirectories'],
                    properties: {
                        allowedDirectories: {
                            type: 'string',
                            description: 'Comma-separated list of directories to allow access to'
                        },
                        readOnly: {
                            type: 'boolean',
                            description: 'Whether to allow only read operations'
                        }
                    }
                }
            },
            {
                id: 'shell-mcp-server',
                name: 'Shell MCP Server',
                description: 'Provides secure shell command execution for AI agents through MCP',
                version: '0.8.2',
                publisher: 'MCP Community',
                category: 'System Tools',
                rating: 4.3,
                downloads: 6254,
                lastUpdated: '2025-03-10',
                installCommand: 'npx',
                args: ['@modelcontextprotocol/server-shell', '--allow-commands', 'ls,cat,echo'],
                capabilities: ['Command execution', 'Process management'],
                requiresConfiguration: true,
                configurationSchema: {
                    type: 'object',
                    required: ['allowedCommands'],
                    properties: {
                        allowedCommands: {
                            type: 'string',
                            description: 'Comma-separated list of allowed commands'
                        },
                        timeoutSeconds: {
                            type: 'number',
                            description: 'Maximum execution time for commands (in seconds)'
                        }
                    }
                }
            },
            {
                id: 'browser-mcp-server',
                name: 'Browser MCP Server',
                description: 'Allows AI agents to browse and interact with web content through MCP',
                version: '1.0.0',
                publisher: 'Web Agents Inc.',
                category: 'Web',
                rating: 4.5,
                downloads: 7829,
                lastUpdated: '2025-04-10',
                installCommand: 'npx',
                args: ['@modelcontextprotocol/server-browser'],
                capabilities: ['Web browsing', 'HTML parsing', 'Form filling', 'Screenshot capture'],
                requiresConfiguration: false
            },
            {
                id: 'database-mcp-server',
                name: 'Database MCP Server',
                description: 'Provides database access for AI agents through the Model Context Protocol',
                version: '0.7.1',
                publisher: 'Data Solutions',
                category: 'Databases',
                rating: 4.2,
                downloads: 3845,
                lastUpdated: '2025-02-28',
                installCommand: 'npx',
                args: ['@modelcontextprotocol/server-database'],
                capabilities: ['SQL query execution', 'Schema inspection', 'Result formatting'],
                requiresConfiguration: true,
                configurationSchema: {
                    type: 'object',
                    required: ['connectionString', 'databaseType'],
                    properties: {
                        connectionString: {
                            type: 'string',
                            description: 'Database connection string'
                        },
                        databaseType: {
                            type: 'string',
                            description: 'Type of database (mysql, postgres, sqlite)'
                        },
                        maxRows: {
                            type: 'number',
                            description: 'Maximum number of rows to return'
                        }
                    }
                }
            },
            {
                id: 'code-as-mcp-server',
                name: 'VSCode as MCP Server',
                description: 'Turns your VSCode into an MCP server, enabling advanced coding assistance from MCP clients',
                version: '1.0.2',
                publisher: 'acomagu',
                category: 'Development Tools',
                rating: 4.9,
                downloads: 322,
                lastUpdated: '2025-04-15',
                installCommand: 'npx',
                args: ['vscode-as-mcp-server'],
                capabilities: ['Code editing', 'Terminal operations', 'Preview tools', 'Multi-instance switching'],
                requiresConfiguration: false
            }
        ];
    }
}

/**
 * Save MCP configuration to file
 */
async function saveMcpConfigToFile(config: any, configPath: string): Promise<void> {
    try {
        await fs.writeFile(configPath, JSON.stringify(config, null, 2), 'utf8');
    } catch (error) {
        throw new Error(`Failed to save MCP config to ${configPath}: ${error}`);
    }
}


==============================================
FILE: ./src/vscode-extension/mcp-integration/mcp-server-view.ts
==============================================

import * as vscode from 'vscode';
import * as fs from 'fs/promises';
import * as path from 'path';
import { loadMcpConfigFromSettings } from './mcp-client';

/**
 * MCP Server information
 */
interface MCPServer {
    id: string;
    name: string;
    description: string;
    command: string;
    args: string[];
    env: Record<string, string>;
    status: 'running' | 'stopped' | 'error';
    version?: string;
    publisher?: string;
}

/**
 * Tree data provider for MCP servers view
 */
export class MCPServerViewProvider implements vscode.TreeDataProvider<MCPServerTreeItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<MCPServerTreeItem | undefined | null | void> = new vscode.EventEmitter<MCPServerTreeItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<MCPServerTreeItem | undefined | null | void> = this._onDidChangeTreeData.event;
    
    private serverList: MCPServer[] = [];
    private context: vscode.ExtensionContext;
    
    constructor(context: vscode.ExtensionContext) {
        this.context = context;
        this.refreshServerList();
    }
    
    getTreeItem(element: MCPServerTreeItem): vscode.TreeItem {
        return element;
    }
    
    /**
     * Get the children of the given element
     */
    async getChildren(element?: MCPServerTreeItem): Promise<MCPServerTreeItem[]> {
        if (!element) {
            // Root level - show servers
            return this.serverList.map(server => new MCPServerTreeItem(
                server.name,
                server.description,
                vscode.TreeItemCollapsibleState.Collapsed,
                undefined,
                'mcpServer',
                server
            ));
        } else if (element.contextValue === 'mcpServer') {
            // Server level - show properties and actions
            const server = element.server;
            return [
                new MCPServerTreeItem(
                    'Properties',
                    '',
                    vscode.TreeItemCollapsibleState.Collapsed,
                    undefined,
                    'mcpServerProperties',
                    server
                ),
                new MCPServerTreeItem(
                    'Actions',
                    '',
                    vscode.TreeItemCollapsibleState.Collapsed,
                    undefined,
                    'mcpServerActions',
                    server
                )
            ];
        } else if (element.contextValue === 'mcpServerProperties') {
            // Properties level - show server properties
            const server = element.server;
            if (!server) {
                return [];
            }
            const children: MCPServerTreeItem[] = [];
            
            // ID
            children.push(new MCPServerTreeItem(
                'ID',
                server.id,
                vscode.TreeItemCollapsibleState.None,
                {
                    command: 'thefuse.mcp.copyToClipboard',
                    title: 'Copy to Clipboard',
                    arguments: [server.id]
                },
                'mcpServerProperty',
                server
            ));
            
            // Status
            const statusIcon = server.status === 'running' ? '$(check)' : 
                               server.status === 'error' ? '$(error)' : '$(stop)';
            children.push(new MCPServerTreeItem(
                'Status',
                `${statusIcon} ${server.status}`,
                vscode.TreeItemCollapsibleState.None,
                undefined,
                'mcpServerProperty',
                server
            ));
            
            // Command
            children.push(new MCPServerTreeItem(
                'Command',
                `${server.command} ${server.args.join(' ')}`,
                vscode.TreeItemCollapsibleState.None,
                {
                    command: 'thefuse.mcp.copyToClipboard',
                    title: 'Copy to Clipboard',
                    arguments: [`${server.command} ${server.args.join(' ')}`]
                },
                'mcpServerProperty',
                server
            ));
            
            // Version
            if (server.version) {
                children.push(new MCPServerTreeItem(
                    'Version',
                    server.version,
                    vscode.TreeItemCollapsibleState.None,
                    undefined,
                    'mcpServerProperty',
                    server
                ));
            }
            
            // Publisher
            if (server.publisher) {
                children.push(new MCPServerTreeItem(
                    'Publisher',
                    server.publisher,
                    vscode.TreeItemCollapsibleState.None,
                    undefined,
                    'mcpServerProperty',
                    server
                ));
            }
            
            return children;
        } else if (element.contextValue === 'mcpServerActions') {
            // Actions group
            const server = element.server;
            if (!server) {
                return [];
            }
            const children: MCPServerTreeItem[] = [];
            
            // Restart action
            children.push(new MCPServerTreeItem(
                'Restart Server',
                '',
                vscode.TreeItemCollapsibleState.None,
                {
                    command: 'thefuse.mcp.restartServer',
                    title: 'Restart Server',
                    arguments: [server.id]
                },
                'mcpServerAction',
                server
            ));
            
            // Edit action
            children.push(new MCPServerTreeItem(
                'Edit Configuration',
                '',
                vscode.TreeItemCollapsibleState.None,
                {
                    command: 'thefuse.mcp.editServerConfig',
                    title: 'Edit Server Configuration',
                    arguments: [server.id]
                },
                'mcpServerAction',
                server
            ));
            
            // Remove action
            children.push(new MCPServerTreeItem(
                'Remove Server',
                '',
                vscode.TreeItemCollapsibleState.None,
                {
                    command: 'thefuse.mcp.removeServer',
                    title: 'Remove Server',
                    arguments: [server.id]
                },
                'mcpServerAction',
                server
            ));
            
            return children;
        }
        
        return [];
    }
    
    /**
     * Refresh the server list
     */
    async refreshServerList() {
        try {
            // Get config path
            const configPath = await this.getConfigPath();
            if (!configPath) {
                return;
            }
            
            // Read the config file
            const configContent = await fs.readFile(configPath, 'utf8');
            const config = JSON.parse(configContent);
            
            if (!config.mcpServers) {
                this.serverList = [];
                this._onDidChangeTreeData.fire();
                return;
            }
            
            // Convert to array
            this.serverList = Object.entries(config.mcpServers).map(([id, serverConfig]: [string, any]) => ({
                id,
                name: serverConfig.name || id,
                description: serverConfig.description || '',
                command: serverConfig.command,
                args: serverConfig.args || [],
                env: serverConfig.env || {},
                status: 'stopped', // Default to stopped until we check status
                version: serverConfig.version,
                publisher: serverConfig.publisher
            }));
            
            // Update server status if possible
            await this.updateServerStatus();
            
            this._onDidChangeTreeData.fire();
        } catch (error: any) {
            console.error('Error refreshing MCP server list:', error);
            vscode.window.showErrorMessage(`Failed to refresh MCP server list: ${error.message}`);
        }
    }
    
    /**
     * Update the status of all servers
     */
    private async updateServerStatus() {
        // In a real implementation, this would check if servers are running
        // For now, let's simulate some random states
        for (const server of this.serverList) {
            // For demonstration purposes, set some random states
            const random = Math.random();
            if (random > 0.7) {
                server.status = 'running';
            } else if (random > 0.5) {
                server.status = 'error';
            } else {
                server.status = 'stopped';
            }
        }
    }
    
    /**
     * Get the MCP config path
     */
    private async getConfigPath(): Promise<string> {
        try {
            return await loadMcpConfigFromSettings();
        } catch (error: any) {
            console.error('Error getting MCP config path:', error);
            return '';
        }
    }
    
    /**
     * Remove a server from the configuration
     */
    async removeServer(serverId: string): Promise<boolean> {
        try {
            const configPath = await this.getConfigPath();
            if (!configPath) {
                throw new Error('No MCP configuration file found');
            }
            
            // Read the config file
            const configContent = await fs.readFile(configPath, 'utf8');
            const config = JSON.parse(configContent);
            
            if (!config.mcpServers || !config.mcpServers[serverId]) {
                throw new Error(`Server ${serverId} not found in configuration`);
            }
            
            // Remove the server
            delete config.mcpServers[serverId];
            
            // Write the updated config
            await fs.writeFile(configPath, JSON.stringify(config, null, 2), 'utf8');
            
            // Refresh the view
            await this.refreshServerList();
            
            return true;
        } catch (error: any) {
            console.error(`Error removing MCP server ${serverId}:`, error);
            vscode.window.showErrorMessage(`Failed to remove MCP server: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Edit a server's configuration
     */
    async editServerConfig(serverId: string): Promise<boolean> {
        try {
            const configPath = await this.getConfigPath();
            if (!configPath) {
                throw new Error('No MCP configuration file found');
            }
            
            // Open the config file in the editor
            const document = await vscode.workspace.openTextDocument(configPath);
            const editor = await vscode.window.showTextDocument(document);
            
            // Try to find the server in the config to position the cursor
            const text = document.getText();
            const serverPos = text.indexOf(`"${serverId}"`);
            if (serverPos >= 0) {
                const position = document.positionAt(serverPos);
                editor.selection = new vscode.Selection(position, position);
                editor.revealRange(new vscode.Range(position, position));
            }
            
            return true;
        } catch (error: any) {
            console.error(`Error editing MCP server ${serverId}:`, error);
            vscode.window.showErrorMessage(`Failed to edit MCP server: ${error.message}`);
            return false;
        }
    }
}

/**
 * Tree item representing an MCP server or property
 */
export class MCPServerTreeItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly description: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState,
        public readonly command?: vscode.Command,
        public readonly contextValue?: string,
        public readonly server?: MCPServer
    ) {
        super(label, collapsibleState);
        
        this.description = description;
        this.tooltip = `${label}${description ? `: ${description}` : ''}`;
        
        // Set icons based on the type
        if (contextValue === 'mcpServer') {
            this.iconPath = new vscode.ThemeIcon(
                server?.status === 'running' ? 'server-environment' :
                server?.status === 'error' ? 'warning' : 'server',
                server?.status === 'running' ? new vscode.ThemeColor('terminal.ansiGreen') :
                server?.status === 'error' ? new vscode.ThemeColor('terminal.ansiRed') : undefined
            );
        } else if (contextValue === 'mcpServerAction') {
            if (label.includes('Restart')) {
                this.iconPath = new vscode.ThemeIcon('refresh');
            } else if (label.includes('Edit')) {
                this.iconPath = new vscode.ThemeIcon('edit');
            } else if (label.includes('Remove')) {
                this.iconPath = new vscode.ThemeIcon('trash');
            }
        } else if (contextValue === 'mcpServerProperties') {
            this.iconPath = new vscode.ThemeIcon('list-flat');
        } else if (contextValue === 'mcpServerActions') {
            this.iconPath = new vscode.ThemeIcon('tools');
        }
    }
}

/**
 * Register the MCP server view and related commands
 */
export function registerMCPServerView(context: vscode.ExtensionContext): vscode.Disposable[] {
    const serverViewProvider = new MCPServerViewProvider(context);
    
    // Register the view
    const serverTreeView = vscode.window.createTreeView('thefuse.mcpServerView', {
        treeDataProvider: serverViewProvider,
        showCollapseAll: true,
        canSelectMany: false
    });
    
    // Register commands
    
    // Refresh command
    const refreshCommand = vscode.commands.registerCommand('thefuse.mcp.refreshServerList', () => {
        serverViewProvider.refreshServerList();
    });
    
    // Copy to clipboard command
    const copyCommand = vscode.commands.registerCommand('thefuse.mcp.copyToClipboard', async (text: string) => {
        await vscode.env.clipboard.writeText(text);
        vscode.window.showInformationMessage('Copied to clipboard');
    });
    
    // Restart server command
    const restartCommand = vscode.commands.registerCommand('thefuse.mcp.restartServer', async (serverId: string) => {
        vscode.window.showInformationMessage(`Restarting MCP server: ${serverId}`);
        // This would trigger a restart of the MCP server
        // In a real implementation, this would connect to the MCP manager
        // and trigger a restart
        await vscode.commands.executeCommand('thefuse.mcp.initialize');
    });
    
    // Edit server config command
    const editConfigCommand = vscode.commands.registerCommand('thefuse.mcp.editServerConfig', async (serverId: string) => {
        await serverViewProvider.editServerConfig(serverId);
    });
    
    // Remove server command
    const removeCommand = vscode.commands.registerCommand('thefuse.mcp.removeServer', async (serverId: string) => {
        const confirm = await vscode.window.showWarningMessage(
            `Are you sure you want to remove MCP server "${serverId}"?`,
            { modal: true },
            'Yes',
            'No'
        );
        
        if (confirm === 'Yes') {
            await serverViewProvider.removeServer(serverId);
            vscode.window.showInformationMessage(`Removed MCP server: ${serverId}`);
        }
    });
    
    // Add a refresh button to the view title
    const refreshButton = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right);
    refreshButton.text = "$(refresh)";
    refreshButton.tooltip = "Refresh MCP Servers";
    refreshButton.command = "thefuse.mcp.refreshServerList";
    refreshButton.show();
    
    return [
        serverTreeView,
        refreshCommand,
        copyCommand,
        restartCommand,
        editConfigCommand,
        removeCommand,
        refreshButton
    ];
}


==============================================
FILE: ./src/vscode-extension/mcp-integration/tools/tool-registry.tsx
==============================================

import * as vscode from 'vscode';
import { Logger } from '../../core/logging';
import { MCPError, ErrorCode } from '../../core/error-handling';

export interface MCPTool {
    id: string;
    name: string;
    description: string;
    version: string;
    capabilities: string[];
    execute: (args: any) => Promise<any>;
}

export class ToolRegistry {
    private tools: Map<string, MCPTool> = new Map();
    private logger: Logger = Logger.getInstance();

    async registerTool(tool: MCPTool): Promise<void> {
        if (this.tools.has(tool.id)) {
            throw new MCPError(
                ErrorCode.TOOL_EXECUTION_FAILED,
                `Tool with ID ${tool.id} already registered`
            );
        }

        this.tools.set(tool.id, tool);
        this.logger.info(`Registered tool: ${tool.name} (${tool.id})`);
    }

    async executeTool(toolId: string, args: any): Promise<any> {
        const tool = this.tools.get(toolId);
        if (!tool) {
            throw new MCPError(
                ErrorCode.TOOL_EXECUTION_FAILED,
                `Tool ${toolId} not found`
            );
        }

        try {
            return await tool.execute(args);
        } catch (error) {
            throw new MCPError(
                ErrorCode.TOOL_EXECUTION_FAILED,
                `Failed to execute tool ${toolId}`,
                error
            );
        }
    }

    getTools(): MCPTool[] {
        return Array.from(this.tools.values());
    }
}


==============================================
FILE: ./src/vscode-extension/mcp-protocol.tsx
==============================================

/**
 * Message Control Protocol (MCP) Implementation
 * 
 * This module implements a simplified MCP protocol for AI agent communication,
 * enabling autonomous discovery and interaction between AI extensions.
 */

import * as vscode from 'vscode';
import { AgentClient } from './agent-communication';
import { getErrorMessage } from './utilities';

// MCP Message interface
export interface MCPMessage {
  namespace: string;
  command: string;
  parameters: Record<string, any>;
  requestId?: string;
}

// MCP Response interface
export interface MCPResponse {
  success: boolean;
  result?: any;
  error?: string;
}

// Registered handler function type
type MCPHandler = (parameters: Record<string, any>) => Promise<any>;

/**
 * MCP Protocol Manager
 */
export class MCPProtocolManager {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private handlers: Map<string, MCPHandler> = new Map();
  private outputChannel: vscode.OutputChannel;
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient) {
    this.context = context;
    this.agentClient = agentClient;
    this.outputChannel = vscode.window.createOutputChannel('MCP Protocol');
    
    // Register this as an agent
    this.agentClient.register('MCP Protocol Manager', ['mcp', 'agent-discovery'], '1.0.0')
      .then(() => {
        this.log('MCP Protocol Manager registered');
        // Subscribe to receive messages
        this.agentClient.subscribe(this.handleAgentMessage.bind(this));
      });
    
    // Register the basic MCP handlers
    this.registerBuiltinHandlers();
    
    // Register commands
    this.registerCommands();
  }
  
  /**
   * Register built-in MCP handlers
   */
  private registerBuiltinHandlers() {
    // Register the discovery handler
    this.registerHandler('mcp.core.discover', async () => {
      // Return list of registered agents
      return vscode.commands.executeCommand('llm-orchestrator.getRegisteredAgents');
    });
    
    // Register the capabilities handler
    this.registerHandler('mcp.core.getCapabilities', async (params) => {
      if (!params.agentId) {
        throw new Error('agentId parameter is required');
      }
      
      // Get agent capabilities
      return vscode.commands.executeCommand('llm-orchestrator.getAgentCapabilities', params.agentId);
    });
    
    // Register ping/echo handler
    this.registerHandler('mcp.core.echo', async (params) => {
      return {
        message: params.message || 'Hello from MCP Protocol Manager',
        timestamp: Date.now(),
        echo: true
      };
    });
  }
  
  /**
   * Register VS Code commands
   */
  private registerCommands() {
    // Register a command to register an MCP handler
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.mcp.registerHandler', 
        async (namespace: string, handlerFn: string | Function) => {
          await this.registerHandlerFromString(namespace, handlerFn);
          return true;
        }
      )
    );
    
    // Register a command to send an MCP message
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.mcp.sendMessage',
        async (recipient: string, namespace: string, command: string, parameters: Record<string, any>) => {
          return this.sendMCPMessage(recipient, namespace, command, parameters);
        }
      )
    );
    
    // Register a command to trigger auto-discovery
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.mcp.startAutoDiscovery',
        async () => {
          return this.startAutoDiscovery();
        }
      )
    );
  }
  
  /**
   * Register an MCP handler
   */
  public registerHandler(fullCommand: string, handler: MCPHandler): void {
    this.handlers.set(fullCommand, handler);
    this.log(`Registered handler for ${fullCommand}`);
  }
  
  /**
   * Register an MCP handler from a string or function
   */
  public async registerHandlerFromString(fullCommand: string, handlerFn: string | Function): Promise<boolean> {
    try {
      let handler: MCPHandler;
      
      if (typeof handlerFn === 'function') {
        handler = handlerFn as MCPHandler;
      } else if (typeof handlerFn === 'string') {
        // Convert string to function
        // eslint-disable-next-line no-new-func
        handler = new Function('parameters', `return (async () => { ${handlerFn} })()`) as MCPHandler;
      } else {
        throw new Error('Invalid handler: must be a function or string');
      }
      
      this.registerHandler(fullCommand, handler);
      return true;
    } catch (error) {
      this.log(`Error registering handler for ${fullCommand}: ${getErrorMessage(error)}`);
      return false;
    }
  }
  
  /**
   * Send an MCP message to another agent
   */
  public async sendMCPMessage(
    recipient: string,
    namespace: string,
    command: string,
    parameters: Record<string, any>
  ): Promise<MCPResponse> {
    try {
      const fullCommand = `${namespace}.${command}`;
      this.log(`Sending MCP message: ${fullCommand} to ${recipient}`);
      
      const result = await this.agentClient.sendMessage(recipient, 'mcp.execute', {
        namespace,
        command,
        parameters,
        requestId: `mcp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
      });
      
      return { success: true, result };
    } catch (error) {
      this.log(`Error sending MCP message: ${getErrorMessage(error)}`);
      return { success: false, error: getErrorMessage(error) };
    }
  }
  
  /**
   * Start auto-discovery of AI agents
   */
  public async startAutoDiscovery(): Promise<boolean> {
    try {
      this.log('Starting auto-discovery of AI agents');
      
      // Broadcast discovery message
      await this.agentClient.broadcast('mcp.execute', {
        namespace: 'mcp.core',
        command: 'discover',
        parameters: {},
        requestId: `mcp-discovery-${Date.now()}`
      });
      
      return true;
    } catch (error) {
      this.log(`Error in auto-discovery: ${getErrorMessage(error)}`);
      return false;
    }
  }
  
  /**
   * Handle incoming agent messages
   */
  private async handleAgentMessage(message: any): Promise<void> {
    if (message.action === 'mcp.execute') {
      const mcpMessage = message.payload as MCPMessage;
      const fullCommand = `${mcpMessage.namespace}.${mcpMessage.command}`;
      
      this.log(`Received MCP execute: ${fullCommand}`);
      
      // Find the handler
      const handler = this.handlers.get(fullCommand);
      if (!handler) {
        // Send error response
        await this.agentClient.sendMessage(message.sender, 'mcp.response', {
          requestId: mcpMessage.requestId,
          success: false,
          error: `No handler registered for ${fullCommand}`
        });
        return;
      }
      
      try {
        // Execute the handler
        const result = await handler(mcpMessage.parameters);
        
        // Send response
        await this.agentClient.sendMessage(message.sender, 'mcp.response', {
          requestId: mcpMessage.requestId,
          success: true,
          result
        });
      } catch (error) {
        // Send error response
        await this.agentClient.sendMessage(message.sender, 'mcp.response', {
          requestId: mcpMessage.requestId,
          success: false,
          error: error.message
        });
      }
    } else if (message.action === 'mcp.response') {
      // Handle response to a previous MCP execute
      this.log(`Received MCP response for request ${message.payload.requestId}`);
      
      // In a real implementation, this would resolve a promise for the original request
    }
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    const timestamp = new Date().toISOString();
    this.outputChannel.appendLine(`[${timestamp}] ${message}`);
  }
  
  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.outputChannel.dispose();
  }
}

// Export factory function
export function createMCPProtocolManager(context: vscode.ExtensionContext, agentClient: AgentClient): MCPProtocolManager {
  return new MCPProtocolManager(context, agentClient);
}



==============================================
FILE: ./src/vscode-extension/mcp_config.json
==============================================

{
  "version": "1.0",
  "servers": {
    "the-new-fuse-mcp": {
      "host": "localhost",
      "port": 3000,
      "protocol": "http",
      "type": "mcp",
      "capabilities": ["file-operations", "build-operations", "agent-coordination", "state-management"],
      "description": "Model-Controller-Provider server for The New Fuse with file, build, and agent coordination capabilities",
      "enabled": true
    },
    "main": {
      "host": "localhost",
      "port": 3000,
      "protocol": "http",
      "enabled": true
    },
    "postgres": {
      "type": "database",
      "POSTGRES_CONNECTION_STRING": "postgresql://postgres:postgres@localhost:5432/fuse",
      "enabled": true
    },
    "redis": {
      "type": "cache",
      "REDIS_HOST": "localhost",
      "REDIS_PORT": 6379,
      "REDIS_PASSWORD": "",
      "enabled": true
    },
    "openai": {
      "type": "llm",
      "provider": "openai",
      "OPENAI_API_KEY": "YOUR_OPENAI_API_KEY",
      "models": ["gpt-3.5-turbo", "gpt-4"],
      "enabled": true
    },
    "anthropic": {
      "type": "llm",
      "provider": "anthropic",
      "ANTHROPIC_API_KEY": "YOUR_ANTHROPIC_API_KEY",
      "models": ["claude-2", "claude-instant-1"],
      "enabled": false
    },
    "brave-search": {
      "type": "search",
      "provider": "brave",
      "BRAVE_API_KEY": "YOUR_BRAVE_SEARCH_API_KEY",
      "enabled": false
    },
    "text-analysis": {
      "type": "agent",
      "capabilities": ["text-analysis", "sentiment-analysis", "entity-extraction"],
      "enabled": true
    },
    "code-generation": {
      "type": "agent",
      "capabilities": ["code-generation", "code-review", "code-explanation"],
      "enabled": true
    },
    "workflow-engine": {
      "type": "orchestration",
      "enabled": true
    }
  },
  "agent-discovery": {
    "auto-discovery": true,
    "scan-interval": 300,
    "capability-validation": true
  },
  "security": {
    "jwt-secret": "CHANGE_THIS_TO_A_SECURE_SECRET_KEY",
    "jwt-expiration": 3600,
    "rate-limit": {
      "window-ms": 60000,
      "max-requests": 100
    },
    "cors": {
      "allowed-origins": ["http://localhost:3000", "http://localhost:5173"],
      "allowed-methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
      "allowed-headers": ["Content-Type", "Authorization"]
    }
  },
  "logging": {
    "level": "info",
    "format": "json",
    "file": "./mcp/logs/mcp-server.log"
  },
  "ui": {
    "dashboard-enabled": true,
    "theme": "light"
  },
  "mcpServers": {
    "the-new-fuse-mcp": {
      "command": "node",
      "args": ["./src/mcp/server.js"],
      "env": {
        "PORT": "3000",
        "WORKSPACE_ROOT": "./",
        "LOG_LEVEL": "info"
      },
      "description": "The New Fuse MCP Server with file, build, and agent coordination capabilities"
    },
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "--allow-dir", "./data"
      ]
    },
    "brave-search": {
      "command": "docker",
      "args": [
        "run",
        "--rm",
        "-i",
        "-e", "BRAVE_API_KEY",
        "modelcontextprotocol/brave-search"
      ],
      "env": {
        "BRAVE_API_KEY": "YOUR_ACTUAL_BRAVE_SEARCH_API_KEY"
      }
    },
    "sqlite": {
      "command": "docker",
      "args": [
        "run",
        "--rm",
        "-i",
        "-v", "./db:/data/mcp/sqlite",
        "--db-path", "/data/mcp/sqlite/ai_data.db",
        "modelcontextprotocol/sqlite"
      ]
    },
    "shell": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-shell",
        "--allow-commands", "ls,cat,grep,find,echo,pwd"
      ]
    },
    "http": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-http",
        "--allow-hosts", "api.github.com,api.openai.com"
      ]
    },
    "code-analysis": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-code-analysis",
        "--allow-dir", "./"
      ]
    },
    "postgres": {
      "command": "docker",
      "args": [
        "run",
        "--rm",
        "-i",
        "-e", "POSTGRES_CONNECTION_STRING",
        "modelcontextprotocol/postgres"
      ],
      "env": {
        "POSTGRES_CONNECTION_STRING": "postgresql://postgres:postgres@localhost:5432/fuse"
      }
    },
    "vector-db": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-vector-db",
        "--db-path", "./data/vector-db"
      ]
    }
  }
}



==============================================
FILE: ./src/vscode-extension/media/agentActivityDashboard.js
==============================================

// Agent Activity Dashboard Client-side JavaScript
(function() {
  // Get message passing API
  const vscode = acquireVsCodeApi();
  
  // Elements
  const monitoringToggle = document.getElementById('monitoring-toggle');
  const refreshButton = document.getElementById('refresh-button');
  const activeAgentsCount = document.getElementById('active-agents');
  const toolUsagesCount = document.getElementById('tool-usages');
  const errorCount = document.getElementById('error-count');
  const avgResponse = document.getElementById('avg-response');
  const agentsList = document.getElementById('agents-list');
  const activeToolsList = document.getElementById('active-tools-list');
  const recentToolsList = document.getElementById('recent-tools-list');
  const toolMetricsList = document.getElementById('tool-metrics-list');
  const backendToggle = document.getElementById('backend-toggle');
  const backendUrl = document.getElementById('backend-url');
  const saveBackendSettings = document.getElementById('save-backend-settings');
  
  // State
  let lastUpdate = Date.now();
  
  // Initialize
  document.addEventListener('DOMContentLoaded', () => {
    // Request initial data
    vscode.postMessage({ command: 'refresh' });
  });
  
  // Handle refresh button click
  refreshButton.addEventListener('click', () => {
    vscode.postMessage({ command: 'refresh' });
  });
  
  // Handle monitoring toggle
  monitoringToggle.addEventListener('change', () => {
    vscode.postMessage({ 
      command: 'toggleMonitoring', 
      enabled: monitoringToggle.checked 
    });
  });
  
  // Handle backend settings
  saveBackendSettings.addEventListener('click', () => {
    vscode.postMessage({
      command: 'setBackendSettings',
      enabled: backendToggle.checked,
      url: backendUrl.value
    });
  });
  
  // Handle messages from extension
  window.addEventListener('message', event => {
    const message = event.data;
    
    switch (message.command) {
      case 'updateDashboard':
        updateDashboard(message.data);
        break;
    }
  });
  
  // Update the dashboard with new data
  function updateDashboard(data) {
    lastUpdate = Date.now();
    
    // Update toggle state
    monitoringToggle.checked = data.enabled;
    
    // Update backend settings
    backendToggle.checked = data.backendEnabled;
    backendUrl.value = data.backendUrl;
    
    // Update summary metrics
    activeAgentsCount.textContent = data.agentCount;
    toolUsagesCount.textContent = data.totalToolUsage;
    errorCount.textContent = data.errorCount;
    avgResponse.textContent = formatTime(data.avgResponseTime);
    
    // Update agents list
    if (data.agents.length > 0) {
      agentsList.innerHTML = '';
      data.agents.forEach(agent => {
        const agentItem = document.createElement('div');
        agentItem.className = 'agent-item';
        agentItem.innerHTML = `
          <div class="agent-name">
            <span class="status-indicator active"></span>
            ${sanitize(agent)}
          </div>
        `;
        agentsList.appendChild(agentItem);
      });
    } else {
      agentsList.innerHTML = '<div class="no-data">No active agents</div>';
    }
    
    // Update active tool executions
    if (data.activeToolExecutions && data.activeToolExecutions.length > 0) {
      activeToolsList.innerHTML = '';
      data.activeToolExecutions.forEach(tool => {
        const toolItem = document.createElement('div');
        toolItem.className = 'tool-item';
        toolItem.innerHTML = `
          <div class="tool-name">
            <span class="status-indicator active"></span>
            ${sanitize(tool.toolId)}
          </div>
          <div class="tool-elapsed">${formatTime(tool.elapsedMs)}</div>
        `;
        activeToolsList.appendChild(toolItem);
      });
    } else {
      activeToolsList.innerHTML = '<div class="no-data">No active tool executions</div>';
    }
    
    // Update recent tools
    if (data.recentTools && data.recentTools.length > 0) {
      recentToolsList.innerHTML = '';
      data.recentTools.forEach(tool => {
        const toolItem = document.createElement('div');
        toolItem.className = 'recent-tool-item';
        toolItem.innerHTML = `
          <div class="tool-info">
            <span class="status-indicator ${tool.success ? 'success' : 'error'}"></span>
            <span class="tool-id">${sanitize(tool.toolId)}</span>
            <span class="agent-id">${sanitize(tool.agentId)}</span>
          </div>
          <div class="tool-time">${formatTimeAgo(tool.timestamp)}</div>
        `;
        recentToolsList.appendChild(toolItem);
      });
    } else {
      recentToolsList.innerHTML = '<div class="no-data">No recent tool usage</div>';
    }
    
    // Update tool metrics
    if (data.tools && data.tools.length > 0) {
      toolMetricsList.innerHTML = '';
      data.tools.forEach(tool => {
        const toolMetricItem = document.createElement('div');
        toolMetricItem.className = 'tool-metric-item';
        
        // Calculate success rate percentage
        const successRatePercent = Math.round(tool.successRate * 100);
        
        toolMetricItem.innerHTML = `
          <div class="tool-metric-header">
            <div class="tool-metric-name">${sanitize(tool.toolId)}</div>
            <div class="tool-metric-count">${tool.count} uses</div>
          </div>
          <div class="tool-metric-details">
            <div class="tool-metric-success-rate">
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${successRatePercent}%"></div>
              </div>
              <div class="progress-text">${successRatePercent}% success</div>
            </div>
            <div class="tool-metric-time">
              Avg: ${formatTime(tool.avgResponseTime)}
            </div>
          </div>
        `;
        toolMetricsList.appendChild(toolMetricItem);
      });
    } else {
      toolMetricsList.innerHTML = '<div class="no-data">No tool metrics available</div>';
    }
  }
  
  // Format milliseconds as human-readable time
  function formatTime(ms) {
    if (ms < 1000) {
      return `${Math.round(ms)}ms`;
    } else if (ms < 60000) {
      return `${(ms / 1000).toFixed(1)}s`;
    } else {
      const minutes = Math.floor(ms / 60000);
      const seconds = ((ms % 60000) / 1000).toFixed(0);
      return `${minutes}m ${seconds}s`;
    }
  }
  
  // Format timestamp as time ago
  function formatTimeAgo(timestamp) {
    const seconds = Math.floor((Date.now() - timestamp) / 1000);
    
    if (seconds < 60) {
      return `${seconds}s ago`;
    } else if (seconds < 3600) {
      return `${Math.floor(seconds / 60)}m ago`;
    } else if (seconds < 86400) {
      return `${Math.floor(seconds / 3600)}h ago`;
    } else {
      return `${Math.floor(seconds / 86400)}d ago`;
    }
  }
  
  // Sanitize strings for display
  function sanitize(text) {
    const element = document.createElement('div');
    element.textContent = text;
    return element.innerHTML;
  }
})();


==============================================
FILE: ./src/vscode-extension/minimal-launch.sh
==============================================

#!/bin/bash

echo "===================================================="
echo "  The New Fuse - Minimal Launch Script"
echo "===================================================="
echo ""

# Create necessary directories
mkdir -p out
mkdir -p ai-communication

# Compile TypeScript to JavaScript if needed
if [ -f "extension.ts" ]; then
  echo "TypeScript source found, compiling..."
  if command -v tsc &> /dev/null; then
    tsc -p . || echo "TypeScript compilation failed, using existing out/extension.js"
  else
    echo "TypeScript compiler not found, using existing out/extension.js"
  fi
else
  echo "No TypeScript source found, using existing out/extension.js"
fi

# Launch VS Code with the extension
echo "Launching VS Code with the extension..."
code --extensionDevelopmentPath="$(pwd)"

echo ""
echo "The New Fuse should now be running in VS Code."
echo "Look for the rocket icon ($(rocket)) in the status bar."
echo ""



==============================================
FILE: ./src/vscode-extension/monitored-llm-provider-manager.ts
==============================================

import * as vscode from 'vscode';
import { FuseMonitoringClient } from './monitoring/FuseMonitoringClient';
import { LLMProviderConfig, LLMProviderManager } from './llm-provider-manager';

/**
 * MonitoredLLMProviderManager 
 * 
 * Extends the LLMProviderManager with integrated monitoring capabilities.
 * This class wraps all LLM provider operations with monitoring to track
 * performance, usage, and errors across different LLM providers.
 */
export class MonitoredLLMProviderManager {
  private providerManager: LLMProviderManager;
  private monitoringClient: FuseMonitoringClient;
  private context: vscode.ExtensionContext;

  constructor(
    context: vscode.ExtensionContext,
    providerManager: LLMProviderManager,
    monitoringClient: FuseMonitoringClient
  ) {
    this.context = context;
    this.providerManager = providerManager;
    this.monitoringClient = monitoringClient;
  }

  /**
   * Get all available LLM providers
   */
  getAllProviders(): LLMProviderConfig[] {
    return this.providerManager.getAllProviders();
  }

  /**
   * Get a provider by ID
   */
  getProvider(id: string): LLMProviderConfig | undefined {
    return this.providerManager.getProvider(id);
  }

  /**
   * Get the currently selected provider
   */
  getCurrentProvider(): LLMProviderConfig {
    const provider = this.providerManager.getSelectedProvider();
    if (!provider) {
      throw new Error('No provider selected');
    }
    return provider;
  }

  /**
   * Set the current provider by ID
   */
  setCurrentProvider(id: string): Promise<boolean> {
    return Promise.resolve(this.providerManager.selectProvider(id));
  }

  /**
   * Generate text with the current provider, with monitoring
   */
  async generateText(prompt: string, options: any = {}): Promise<any> {
    const provider = this.getCurrentProvider();
    
    // Use scoreGeneration instead of traceGeneration
    return this.monitoringClient.scoreGeneration({
      generationId: `text-gen-${Date.now()}`,
      name: 'text-generation',
      provider: provider.name,
      model: provider.modelName,
      prompt,
      options,
      callback: async () => {
        // Implementation of generateText
        return {
          text: prompt + " [Generated response]",
          provider: provider.name,
          model: provider.modelName,
          usage: { promptTokens: prompt.length, completionTokens: 100, totalTokens: prompt.length + 100 }
        };
      }
    });
  }

  /**
   * Generate a chat completion with the current provider, with monitoring
   */
  async generateChatCompletion(messages: any[], options: any = {}): Promise<any> {
    const provider = this.getCurrentProvider();
    
    // Construct a readable prompt from the messages for monitoring
    const promptForMonitoring = messages.map(msg => 
      `${msg.role}: ${msg.content}`
    ).join('\n');
    
    // Use scoreGeneration instead of traceGeneration
    return this.monitoringClient.scoreGeneration({
      generationId: `chat-gen-${Date.now()}`,
      name: 'chat-completion',
      provider: provider.name,
      model: provider.modelName,
      prompt: promptForMonitoring,
      options,
      callback: async () => {
        // Implementation of chat completion
        return {
          text: "This is a chat completion response",
          provider: provider.name,
          model: provider.modelName,
          usage: { promptTokens: 100, completionTokens: 150, totalTokens: 250 }
        };
      }
    });
  }

  /**
   * Generate code with the current provider, with monitoring
   */
  async generateCode(prompt: string, language: string, options: any = {}): Promise<any> {
    const provider = this.getCurrentProvider();
    
    // Use scoreGeneration instead of traceGeneration
    return this.monitoringClient.scoreGeneration({
      generationId: `code-gen-${Date.now()}`,
      name: 'code-generation',
      provider: provider.name,
      model: provider.modelName,
      prompt,
      language,
      options,
      callback: async () => {
        // Implementation of code generation
        return {
          text: `// ${language} code\n// Generated from prompt: ${prompt}\n\nfunction example() {\n  // Implementation\n}`,
          provider: provider.name,
          model: provider.modelName,
          usage: { promptTokens: prompt.length, completionTokens: 120, totalTokens: prompt.length + 120 }
        };
      }
    });
  }

  /**
   * Add a user rating for a generation
   */
  rateGeneration(generationId: string, rating: number, comment?: string): void {
    this.monitoringClient.scoreGeneration({
      generationId,
      name: 'user-rating',
      value: rating,
      comment
    });
  }

  /**
   * Save a user preference for a provider
   */
  saveUserPreference(providerId: string, preferred: boolean): void {
    // Save preference in global state
    const preferences = this.context.globalState.get<Record<string, boolean>>('thefuse.providerPreferences', {});
    preferences[providerId] = preferred;
    this.context.globalState.update('thefuse.providerPreferences', preferences);
    
    // Log in monitoring system
    if (this.monitoringClient.isEnabled()) {
      const provider = this.getProvider(providerId);
      if (provider) {
        // Create a trace ID that encodes the preference information 
        const traceId = `preference-${providerId}-${preferred ? 'preferred' : 'not-preferred'}-${Date.now()}`;
        this.monitoringClient.startTrace(traceId);
        
        if (traceId) {
          this.monitoringClient.endTrace(traceId);
        }
      }
    }
  }

  /**
   * Get monitoring metrics for LLM usage
   */
  getMetrics(): any {
    return this.monitoringClient.getSessionMetrics();
  }

  /**
   * Open the monitoring dashboard
   */
  openMonitoringDashboard(): void {
    this.monitoringClient.openDashboard();
  }
}


==============================================
FILE: ./src/vscode-extension/monitoring/AdminControlPanelProvider.ts
==============================================

import * as vscode from 'vscode';
import { FuseMonitoringClient } from './FuseMonitoringClient';
import { LLMMonitoringClient } from './llm-monitoring-client';
import { AgentMonitor } from './AgentMonitor';

export class AdminControlPanelProvider {
  public static readonly viewType = 'thefuse.adminControlPanel';
  private panel: vscode.WebviewPanel;
  private disposables: vscode.Disposable[] = [];
  private fuseClient: FuseMonitoringClient;
  private llmClient: LLMMonitoringClient;
  private agentMonitor: AgentMonitor;

  public static createOrShow(
    extensionUri: vscode.Uri,
    context: vscode.ExtensionContext,
    fuseClient: FuseMonitoringClient,
    llmClient: LLMMonitoringClient
  ) {
    const column = vscode.window.activeTextEditor ? vscode.window.activeTextEditor.viewColumn : undefined;
    const panel = vscode.window.createWebviewPanel(
      AdminControlPanelProvider.viewType,
      'Fuse Admin Control Panel',
      column || vscode.ViewColumn.One,
      { enableScripts: true }
    );
    return new AdminControlPanelProvider(panel, extensionUri, context, fuseClient, llmClient);
  }

  private constructor(
    panel: vscode.WebviewPanel,
    extensionUri: vscode.Uri,
    context: vscode.ExtensionContext,
    fuseClient: FuseMonitoringClient,
    llmClient: LLMMonitoringClient
  ) {
    this.panel = panel;
    this.fuseClient = fuseClient;
    this.llmClient = llmClient;
    this.agentMonitor = AgentMonitor.getInstance();

    this.panel.webview.html = this._getHtml();

    this.panel.webview.onDidReceiveMessage(msg => {
      switch (msg.command) {
        case 'refresh':
          this.panel.webview.postMessage({
            command: 'updateData',
            data: {
              agents: this.agentMonitor.getMetrics(),
              llm: this.llmClient.getSessionMetrics(),
              fuse: this.fuseClient.getSessionMetrics()
            }
          });
          break;
      }
    }, null, this.disposables);

    this.panel.onDidDispose(() => this.dispose(), null, this.disposables);
  }

  private _getHtml(): string {
    const script = `<script>
      const vscode = acquireVsCodeApi();
      function refresh() { vscode.postMessage({ command: 'refresh' }); }
      window.addEventListener('message', event => {
        const msg = event.data;
        if (msg.command === 'updateData') {
          document.getElementById('agents').textContent = JSON.stringify(msg.data.agents, null, 2);
          document.getElementById('llm').textContent = JSON.stringify(msg.data.llm, null, 2);
          document.getElementById('fuse').textContent = JSON.stringify(msg.data.fuse, null, 2);
        }
      });
      setTimeout(refresh, 0);
    </script>`;

    return `<!DOCTYPE html>
    <html lang="en">
    <head><meta charset="UTF-8"><title>Fuse Admin Control Panel</title></head>
    <body>
      <h1>Fuse Admin Control Panel</h1>
      <button onclick="refresh()">Refresh</button>
      <h2>Agent Metrics</h2><pre id="agents">Loading...</pre>
      <h2>LLM Metrics</h2><pre id="llm">Loading...</pre>
      <h2>Fuse Monitoring Metrics</h2><pre id="fuse">Loading...</pre>
      ${script}
    </body>
    </html>`;
  }

  public dispose() {
    this.panel.dispose();
    this.disposables.forEach(d => d.dispose());
  }
}


==============================================
FILE: ./src/vscode-extension/monitoring/AgentActivityDashboardProvider.ts
==============================================

import * as vscode from 'vscode';
import { AgentMonitor, AgentStatus } from './AgentMonitor';

/**
 * Provides a dashboard webview to display agent activity and metrics
 */
export class AgentActivityDashboardProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = 'thefuse.agentActivityDashboard';
  private _view?: vscode.WebviewView;
  private agentMonitor: AgentMonitor;
  private refreshInterval: NodeJS.Timeout | null = null;

  constructor(private readonly _extensionUri: vscode.Uri) {
    this.agentMonitor = AgentMonitor.getInstance();
  }

  /**
   * Called when the view is initially created
   */
  public resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken,
  ) {
    this._view = webviewView;

    // Set webview options
    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };

    // Set initial HTML content
    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    // Handle messages from the webview
    webviewView.webview.onDidReceiveMessage(data => {
      switch (data.command) {
        case 'refresh':
          this.refreshDashboard();
          break;
        case 'toggleMonitoring':
          this.agentMonitor.setEnabled(data.enabled);
          this.refreshDashboard();
          break;
        case 'setBackendSettings':
          this.agentMonitor.setBackendSettings(data.enabled, data.url);
          this.refreshDashboard();
          break;
      }
    });

    // Set up refresh interval
    this.refreshInterval = setInterval(() => {
      if (this._view?.visible) {
        this.refreshDashboard();
      }
    }, 5000); // Refresh every 5 seconds when visible

    // Initial refresh
    this.refreshDashboard();
  }

  /**
   * Update the webview with current metrics
   */
  public refreshDashboard() {
    if (!this._view) return;

    const metrics = this.agentMonitor.getMetrics();
    
    // Get detailed tool metrics
    const toolsData = Array.from(metrics.toolUsage.entries()).map(([key, count]) => {
      const [agentId, toolId] = key.split(':');
      const successRate = this.agentMonitor.getToolSuccessRate(toolId);
      const avgResponseTime = this.agentMonitor.getToolAverageResponseTime(toolId);
      
      return {
        agentId,
        toolId,
        count,
        successRate: successRate.rate,
        successCount: successRate.success,
        failureCount: successRate.failure,
        avgResponseTime
      };
    });
    
    // Sort tools by usage count
    toolsData.sort((a, b) => b.count - a.count);
    
    // Get recent tool usage
    const recentTools = this.agentMonitor.getRecentToolUsage(20);
    
    // Build the dashboard data
    const dashboardData = {
      enabled: this.agentMonitor.isEnabled(),
      backendEnabled: (this.agentMonitor as any).backendEnabled || false,
      backendUrl: (this.agentMonitor as any).backendUrl || '',
      agentCount: metrics.activeAgents.length,
      agents: metrics.activeAgents,
      totalToolUsage: Array.from(metrics.toolUsage.values()).reduce((sum, count) => sum + count, 0),
      errorCount: metrics.errorCount,
      avgResponseTime: metrics.responseTime.length > 0 
        ? metrics.responseTime.reduce((sum, time) => sum + time, 0) / metrics.responseTime.length 
        : 0,
      tools: toolsData,
      recentTools: recentTools,
      activeToolExecutions: Array.from(metrics.activeToolExecutions.entries()).map(([id, data]) => ({
        id,
        toolId: data.toolId,
        elapsedMs: Date.now() - data.startTime
      }))
    };
    
    // Send to webview
    this._view.webview.postMessage({
      command: 'updateDashboard',
      data: dashboardData
    });
  }

  /**
   * Generate the HTML for the webview
   */
  private _getHtmlForWebview(webview: vscode.Webview) {
    // Get resources
    const scriptUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'agentActivityDashboard.js')
    );
    const styleUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'media', 'agentActivityDashboard.css')
    );
    const codiconsUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'node_modules', '@vscode/codicons', 'dist', 'codicon.css')
    );
    
    // Use a nonce to only allow a specific script to be run
    const nonce = getNonce();

    return `<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}'; font-src ${webview.cspSource};">
      <link href="${styleUri}" rel="stylesheet">
      <link href="${codiconsUri}" rel="stylesheet">
      <title>Agent Activity Dashboard</title>
    </head>
    <body>
      <header>
        <h1>Agent Activity Dashboard</h1>
        <div class="monitoring-toggle">
          <label class="switch">
            <input type="checkbox" id="monitoring-toggle" checked>
            <span class="slider round"></span>
          </label>
          <span>Monitoring Enabled</span>
        </div>
      </header>
      
      <section class="metrics-summary">
        <div class="card">
          <div class="card-title">Active Agents</div>
          <div class="card-value" id="active-agents">0</div>
        </div>
        <div class="card">
          <div class="card-title">Tool Usages</div>
          <div class="card-value" id="tool-usages">0</div>
        </div>
        <div class="card">
          <div class="card-title">Errors</div>
          <div class="card-value" id="error-count">0</div>
        </div>
        <div class="card">
          <div class="card-title">Avg Response</div>
          <div class="card-value" id="avg-response">0 ms</div>
        </div>
      </section>
      
      <section class="active-agents">
        <h2>Active Agents</h2>
        <div id="agents-list" class="agents-container">
          <div class="no-data">No active agents</div>
        </div>
      </section>
      
      <section class="active-tools">
        <h2>Active Tool Executions</h2>
        <div id="active-tools-list" class="tools-container">
          <div class="no-data">No active tool executions</div>
        </div>
      </section>
      
      <section class="recent-tools">
        <h2>Recent Tool Usage</h2>
        <div id="recent-tools-list" class="recent-tools-container">
          <div class="no-data">No recent tool usage</div>
        </div>
      </section>
      
      <section class="tool-metrics">
        <h2>Tool Usage Metrics</h2>
        <div id="tool-metrics-list" class="tools-metrics-container">
          <div class="no-data">No tool metrics available</div>
        </div>
      </section>
      
      <section class="backend-settings">
        <h2>Telemetry Backend</h2>
        <div class="form-row">
          <div class="form-control">
            <label class="switch">
              <input type="checkbox" id="backend-toggle">
              <span class="slider round"></span>
            </label>
            <span>Enable Backend</span>
          </div>
        </div>
        <div class="form-row">
          <div class="form-control">
            <label for="backend-url">Backend URL:</label>
            <input type="text" id="backend-url" placeholder="http://localhost:3000/api/telemetry">
          </div>
        </div>
        <div class="form-row">
          <button id="save-backend-settings">Save Settings</button>
        </div>
      </section>
      
      <footer>
        <button id="refresh-button">
          <i class="codicon codicon-refresh"></i>
          Refresh
        </button>
      </footer>
      
      <script nonce="${nonce}" src="${scriptUri}"></script>
    </body>
    </html>`;
  }

  /**
   * Clean up resources when the extension is deactivated
   */
  public dispose() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
  }
}

/**
 * Generate a nonce string
 */
function getNonce() {
  let text = '';
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}


==============================================
FILE: ./src/vscode-extension/monitoring/AgentMonitor.ts
==============================================

import * as vscode from 'vscode';
import { Logger } from '../core/logging';
import { TelemetryService } from '../core/telemetry';
import { v4 as uuidv4 } from 'uuid';

/**
 * AgentMetrics holds monitoring data for AI agents, including tool usage,
 * response times, errors, and active agent tracking.
 */
export interface AgentMetrics {
  toolUsage: Map<string, number>;
  responseTime: number[];
  errorCount: number;
  activeAgents: string[];
  // New metrics for enhanced monitoring
  toolSuccessRate: Map<string, { success: number, failure: number }>;
  responseTimeByTool: Map<string, number[]>;
  activeToolExecutions: Map<string, { startTime: number, toolId: string }>;
  mostRecentTools: { agentId: string, toolId: string, timestamp: number, success: boolean }[];
}

/**
 * Status of an agent
 */
export enum AgentStatus {
  ACTIVE = 'active',
  IDLE = 'idle',
  ERROR = 'error'
}

/**
 * Interface for tool execution tracking
 */
export interface ToolExecution {
  agentId: string;
  toolId: string;
  startTime: number;
  endTime?: number;
  success?: boolean;
  error?: Error;
  metadata?: Record<string, any>;
  traceId?: string;
}

/**
 * AgentMonitor provides singleton monitoring for all AI agents.
 */
export class AgentMonitor {
  private static instance: AgentMonitor;
  private metrics: AgentMetrics;
  private logger: Logger;
  private telemetry: TelemetryService;
  private enabled: boolean = true;
  private backendEnabled: boolean = false;
  private backendUrl: string = '';
  private eventQueue: any[] = [];
  private flushInterval: NodeJS.Timeout | null = null;
  
  private constructor() {
    this.logger = Logger.getInstance();
    this.telemetry = TelemetryService.getInstance();
    this.metrics = {
      toolUsage: new Map(),
      responseTime: [],
      errorCount: 0,
      activeAgents: [],
      // Initialize new metrics
      toolSuccessRate: new Map(),
      responseTimeByTool: new Map(),
      activeToolExecutions: new Map(),
      mostRecentTools: []
    };
    
    // Initialize settings
    this.loadSettings();
    
    // Start flush interval if backend is enabled
    if (this.backendEnabled) {
      this.startFlushInterval();
    }
    
    // Listen to configuration changes
    vscode.workspace.onDidChangeConfiguration(e => {
      if (e.affectsConfiguration('theFuse')) {
        this.loadSettings();
      }
    });
  }

  /**
   * Load settings from VS Code configuration
   */
  private loadSettings(): void {
    const config = vscode.workspace.getConfiguration('theFuse');
    this.enabled = config.get<boolean>('agentMonitoringEnabled', true);
    this.backendEnabled = config.get<boolean>('telemetryBackendEnabled', false);
    this.backendUrl = config.get<string>('telemetryBackendUrl', 'http://localhost:3000/api/telemetry');
    
    // If backend was just enabled, start flush interval
    if (this.backendEnabled && !this.flushInterval) {
      this.startFlushInterval();
    }
    // If backend was just disabled, stop flush interval
    else if (!this.backendEnabled && this.flushInterval) {
      this.stopFlushInterval();
    }
  }

  /**
   * Start the interval to flush events to the backend
   */
  private startFlushInterval(): void {
    if (this.flushInterval) {
      clearInterval(this.flushInterval);
    }
    
    this.flushInterval = setInterval(() => {
      this.flushEvents();
    }, 5000); // Flush every 5 seconds
  }

  /**
   * Stop the flush interval
   */
  private stopFlushInterval(): void {
    if (this.flushInterval) {
      clearInterval(this.flushInterval);
      this.flushInterval = null;
    }
  }

  /**
   * Flush queued events to the backend
   */
  private async flushEvents(): Promise<void> {
    if (!this.backendEnabled || this.eventQueue.length === 0) {
      return;
    }
    
    try {
      const events = [...this.eventQueue];
      this.eventQueue = [];
      
      const response = await fetch(`${this.backendUrl}/events`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ events })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to send events: ${response.statusText}`);
      }
      
      const result = await response.json();
      this.logger.info('Telemetry', `Sent ${result.processed} events to telemetry backend`);
    } catch (error) {
      this.logger.error('Failed to send events to backend:', error);
      // Re-queue the events for next attempt
      this.eventQueue.push(...this.eventQueue);
    }
  }

  public static getInstance(): AgentMonitor {
    if (!AgentMonitor.instance) {
      AgentMonitor.instance = new AgentMonitor();
    }
    return AgentMonitor.instance;
  }

  public setEnabled(enabled: boolean): void {
    this.enabled = enabled;
    vscode.workspace.getConfiguration('theFuse').update(
      'agentMonitoringEnabled', enabled,
      vscode.ConfigurationTarget.Global
    );
  }

  public isEnabled(): boolean {
    return this.enabled;
  }
  
  /**
   * Configure backend telemetry settings
   */
  public setBackendSettings(enabled: boolean, url?: string): void {
    this.backendEnabled = enabled;
    if (url) {
      this.backendUrl = url;
    }
    
    const config = vscode.workspace.getConfiguration('theFuse');
    config.update('telemetryBackendEnabled', enabled, vscode.ConfigurationTarget.Global);
    if (url) {
      config.update('telemetryBackendUrl', url, vscode.ConfigurationTarget.Global);
    }
    
    // Handle interval based on new settings
    if (enabled && !this.flushInterval) {
      this.startFlushInterval();
    } else if (!enabled && this.flushInterval) {
      this.stopFlushInterval();
    }
  }

  /**
   * Track usage of a specific tool by an agent
   */
  public trackToolUsage(agentId: string, toolId: string, executionTime: number): void {
    if (!this.enabled) return;
    const key = `${agentId}:${toolId}`;
    const count = this.metrics.toolUsage.get(key) || 0;
    this.metrics.toolUsage.set(key, count + 1);
    this.metrics.responseTime.push(executionTime);
    this.telemetry.trackEvent('agent_tool_execution', { agentId, toolId, executionTime: executionTime.toString() });
    
    // Add to recent tools
    this.addRecentTool(agentId, toolId, true);
    
    // Add to backend queue if enabled
    if (this.backendEnabled) {
      this.queueEvent({
        id: uuidv4(),
        type: 'tool_usage',
        timestamp: Date.now(),
        source: 'vscode-extension',
        sourceId: agentId,
        metadata: {
          toolId,
          executionTime,
          success: true
        }
      });
    }
  }
  
  /**
   * Start tracking a tool execution
   */
  public startToolExecution(agentId: string, toolId: string, metadata?: Record<string, any>, traceId?: string): string {
    if (!this.enabled) return '';
    
    const executionId = uuidv4();
    const startTime = Date.now();
    
    // Track active execution
    this.metrics.activeToolExecutions.set(executionId, {
      startTime,
      toolId
    });
    
    // Queue start event if backend enabled
    if (this.backendEnabled) {
      this.queueEvent({
        id: executionId,
        type: 'tool_usage',
        timestamp: startTime,
        source: 'vscode-extension',
        sourceId: agentId,
        metadata: {
          toolId,
          stage: 'start',
          traceId,
          ...metadata
        }
      });
    }
    
    return executionId;
  }
  
  /**
   * Complete a tool execution (success or failure)
   */
  public completeToolExecution(
    executionId: string, 
    agentId: string, 
    success: boolean, 
    error?: Error,
    metadata?: Record<string, any>
  ): void {
    if (!this.enabled) return;
    
    const execution = this.metrics.activeToolExecutions.get(executionId);
    if (!execution) {
      this.logger.warn(`No active execution found for ID ${executionId}`);
      return;
    }
    
    const { toolId, startTime } = execution;
    const endTime = Date.now();
    const executionTime = endTime - startTime;
    
    // Update tool usage counts
    const key = `${agentId}:${toolId}`;
    const count = this.metrics.toolUsage.get(key) || 0;
    this.metrics.toolUsage.set(key, count + 1);
    
    // Update response times
    this.metrics.responseTime.push(executionTime);
    
    // Update tool-specific response times
    const toolResponseTimes = this.metrics.responseTimeByTool.get(toolId) || [];
    toolResponseTimes.push(executionTime);
    this.metrics.responseTimeByTool.set(toolId, toolResponseTimes);
    
    // Update success rate
    const successRate = this.metrics.toolSuccessRate.get(toolId) || { success: 0, failure: 0 };
    if (success) {
      successRate.success++;
    } else {
      successRate.failure++;
    }
    this.metrics.toolSuccessRate.set(toolId, successRate);
    
    // Add to recent tools
    this.addRecentTool(agentId, toolId, success);
    
    // Remove from active executions
    this.metrics.activeToolExecutions.delete(executionId);
    
    // Track via telemetry service
    this.telemetry.trackEvent('agent_tool_execution', { 
      agentId, 
      toolId, 
      executionTime: executionTime.toString(),
      success: success.toString()
    });
    
    // Track error if applicable
    if (!success && error) {
      this.trackError(agentId, error);
    }
    
    // Queue completion event if backend enabled
    if (this.backendEnabled) {
      this.queueEvent({
        id: uuidv4(),
        type: 'tool_usage',
        timestamp: endTime,
        source: 'vscode-extension',
        sourceId: agentId,
        metadata: {
          toolId,
          executionId,
          executionTime,
          stage: 'complete',
          success,
          error: error ? error.message : undefined,
          ...metadata
        }
      });
    }
  }

  /**
   * Track an error encountered by an agent
   */
  public trackError(agentId: string, error: Error): void {
    if (!this.enabled) return;
    this.metrics.errorCount++;
    // Convert the error object to a string for the trackError method
    this.telemetry.trackError(error.message || 'Unknown error', agentId);
    
    // Queue error event if backend enabled
    if (this.backendEnabled) {
      this.queueEvent({
        id: uuidv4(),
        type: 'agent_status',
        timestamp: Date.now(),
        source: 'vscode-extension',
        sourceId: agentId,
        metadata: {
          status: AgentStatus.ERROR,
          error: error.message,
          stack: error.stack
        }
      });
    }
  }

  /**
   * Update the list of currently active agents
   */
  public updateActiveAgents(agents: string[]): void {
    if (!this.enabled) return;
    this.metrics.activeAgents = agents;
    this.telemetry.trackEvent('active_agents_updated', { count: agents.length.toString(), agents: agents.join(',') });
    
    // Queue agent status events if backend enabled
    if (this.backendEnabled) {
      for (const agentId of agents) {
        this.queueEvent({
          id: uuidv4(),
          type: 'agent_status',
          timestamp: Date.now(),
          source: 'vscode-extension',
          sourceId: agentId,
          metadata: {
            status: AgentStatus.ACTIVE
          }
        });
      }
    }
  }
  
  /**
   * Update status for a specific agent
   */
  public updateAgentStatus(agentId: string, status: AgentStatus): void {
    if (!this.enabled) return;
    
    // Update active agents list if necessary
    if (status === AgentStatus.ACTIVE) {
      if (!this.metrics.activeAgents.includes(agentId)) {
        this.metrics.activeAgents.push(agentId);
      }
    } else {
      this.metrics.activeAgents = this.metrics.activeAgents.filter(id => id !== agentId);
    }
    
    this.telemetry.trackEvent('agent_status_change', { agentId, status });
    
    // Queue agent status event if backend enabled
    if (this.backendEnabled) {
      this.queueEvent({
        id: uuidv4(),
        type: 'agent_status',
        timestamp: Date.now(),
        source: 'vscode-extension',
        sourceId: agentId,
        metadata: {
          status
        }
      });
    }
  }
  
  /**
   * Add a tool usage to the recent tools list
   */
  private addRecentTool(agentId: string, toolId: string, success: boolean): void {
    this.metrics.mostRecentTools.unshift({
      agentId,
      toolId,
      timestamp: Date.now(),
      success
    });
    
    // Keep only the 50 most recent
    if (this.metrics.mostRecentTools.length > 50) {
      this.metrics.mostRecentTools.pop();
    }
  }
  
  /**
   * Queue an event to be sent to the backend
   */
  private queueEvent(event: any): void {
    this.eventQueue.push(event);
    
    // If queue is getting large, trigger a flush
    if (this.eventQueue.length >= 50) {
      this.flushEvents();
    }
  }

  /**
   * Get the current monitoring metrics for agents
   */
  public getMetrics(): AgentMetrics {
    // return metrics even if disabled
    return this.metrics;
  }
  
  /**
   * Get success rate for a specific tool
   */
  public getToolSuccessRate(toolId: string): { success: number, failure: number, rate: number } {
    const stats = this.metrics.toolSuccessRate.get(toolId) || { success: 0, failure: 0 };
    const total = stats.success + stats.failure;
    const rate = total === 0 ? 0 : stats.success / total;
    return { ...stats, rate };
  }
  
  /**
   * Get average response time for a specific tool
   */
  public getToolAverageResponseTime(toolId: string): number {
    const times = this.metrics.responseTimeByTool.get(toolId) || [];
    if (times.length === 0) return 0;
    return times.reduce((sum, time) => sum + time, 0) / times.length;
  }
  
  /**
   * Get the most recent tool usages
   */
  public getRecentToolUsage(limit: number = 10): typeof this.metrics.mostRecentTools {
    return this.metrics.mostRecentTools.slice(0, limit);
  }
}



==============================================
FILE: ./src/vscode-extension/monitoring/FuseMonitoringClient.ts
==============================================

import * as vscode from 'vscode';
import { v4 as uuidv4 } from 'uuid';

interface TraceEvent {
  id: string;
  parentId?: string;
  traceId: string;
  name: string;
  startTime: number;
  endTime?: number;
  metadata: Record<string, any>;
  status: 'running' | 'success' | 'error';
  error?: Error;
}

interface GenerationEvent extends TraceEvent {
  type: 'generation';
  prompt: string;
  completion?: string;
  model: string;
  provider: string;
  tokens?: {
    prompt?: number;
    completion?: number;
    total?: number;
  };
  cost?: number;
}

interface SpanEvent extends TraceEvent {
  type: 'span';
}

interface MetricsData {
  totalGenerations: number;
  avgResponseTime: number;
  errorRate: number;
  providerUsage: Record<string, number>;
  modelUsage: Record<string, number>;
}

/**
 * Create a Fuse Monitoring Client
 */
export function createFuseMonitoringClient(
  context: vscode.ExtensionContext,
  outputChannel?: vscode.OutputChannel
): FuseMonitoringClient {
  return new FuseMonitoringClient(context, outputChannel);
}

/**
 * FuseMonitoringClient - The New Fuse's built-in monitoring solution
 *
 * Provides tracing, telemetry, and performance monitoring for LLM operations
 * with optional Langfuse integration for advanced analytics.
 */
export class FuseMonitoringClient {
  private enabled: boolean = true;
  private events: (GenerationEvent | SpanEvent)[] = [];
  private activeTraces: Map<string, TraceEvent> = new Map();
  private sessionId: string;
  private backendConnection: {
    enabled: boolean;
    url: string;
  };
  private langfuseConnection: {
    enabled: boolean;
    publicKey: string;
    secretKey: string;
    host: string;
  };
  private langfuseClient: any = null;
  private outputChannel: vscode.OutputChannel;

  constructor(
    private context: vscode.ExtensionContext,
    outputChannel?: vscode.OutputChannel
  ) {
    this.outputChannel = outputChannel || vscode.window.createOutputChannel('Fuse Monitoring');
    this.sessionId = uuidv4();

    // Load settings
    const config = vscode.workspace.getConfiguration('theFuse');
    this.enabled = config.get<boolean>('monitoringEnabled', true);

    this.backendConnection = {
      enabled: config.get<boolean>('connectToBackendMonitoring', false),
      url: config.get<string>('monitoringBackendUrl', '')
    };

    this.langfuseConnection = {
      enabled: config.get<boolean>('langfuseEnabled', false),
      publicKey: config.get<string>('langfusePublicKey', ''),
      secretKey: config.get<string>('langfuseSecretKey', ''),
      host: config.get<string>('langfuseHost', 'https://langfuse.com')
    };

    // Initialize Langfuse if enabled
    this.initializeLangfuse();

    // Setup config change listener
    context.subscriptions.push(
      vscode.workspace.onDidChangeConfiguration(e => {
        if (e.affectsConfiguration('theFuse')) {
          this.updateSettings();
        }
      })
    );
  }

  private updateSettings() {
    const config = vscode.workspace.getConfiguration('theFuse');
    this.enabled = config.get<boolean>('monitoringEnabled', true);

    this.backendConnection = {
      enabled: config.get<boolean>('connectToBackendMonitoring', false),
      url: config.get<string>('monitoringBackendUrl', '')
    };

    const langfuseEnabled = config.get<boolean>('langfuseEnabled', false);
    if (langfuseEnabled !== this.langfuseConnection.enabled ||
        config.get<string>('langfusePublicKey', '') !== this.langfuseConnection.publicKey ||
        config.get<string>('langfuseSecretKey', '') !== this.langfuseConnection.secretKey ||
        config.get<string>('langfuseHost', 'https://langfuse.com') !== this.langfuseConnection.host) {

      this.langfuseConnection = {
        enabled: langfuseEnabled,
        publicKey: config.get<string>('langfusePublicKey', ''),
        secretKey: config.get<string>('langfuseSecretKey', ''),
        host: config.get<string>('langfuseHost', 'https://langfuse.com')
      };

      // Re-initialize Langfuse
      this.initializeLangfuse();
    }
  }

  private async initializeLangfuse() {
    try {
      if (this.langfuseConnection.enabled &&
          this.langfuseConnection.publicKey &&
          this.langfuseConnection.secretKey) {
        // Dynamically import Langfuse to avoid dependency if not used
        const { Langfuse } = await import('langfuse');

        this.langfuseClient = new Langfuse({
          publicKey: this.langfuseConnection.publicKey,
          secretKey: this.langfuseConnection.secretKey,
          host: this.langfuseConnection.host || 'https://langfuse.com',
          flushAt: 10,
          flushInterval: 5000
        });

        console.log('[FuseMonitoring] Langfuse integration enabled');
      } else {
        this.langfuseClient = null;
      }
    } catch (error) {
      console.error('[FuseMonitoring] Failed to initialize Langfuse:', error);
      this.langfuseClient = null;

      vscode.window.showErrorMessage(
        'Failed to initialize Langfuse integration. Please make sure the package is installed.'
      );
    }
  }

  /**
   * Start a new trace for monitoring an operation
   */
  public startTrace(name: string, metadata: Record<string, any> = {}): string {
    if (!this.enabled) {
      return uuidv4(); // Return a dummy ID when disabled
    }

    const traceId = uuidv4();
    const event: SpanEvent = {
      id: traceId,
      traceId,
      type: 'span',
      name,
      startTime: Date.now(),
      metadata: {
        ...metadata,
        sessionId: this.sessionId
      },
      status: 'running'
    };

    this.activeTraces.set(traceId, event);
    this.events.push(event);

    // Send to backend if enabled
    this.sendToBackend('trace.start', event);

    // Send to Langfuse if enabled
    if (this.langfuseClient) {
      try {
        this.langfuseClient.trace({
          id: traceId,
          name,
          metadata
        });
      } catch (error) {
        console.error('[FuseMonitoring] Langfuse trace error:', error);
      }
    }

    return traceId;
  }

  /**
   * End a trace and record its result
   */
  public endTrace(traceId: string, status: 'success' | 'error' = 'success', error?: Error): void {
    if (!this.enabled) {
      return;
    }

    const trace = this.activeTraces.get(traceId);
    if (!trace) {
      console.warn(`[FuseMonitoring] Attempted to end unknown trace: ${traceId}`);
      return;
    }

    trace.endTime = Date.now();
    trace.status = status;
    if (error) {
      trace.error = error;
    }

    this.activeTraces.delete(traceId);

    // Send to backend if enabled
    this.sendToBackend('trace.end', trace);

    // Send to Langfuse if enabled
    if (this.langfuseClient) {
      try {
        this.langfuseClient.getTrace(traceId).update({
          status: status === 'error' ? 'error' : 'success',
          statusMessage: error?.message
        });
      } catch (error) {
        console.error('[FuseMonitoring] Langfuse trace update error:', error);
      }
    }
  }

  /**
   * Create a child span within a trace
   */
  public startSpan(parentId: string, name: string, metadata: Record<string, any> = {}): string {
    if (!this.enabled) {
      return uuidv4(); // Return a dummy ID when disabled
    }

    const parent = this.activeTraces.get(parentId);
    if (!parent) {
      console.warn(`[FuseMonitoring] Parent trace not found: ${parentId}`);
      return this.startTrace(name, metadata); // Start a new trace instead
    }

    const spanId = uuidv4();
    const event: SpanEvent = {
      id: spanId,
      parentId,
      traceId: parent.traceId,
      type: 'span',
      name,
      startTime: Date.now(),
      metadata,
      status: 'running'
    };

    this.activeTraces.set(spanId, event);
    this.events.push(event);

    // Send to backend if enabled
    this.sendToBackend('span.start', event);

    // Send to Langfuse if enabled
    if (this.langfuseClient) {
      try {
        this.langfuseClient.getTrace(parent.traceId).span({
          id: spanId,
          name,
          metadata
        });
      } catch (error) {
        console.error('[FuseMonitoring] Langfuse span error:', error);
      }
    }

    return spanId;
  }

  /**
   * End a span and record its result
   */
  public endSpan(spanId: string, status: 'success' | 'error' = 'success', error?: Error): void {
    if (!this.enabled) {
      return;
    }

    const span = this.activeTraces.get(spanId);
    if (!span) {
      console.warn(`[FuseMonitoring] Attempted to end unknown span: ${spanId}`);
      return;
    }

    span.endTime = Date.now();
    span.status = status;
    if (error) {
      span.error = error;
    }

    this.activeTraces.delete(spanId);

    // Send to backend if enabled
    this.sendToBackend('span.end', span);

    // Send to Langfuse if enabled
    if (this.langfuseClient) {
      try {
        this.langfuseClient.getSpan(spanId).update({
          status: status === 'error' ? 'error' : 'success',
          statusMessage: error?.message
        });
      } catch (error) {
        console.error('[FuseMonitoring] Langfuse span update error:', error);
      }
    }
  }

  /**
   * Record an LLM generation
   */
  public recordGeneration(
    traceId: string,
    prompt: string,
    model: string,
    provider: string,
    options: {
      completion?: string;
      tokens?: {
        prompt?: number;
        completion?: number;
        total?: number;
      };
      cost?: number;
      metadata?: Record<string, any>;
      status?: 'success' | 'error';
      error?: Error;
    } = {}
  ): string {
    if (!this.enabled) {
      return uuidv4(); // Return a dummy ID when disabled
    }

    const parent = this.activeTraces.get(traceId);
    const generationId = uuidv4();

    const event: GenerationEvent = {
      id: generationId,
      parentId: traceId,
      traceId: parent?.traceId || traceId,
      type: 'generation',
      name: `${provider} - ${model}`,
      startTime: Date.now(),
      endTime: Date.now(),
      prompt,
      completion: options.completion,
      model,
      provider,
      tokens: options.tokens,
      cost: options.cost,
      metadata: options.metadata || {},
      status: options.status || 'success',
      error: options.error
    };

    this.events.push(event);

    // Send to backend if enabled
    this.sendToBackend('generation.record', event);

    // Send to Langfuse if enabled
    if (this.langfuseClient) {
      try {
        const parentTrace = parent?.traceId || traceId;
        this.langfuseClient.getTrace(parentTrace).generation({
          id: generationId,
          name: `${provider} - ${model}`,
          startTime: new Date(event.startTime),
          endTime: new Date(event.endTime || event.startTime),
          model,
          modelParameters: options.metadata,
          prompt: [{ role: 'user', content: prompt }],
          completion: options.completion,
          usage: options.tokens ? {
            promptTokens: options.tokens.prompt,
            completionTokens: options.tokens.completion,
            totalTokens: options.tokens.total
          } : undefined,
          metadata: options.metadata
        });
      } catch (error) {
        console.error('[FuseMonitoring] Langfuse generation error:', error);
      }
    }

    return generationId;
  }

  /**
   * Get metrics for the current session
   */
  public getSessionMetrics(): MetricsData {
    if (!this.enabled || this.events.length === 0) {
      return {
        totalGenerations: 0,
        avgResponseTime: 0,
        errorRate: 0,
        providerUsage: {},
        modelUsage: {}
      };
    }

    const generations = this.events.filter(e => e.type === 'generation') as GenerationEvent[];
    const totalGenerations = generations.length;

    // Calculate response times for completed generations
    const responseTimes = generations
      .filter(g => g.startTime && g.endTime)
      .map(g => g.endTime! - g.startTime);

    const avgResponseTime = responseTimes.length > 0
      ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
      : 0;

    // Calculate error rate
    const errorCount = generations.filter(g => g.status === 'error').length;
    const errorRate = totalGenerations > 0 ? errorCount / totalGenerations : 0;

    // Calculate provider and model usage
    const providerUsage: Record<string, number> = {};
    const modelUsage: Record<string, number> = {};

    for (const gen of generations) {
      providerUsage[gen.provider] = (providerUsage[gen.provider] || 0) + 1;
      modelUsage[gen.model] = (modelUsage[gen.model] || 0) + 1;
    }

    return {
      totalGenerations,
      avgResponseTime,
      errorRate,
      providerUsage,
      modelUsage
    };
  }

  /**
   * Clear all monitoring data
   */
  public clearAllData(): void {
    this.events = [];
    this.activeTraces.clear();
    console.log('[FuseMonitoring] All monitoring data cleared');
  }

  /**
   * Score a generation with user feedback
   */
  public scoreGeneration(options: {
    generationId: string;
    name: string;
    value: number;
    comment?: string;
  }): void {
    if (!this.enabled) {
      return;
    }

    console.log(`[FuseMonitoring] Scoring generation ${options.generationId}: ${options.value}`);

    // Send to backend if enabled
    this.sendToBackend('generation.score', options);

    // Send to Langfuse if enabled
    if (this.langfuseClient) {
      try {
        this.langfuseClient.score({
          id: `score-${Date.now()}`,
          traceId: options.generationId,
          name: options.name,
          value: options.value,
          comment: options.comment
        });
      } catch (error) {
        console.error('[FuseMonitoring] Langfuse score error:', error);
      }
    }
  }

  /**
   * Open the monitoring dashboard
   */
  public openDashboard(): void {
    // Create and show a webview panel for the dashboard
    const panel = vscode.window.createWebviewPanel(
      'fuseMonitoringDashboard',
      'The New Fuse Monitoring',
      vscode.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true
      }
    );

    // Get metrics data
    const metrics = this.getSessionMetrics();

    // Generate HTML for the dashboard
    panel.webview.html = this.generateDashboardHtml(metrics);

    // Handle messages from the webview
    panel.webview.onDidReceiveMessage(message => {
      switch (message.command) {
        case 'refresh':
          panel.webview.html = this.generateDashboardHtml(this.getSessionMetrics());
          break;
        case 'clearData':
          this.clearAllData();
          panel.webview.html = this.generateDashboardHtml(this.getSessionMetrics());
          break;
      }
    });
  }

  /**
   * Set whether monitoring is enabled
   */
  public setEnabled(enabled: boolean): void {
    this.enabled = enabled;
    vscode.workspace.getConfiguration('theFuse').update(
      'monitoringEnabled',
      enabled,
      vscode.ConfigurationTarget.Global
    );
  }

  /**
   * Check if monitoring is enabled
   */
  public isEnabled(): boolean {
    return this.enabled;
  }

  /**
   * Configure backend connection
   */
  public setBackendEnabled(enabled: boolean, url?: string): void {
    this.backendConnection.enabled = enabled;
    if (url) {
      this.backendConnection.url = url;
    }

    vscode.workspace.getConfiguration('theFuse').update(
      'connectToBackendMonitoring',
      enabled,
      vscode.ConfigurationTarget.Global
    );

    if (url) {
      vscode.workspace.getConfiguration('theFuse').update(
        'monitoringBackendUrl',
        url,
        vscode.ConfigurationTarget.Global
      );
    }
  }

  /**
   * Send event data to the backend monitoring service
   */
  private async sendToBackend(eventType: string, data: any): Promise<void> {
    if (!this.backendConnection.enabled || !this.backendConnection.url) {
      return;
    }

    try {
      const response = await fetch(this.backendConnection.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          eventType,
          data,
          timestamp: Date.now(),
          sessionId: this.sessionId
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to send monitoring data: ${response.statusText}`);
      }
    } catch (error) {
      console.error('[FuseMonitoring] Backend connection error:', error);
    }
  }

  /**
   * Generate HTML for the monitoring dashboard
   */
  private generateDashboardHtml(metrics: MetricsData): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>The New Fuse Monitoring</title>
        <style>
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            padding: 20px;
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
          }
          h1, h2, h3 {
            color: var(--vscode-editor-foreground);
          }
          .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
          }
          .card {
            background-color: var(--vscode-editor-inactiveSelectionBackground);
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          }
          .metric {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
          }
          .label {
            font-size: 14px;
            color: var(--vscode-descriptionForeground);
          }
          .chart {
            height: 200px;
            margin-top: 20px;
          }
          button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 8px 12px;
            border-radius: 2px;
            cursor: pointer;
            margin-right: 10px;
          }
          button:hover {
            background-color: var(--vscode-button-hoverBackground);
          }
          table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
          }
          th, td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid var(--vscode-panel-border);
          }
          th {
            background-color: var(--vscode-editor-inactiveSelectionBackground);
          }
        </style>
      </head>
      <body>
        <h1>The New Fuse Monitoring Dashboard</h1>

        <div class="actions">
          <button id="refresh">Refresh Data</button>
          <button id="clear">Clear All Data</button>
        </div>

        <h2>Session Overview</h2>
        <div class="dashboard">
          <div class="card">
            <div class="label">Total Generations</div>
            <div class="metric">${metrics.totalGenerations}</div>
          </div>
          <div class="card">
            <div class="label">Average Response Time</div>
            <div class="metric">${Math.round(metrics.avgResponseTime)}ms</div>
          </div>
          <div class="card">
            <div class="label">Error Rate</div>
            <div class="metric">${(metrics.errorRate * 100).toFixed(1)}%</div>
          </div>
        </div>

        <h2>Provider Usage</h2>
        <div class="card">
          <table>
            <thead>
              <tr>
                <th>Provider</th>
                <th>Count</th>
                <th>Percentage</th>
              </tr>
            </thead>
            <tbody>
              ${Object.entries(metrics.providerUsage).map(([provider, count]) => `
                <tr>
                  <td>${provider}</td>
                  <td>${count}</td>
                  <td>${metrics.totalGenerations ? ((count / metrics.totalGenerations) * 100).toFixed(1) : 0}%</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <h2>Model Usage</h2>
        <div class="card">
          <table>
            <thead>
              <tr>
                <th>Model</th>
                <th>Count</th>
                <th>Percentage</th>
              </tr>
            </thead>
            <tbody>
              ${Object.entries(metrics.modelUsage).map(([model, count]) => `
                <tr>
                  <td>${model}</td>
                  <td>${count}</td>
                  <td>${metrics.totalGenerations ? ((count / metrics.totalGenerations) * 100).toFixed(1) : 0}%</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <script>
          (function() {
            const vscode = acquireVsCodeApi();

            document.getElementById('refresh').addEventListener('click', () => {
              vscode.postMessage({ command: 'refresh' });
            });

            document.getElementById('clear').addEventListener('click', () => {
              if (confirm('Are you sure you want to clear all monitoring data?')) {
                vscode.postMessage({ command: 'clearData' });
              }
            });
          })();
        </script>
      </body>
      </html>
    `;
  }
}

// Add type declaration for langfuse until it's properly installed
declare module 'langfuse' {
  export class Langfuse {
    constructor(options: { publicKey: string; secretKey: string; baseUrl?: string });
    trace(id: string, options?: any): any;
    score(options: any): any;
    flush(): Promise<void>;
  }
}


==============================================
FILE: ./src/vscode-extension/monitoring/MonitoringSettingsProvider.ts
==============================================

import * as vscode from 'vscode';
import { AgentMonitor } from './AgentMonitor';
import { LLMMonitoringClient } from './llm-monitoring-client';

/**
 * MonitoringSettingsProvider
 * 
 * Provides a webview for managing monitoring settings in VS Code,
 * including toggling monitoring features and configuring Langfuse integration.
 */
export class MonitoringSettingsProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = 'thefuse.monitoringSettings';
  private _view?: vscode.WebviewView;

  constructor(
    private readonly _context: vscode.ExtensionContext,
    private readonly _monitoringClient: any,
    private readonly _agentMonitor: AgentMonitor,
    private readonly _llmMonitor: LLMMonitoringClient
  ) {}

  public resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken
  ) {
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [
        vscode.Uri.joinPath(this._context.extensionUri, 'media')
      ]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    // Handle messages from the webview
    webviewView.webview.onDidReceiveMessage(async message => {
      switch (message.command) {
        case 'toggleMonitoring':
          this._monitoringClient.setEnabled(message.enabled);
          break;
        case 'toggleBackendConnection':
          this._monitoringClient.setBackendEnabled(message.enabled);
          break;
        case 'setBackendUrl':
          this._monitoringClient.setBackendEnabled(true, message.url);
          break;
        case 'toggleAgentMonitoring':
          this._agentMonitor.setEnabled(message.enabled);
          break;
        case 'toggleLLMMonitoring':
          this._llmMonitor.setEnabled(message.enabled);
          break;
        case 'toggleLangfuse':
          this.updateLangfuseSettings(message.enabled);
          break;
        case 'setLangfuseCredentials':
          this.updateLangfuseCredentials(message.publicKey, message.secretKey, message.host);
          break;
        case 'clearData':
          this._monitoringClient.clearAllData();
          vscode.window.showInformationMessage('Monitoring data cleared');
          break;
        case 'getSettings':
          this.sendCurrentSettings();
          break;
      }
    });

    // Send current settings when view becomes visible
    this.sendCurrentSettings();
  }

  private sendCurrentSettings() {
    if (!this._view) {
      return;
    }

    const config = vscode.workspace.getConfiguration('theFuse');
    const enabled = this._monitoringClient.isEnabled();
    const backendEnabled = config.get<boolean>('connectToBackendMonitoring', false);
    const backendUrl = config.get<string>('monitoringBackendUrl', '');
    const langfuseEnabled = config.get<boolean>('langfuseEnabled', false);
    const langfusePublicKey = config.get<string>('langfusePublicKey', '');
    const langfuseSecretKey = config.get<string>('langfuseSecretKey', '');
    const langfuseHost = config.get<string>('langfuseHost', 'https://langfuse.com');

    this._view.webview.postMessage({
      command: 'updateSettings',
      settings: {
        nativeEnabled: enabled,
        backendEnabled,
        backendUrl,
        agentEnabled: this._agentMonitor.isEnabled(),
        llmEnabled: this._llmMonitor.isEnabled(),
        langfuseEnabled,
        langfusePublicKey,
        langfuseSecretKey,
        langfuseHost
      }
    });

    // Also send metrics
    const nativeMetrics = this._monitoringClient.getSessionMetrics();
    const agentMetrics = this._agentMonitor.getMetrics();
    const llmMetrics = this._llmMonitor.getSessionMetrics();
    this._view.webview.postMessage({
      command: 'updateMetrics',
      metrics: { nativeMetrics, agentMetrics, llmMetrics }
    });
  }

  private async updateLangfuseSettings(enabled: boolean) {
    await vscode.workspace.getConfiguration('theFuse').update(
      'langfuseEnabled',
      enabled,
      vscode.ConfigurationTarget.Global
    );

    if (enabled) {
      const publicKey = await vscode.window.showInputBox({
        prompt: 'Enter your Langfuse Public Key',
        placeHolder: 'pk_...'
      });

      if (!publicKey) {
        vscode.window.showWarningMessage('Langfuse Public Key is required');
        await vscode.workspace.getConfiguration('theFuse').update(
          'langfuseEnabled',
          false,
          vscode.ConfigurationTarget.Global
        );
        this.sendCurrentSettings();
        return;
      }

      const secretKey = await vscode.window.showInputBox({
        prompt: 'Enter your Langfuse Secret Key',
        placeHolder: 'sk_...',
        password: true
      });

      if (!secretKey) {
        vscode.window.showWarningMessage('Langfuse Secret Key is required');
        await vscode.workspace.getConfiguration('theFuse').update(
          'langfuseEnabled',
          false,
          vscode.ConfigurationTarget.Global
        );
        this.sendCurrentSettings();
        return;
      }

      const host = await vscode.window.showInputBox({
        prompt: 'Enter your Langfuse Host (optional)',
        placeHolder: 'https://langfuse.com',
        value: 'https://langfuse.com'
      });

      this.updateLangfuseCredentials(publicKey, secretKey, host || 'https://langfuse.com');
    }

    this.sendCurrentSettings();
  }

  private async updateLangfuseCredentials(publicKey: string, secretKey: string, host: string) {
    await vscode.workspace.getConfiguration('theFuse').update(
      'langfusePublicKey',
      publicKey,
      vscode.ConfigurationTarget.Global
    );

    await vscode.workspace.getConfiguration('theFuse').update(
      'langfuseSecretKey',
      secretKey,
      vscode.ConfigurationTarget.Global
    );

    await vscode.workspace.getConfiguration('theFuse').update(
      'langfuseHost',
      host,
      vscode.ConfigurationTarget.Global
    );

    vscode.window.showInformationMessage('Langfuse credentials updated');
    this.sendCurrentSettings();
  }

  private _getHtmlForWebview(webview: vscode.Webview) {
    return `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>The New Fuse Monitoring Settings</title>
        <style>
            body {
                font-family: var(--vscode-font-family);
                color: var(--vscode-foreground);
                padding: 10px;
            }
            .form-group {
                margin-bottom: 16px;
                display: flex;
                flex-direction: column;
            }
            .form-group label {
                margin-bottom: 8px;
            }
            .input-group {
                display: flex;
                flex-direction: column;
                margin-bottom: 12px;
            }
            input[type="text"], input[type="password"] {
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border: 1px solid var(--vscode-input-border);
                padding: 6px 8px;
                border-radius: 2px;
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                border: none;
                padding: 6px 12px;
                border-radius: 2px;
                cursor: pointer;
                margin-right: 8px;
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
            .section {
                border-bottom: 1px solid var(--vscode-panel-border);
                padding-bottom: 16px;
                margin-bottom: 16px;
            }
            .checkbox-container {
                display: flex;
                align-items: center;
            }
            .checkbox-container input {
                margin-right: 8px;
            }
            .metrics {
                background-color: var(--vscode-panel-background);
                padding: 12px;
                border-radius: 4px;
                font-family: var(--vscode-editor-font-family);
                font-size: var(--vscode-editor-font-size);
            }
            h3 {
                margin-top: 0;
            }
            .description {
                font-size: 0.9em;
                opacity: 0.8;
                margin-bottom: 12px;
            }
            .info-icon {
                display: inline-block;
                width: 16px;
                height: 16px;
                background-color: var(--vscode-badge-background);
                color: var(--vscode-badge-foreground);
                text-align: center;
                line-height: 16px;
                border-radius: 50%;
                font-size: 12px;
                margin-left: 5px;
                cursor: help;
            }
            .metrics-chart {
                height: 200px;
                width: 100%;
                margin-top: 10px;
                margin-bottom: 20px;
                background-color: var(--vscode-editor-background);
                position: relative;
            }
            .chart-bar {
                position: absolute;
                bottom: 0;
                background-color: var(--vscode-button-background);
                width: 30px;
                border-top-left-radius: 3px;
                border-top-right-radius: 3px;
            }
            .chart-label {
                position: absolute;
                bottom: -20px;
                font-size: 10px;
                text-align: center;
                width: 30px;
            }
            .export-btn {
                margin-top: 10px;
                background-color: var(--vscode-badge-background);
            }
        </style>
    </head>
    <body>
        <h2>The New Fuse Monitoring</h2>
        
        <div class="section">
            <div class="checkbox-container">
                <input type="checkbox" id="enable-native-monitoring" />
                <label for="enable-native-monitoring">Enable Native Fuse Monitoring</label>
                <span class="info-icon" title="Enables local tracking of AI operations without sending data externally">?</span>
            </div>
            <p class="description">
                Track LLM usage, performance, and errors to improve your experience.
                All monitoring data is stored locally by default.
            </p>
        </div>

        <div class="section">
            <h3>Native Monitoring</h3>
            <p class="description">
                The New Fuse's built-in monitoring system tracks LLM operations, 
                generations, and evaluations independently of third-party services.
            </p>
            
            <div class="checkbox-container">
                <input type="checkbox" id="enable-backend" />
                <label for="enable-backend">Connect to The New Fuse Backend</label>
            </div>
            
            <div class="input-group">
                <label for="backend-url">Backend URL</label>
                <input type="text" id="backend-url" placeholder="https://your-fuse-backend.com/monitoring" />
            </div>
            
            <button id="save-backend">Save Backend Settings</button>
        </div>

        <div class="section">
            <div class="checkbox-container">
                <input type="checkbox" id="enable-agent-monitoring" />
                <label for="enable-agent-monitoring">Enable Agent Monitoring</label>
            </div>
            <p class="description">
                Track agent interactions, tool usage, errors, and active agents across all AI agent adapters.
            </p>
        </div>
        <div class="section">
            <div class="checkbox-container">
                <input type="checkbox" id="enable-llm-monitoring" />
                <label for="enable-llm-monitoring">Enable LLM Monitoring</label>
            </div>
            <p class="description">
                Track LLM generation metrics, response times, and error rates separately.
            </p>
        </div>

        <div class="section">
            <h3>Langfuse Integration (Optional)</h3>
            <p class="description">
                Langfuse is a third-party monitoring service for LLMs. 
                This integration is optional and provides additional tracing 
                and evaluation capabilities.
            </p>
            
            <div class="checkbox-container">
                <input type="checkbox" id="enable-langfuse" />
                <label for="enable-langfuse">Enable Langfuse Integration</label>
            </div>
            
            <div id="langfuse-settings" style="display: none;">
                <div class="input-group">
                    <label for="langfuse-public-key">Public Key</label>
                    <input type="text" id="langfuse-public-key" placeholder="pk_..." />
                </div>
                
                <div class="input-group">
                    <label for="langfuse-secret-key">Secret Key</label>
                    <input type="password" id="langfuse-secret-key" placeholder="sk_..." />
                </div>
                
                <div class="input-group">
                    <label for="langfuse-host">Host (Optional)</label>
                    <input type="text" id="langfuse-host" placeholder="https://langfuse.com" />
                </div>
                
                <button id="save-langfuse">Save Langfuse Settings</button>
            </div>
        </div>

        <div class="section">
            <h3>Usage Data</h3>
            <div class="metrics">
                <pre id="metrics-display">Loading metrics...</pre>
            </div>
            
            <h4>Performance Visualization</h4>
            <div class="metrics-chart" id="response-time-chart">
                <!-- Chart will be generated here -->
            </div>
            
            <button id="export-data" class="export-btn">Export Monitoring Data</button>
            <button id="clear-data">Clear Monitoring Data</button>
        </div>

        <script>
            const vscode = acquireVsCodeApi();
            
            // Get all the UI elements
            const enableNativeCheckbox = document.getElementById('enable-native-monitoring');
            const enableBackendCheckbox = document.getElementById('enable-backend');
            const backendUrlInput = document.getElementById('backend-url');
            const saveBackendButton = document.getElementById('save-backend');
            const enableAgentCheckbox = document.getElementById('enable-agent-monitoring');
            const enableLLMCheckbox = document.getElementById('enable-llm-monitoring');
            const enableLangfuseCheckbox = document.getElementById('enable-langfuse');
            const langfuseSettingsDiv = document.getElementById('langfuse-settings');
            const langfusePublicKeyInput = document.getElementById('langfuse-public-key');
            const langfuseSecretKeyInput = document.getElementById('langfuse-secret-key');
            const langfuseHostInput = document.getElementById('langfuse-host');
            const saveLangfuseButton = document.getElementById('save-langfuse');
            const clearDataButton = document.getElementById('clear-data');
            const metricsDisplay = document.getElementById('metrics-display');
            const exportDataButton = document.getElementById('export-data');
            const responseTimeChart = document.getElementById('response-time-chart');
            
            // Initialize the UI with current settings and metrics
            vscode.postMessage({ command: 'getSettings' });
            vscode.postMessage({ command: 'getMetrics' });
            
            // Event listeners
            enableNativeCheckbox.addEventListener('change', () => {
                vscode.postMessage({ 
                    command: 'toggleMonitoring', 
                    enabled: enableNativeCheckbox.checked 
                });
            });
            
            enableBackendCheckbox.addEventListener('change', () => {
                vscode.postMessage({ 
                    command: 'toggleBackendConnection', 
                    enabled: enableBackendCheckbox.checked 
                });
            });
            
            saveBackendButton.addEventListener('click', () => {
                vscode.postMessage({ 
                    command: 'setBackendUrl', 
                    url: backendUrlInput.value 
                });
            });
            
            enableLangfuseCheckbox.addEventListener('change', () => {
                vscode.postMessage({ 
                    command: 'toggleLangfuse', 
                    enabled: enableLangfuseCheckbox.checked 
                });
                langfuseSettingsDiv.style.display = enableLangfuseCheckbox.checked ? 'block' : 'none';
            });
            
            saveLangfuseButton.addEventListener('click', () => {
                vscode.postMessage({ 
                    command: 'setLangfuseCredentials', 
                    publicKey: langfusePublicKeyInput.value,
                    secretKey: langfuseSecretKeyInput.value,
                    host: langfuseHostInput.value || 'https://langfuse.com'
                });
            });
            
            clearDataButton.addEventListener('click', () => {
                vscode.postMessage({ command: 'clearData' });
            });
            
            enableAgentCheckbox.addEventListener('change', () => {
                vscode.postMessage({ command: 'toggleAgentMonitoring', enabled: enableAgentCheckbox.checked });
            });
            enableLLMCheckbox.addEventListener('change', () => {
                vscode.postMessage({ command: 'toggleLLMMonitoring', enabled: enableLLMCheckbox.checked });
            });

            // Handle messages from the extension
            window.addEventListener('message', event => {
                const message = event.data;
                
                switch (message.command) {
                    case 'updateSettings':
                        enableNativeCheckbox.checked = message.settings.nativeEnabled;
                        enableBackendCheckbox.checked = message.settings.backendEnabled;
                        backendUrlInput.value = message.settings.backendUrl || '';
                        enableAgentCheckbox.checked = message.settings.agentEnabled;
                        enableLLMCheckbox.checked = message.settings.llmEnabled;
                        langfusePublicKeyInput.value = message.settings.langfusePublicKey || '';
                        langfuseSecretKeyInput.value = message.settings.langfuseSecretKey || '';
                        langfuseHostInput.value = message.settings.langfuseHost || 'https://langfuse.com';
                        
                        langfuseSettingsDiv.style.display = message.settings.langfuseEnabled ? 'block' : 'none';
                        break;
                        
                    case 'updateMetrics':
                        if (message.metrics) {
                            const { nativeMetrics, agentMetrics, llmMetrics } = message.metrics;
                            metricsDisplay.textContent = 
                                \`Native - Generations: \${nativeMetrics.totalGenerations || 0}, Avg RT: \${Math.round(nativeMetrics.avgResponseTime||0)}ms, Errors: \${Math.round((nativeMetrics.errorRate||0)*100)}%\n\`
                                + \`Agent - Tools: \${formatObject(agentMetrics.toolUsage)}, Errors: \${agentMetrics.errorCount}\n\`
                                + \`LLM - Generations: \${llmMetrics.totalGenerations||0}, Avg RT: \${Math.round(llmMetrics.avgResponseTime||0)}ms, Errors: \${Math.round((llmMetrics.errorRate||0)*100)}%\`;
                                
                            // Generate the visualization chart
                            renderResponseTimeChart(responseTimeChart, [
                                { label: "Native", value: nativeMetrics.avgResponseTime || 0 },
                                { label: "LLM", value: llmMetrics.avgResponseTime || 0 }
                            ]);
                        } else {
                            metricsDisplay.textContent = 'No metrics available yet.';
                        }
                    break;

                    case 'exportData':
                        exportDataButton.addEventListener('click', () => {
                            if (!message.metrics) {
                                vscode.window.showInformationMessage('No metrics data available to export');
                                return;
                            }
                            
                            const exportData = {
                                timestamp: new Date().toISOString(),
                                metrics: message.metrics
                            };
                            
                            // Create a download link for the JSON data
                            const dataStr = JSON.stringify(exportData, null, 2);
                            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                            
                            vscode.postMessage({ 
                                command: 'exportData', 
                                dataUri: dataUri,
                                filename: \`fuse-monitoring-\${new Date().toISOString().slice(0,10)}.json\`
                            });
                        });
                        break;
                }
            });
            
            // Helper to format objects for display
            function formatObject(obj) {
                if (!obj) return 'None';
                return Object.entries(obj)
                    .map(([key, value]) => \`\${key}: \${value}\`)
                    .join(', ');
            }
            
            // Helper to render the response time chart
            function renderResponseTimeChart(chartElement, data) {
                // Clear existing chart
                chartElement.innerHTML = '';
                
                // Find the maximum value for scaling
                const maxValue = Math.max(...data.map(item => item.value));
                const scaleFactor = maxValue > 0 ? 180 / maxValue : 1; // Maximum height is 180px
                
                // Create bars
                data.forEach((item, index) => {
                    const barHeight = Math.max(item.value * scaleFactor, 1); // Minimum height of 1px
                    const barElement = document.createElement('div');
                    barElement.className = 'chart-bar';
                    barElement.style.height = \`\${barHeight}px\`;
                    barElement.style.left = \`\${(index * 40) + 20}px\`; // Position bars with spacing
                    barElement.title = \`\${item.label}: \${Math.round(item.value)}ms\`;
                    
                    const labelElement = document.createElement('div');
                    labelElement.className = 'chart-label';
                    labelElement.textContent = item.label;
                    labelElement.style.left = \`\${(index * 40) + 20}px\`;
                    
                    chartElement.appendChild(barElement);
                    chartElement.appendChild(labelElement);
                });
                
                // Add y-axis labels (milliseconds)
                if (maxValue > 0) {
                    const yAxisLabel = document.createElement('div');
                    yAxisLabel.style.position = 'absolute';
                    yAxisLabel.style.left = '0';
                    yAxisLabel.style.top = '0';
                    yAxisLabel.style.fontSize = '10px';
                    yAxisLabel.textContent = \`\${Math.round(maxValue)}ms\`;
                    chartElement.appendChild(yAxisLabel);
                }
            }
        </script>
    </body>
    </html>`;
  }
}


==============================================
FILE: ./src/vscode-extension/monitoring/MonitoringStrategy.ts
==============================================

import * as vscode from 'vscode';
import { AgentMonitor } from './AgentMonitor';
import { FuseMonitoringClient } from './FuseMonitoringClient';
import { LLMMonitoringClient } from './llm-monitoring-client';

/**
 * Monitoring Strategy Guide for The New Fuse
 * 
 * This file outlines the monitoring implementation strategy, balancing native features
 * and Langfuse integration to provide comprehensive monitoring capabilities.
 */

export interface MonitoringStrategy {
  // Native implementations
  nativeImplementations: {
    // Priority 1: Near-term implementations with high value
    highPriority: string[];
    // Priority 2: Medium-term implementations
    mediumPriority: string[];
    // Priority 3: Long-term implementations or Langfuse delegations
    lowPriority: string[];
  };
  
  // Langfuse delegate features
  langfuseIntegration: {
    // Features to leverage from Langfuse immediately
    immediateUse: string[];
    // Features to potentially replace with native implementations later
    potentialReplacement: string[];
  };
}

/**
 * The recommended monitoring strategy for The New Fuse platform.
 */
export const recommendedStrategy: MonitoringStrategy = {
  nativeImplementations: {
    highPriority: [
      "Real-time Agent Activity Dashboard - Showcase active agents and their tool usage in the SaaS UI",
      "Enhanced Tool Usage Metrics - Track tool invocations, success rates, and performance across all agents",
      "Unified Trace View - Show interactions between multiple agents in a single view/timeline",
      "Basic Token/Cost Tracking - Implement token counting and basic usage reporting"
    ],
    
    mediumPriority: [
      "Session Replay - Capture and replay agent interaction sequences",
      "Custom Event Tracking - Allow developers to emit and track custom events",
      "Agent Performance Benchmarks - Compare agent performance across different workloads",
      "Redis-backed Event Queue - Implement Redis-based event buffering for better throughput"
    ],
    
    lowPriority: [
      "Advanced Analytics Dashboard - Complex visualizations and reporting",
      "ML-powered Anomaly Detection - Identify unusual agent behavior patterns",
      "Cross-project Analytics - Compare metrics across multiple Fuse deployments",
      "Historical Data Warehousing - Long-term storage and analysis of monitoring data"
    ]
  },
  
  langfuseIntegration: {
    immediateUse: [
      "Long-term Analytics Storage - Leverage Langfuse's S3/ClickHouse infrastructure",
      "Advanced Cost Analytics - Use Langfuse's token counting and cost projections",
      "SQL Analytics Engine - Allow users to run custom SQL queries on their data",
      "Data Export/Import - Utilize Langfuse's data portability features",
      "Custom Dashboards - Allow users to create custom monitoring dashboards"
    ],
    
    potentialReplacement: [
      "Evaluation Workflows - Currently use Langfuse's, but build native version later",
      "Team Collaboration Features - Delegate to Langfuse initially",
      "Alerting System - Use Langfuse alerts before building native capability",
      "Advanced Prompt Analysis - Use Langfuse's prompt analysis tools initially"
    ]
  }
};

/**
 * Helper function to determine if a feature should be implemented natively
 * or delegated to Langfuse based on the recommended strategy.
 */
export function shouldImplementNatively(featureName: string): boolean {
  const allNative = [
    ...recommendedStrategy.nativeImplementations.highPriority,
    ...recommendedStrategy.nativeImplementations.mediumPriority,
    ...recommendedStrategy.nativeImplementations.lowPriority
  ];
  
  const allLangfuse = [
    ...recommendedStrategy.langfuseIntegration.immediateUse,
    ...recommendedStrategy.langfuseIntegration.potentialReplacement
  ];
  
  return allNative.some(f => f.includes(featureName)) && 
         !allLangfuse.some(f => f.includes(featureName));
}

/**
 * Implementation plan for integrating monitoring across the full Fuse stack
 */
export const implementationPlan = {
  vsCodeExtension: {
    current: [
      "Basic agent monitoring via AgentMonitor",
      "LLM usage tracking via LLMMonitoringClient",
      "Native tracing via FuseMonitoringClient",
      "Admin control panel webview",
      "Monitoring settings webview"
    ],
    next: [
      "Enhanced tool call tracking",
      "Local persistent storage via SQLite",
      "Unified agent dashboard improvements",
      "Token counting for all LLM providers"
    ]
  },
  
  saasBackend: {
    current: [
      "Basic Redis-based event storage",
      "REST API for monitoring data submission",
      "PostgreSQL schema for event storage"
    ],
    next: [
      "Dedicated telemetry-worker service",
      "Redis-based event buffering queue",
      "Optimized PostgreSQL schema with time-series capabilities",
      "Basic monitoring dashboard in web UI"
    ]
  },
  
  langfuseBridge: {
    current: [
      "Optional Langfuse client in VS Code extension",
      "Basic trace/span/generation mapping"
    ],
    next: [
      "Server-side Langfuse integration",
      "Two-way data sync between Fuse and Langfuse",
      "Enhanced Langfuse SDK integration",
      "Langfuse dashboard embedding in Fuse web UI"
    ]
  }
};


==============================================
FILE: ./src/vscode-extension/monitoring/llm-monitoring-client.ts
==============================================

// Define the missing types locally instead of importing them
interface LMRequestParams {
  prompt: string;
  systemPrompt?: string;
  temperature?: number;
  maxTokens?: number;
  options?: any;
}

interface LMResponse {
  text: string;
  provider?: string;
  model?: string;
  usage?: {
    promptTokens?: number;
    completionTokens?: number;
    totalTokens?: number;
  };
}

import * as vscode from 'vscode';
import { LLMProviderConfig } from '../llm-provider-manager';

/**
 * LLMMonitoringClient provides a bridge between the VS Code extension's
 * LLM provider manager and monitoring systems like Langfuse.
 */
export class LLMMonitoringClient {
  private context: vscode.ExtensionContext;
  private outputChannel: vscode.OutputChannel;
  private enabled: boolean = false;
  private traceId: string | null = null;

  constructor(context: vscode.ExtensionContext, outputChannel?: vscode.OutputChannel) {
    this.context = context;
    this.outputChannel = outputChannel || vscode.window.createOutputChannel('LLM Monitoring');

    // Check if monitoring is enabled in settings
    const config = vscode.workspace.getConfiguration('theFuse');
    this.enabled = config.get<boolean>('enableLLMMonitoring', false);

    this.log(`LLM Monitoring initialized. Enabled: ${this.enabled}`);
  }

  /**
   * Start a new trace for a user session or operation
   */
  startTrace(options: {
    name?: string;
    userId?: string;
    metadata?: Record<string, any>;
    tags?: string[];
  }): string | null {
    if (!this.enabled) return null;

    try {
      // Generate a trace ID
      const traceId = `trace-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
      this.traceId = traceId;

      this.log(`Started new trace: ${options.name || 'unnamed'} (${traceId})`);

      // Store trace info in extension state
      const traces = this.context.globalState.get<any[]>('thefuse.llm.traces', []);
      traces.push({
        id: traceId,
        name: options.name || 'unnamed',
        userId: options.userId,
        metadata: options.metadata,
        tags: options.tags,
        timestamp: Date.now()
      });

      // Limit the number of stored traces
      if (traces.length > 100) {
        traces.splice(0, traces.length - 100);
      }

      this.context.globalState.update('thefuse.llm.traces', traces);

      return traceId;
    } catch (error) {
      this.log(`Error starting trace: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  /**
   * End the current trace
   */
  endTrace(traceId?: string): void {
    if (!this.enabled) return;

    const tId = traceId || this.traceId;
    if (tId) {
      this.log(`Ended trace: ${tId}`);
      if (tId === this.traceId) {
        this.traceId = null;
      }
    }
  }

  /**
   * Trace an LLM generation
   */
  async traceGeneration(
    provider: LLMProviderConfig,
    params: LMRequestParams,
    generationFunction: () => Promise<LMResponse>
  ): Promise<LMResponse> {
    if (!this.enabled) {
      return generationFunction();
    }

    const startTime = new Date();
    let result: LMResponse | undefined;
    let error: any;

    try {
      this.log(`Tracing LLM generation with provider: ${provider.name}`);
      result = await generationFunction();
      return result;
    } catch (e) {
      error = e;
      throw e;
    } finally {
      const endTime = new Date();

      // Store generation data in extension state
      try {
        if (result) {
          const generations = this.context.globalState.get<any[]>('thefuse.llm.generations', []);

          generations.push({
            id: `gen-${Date.now()}-${Math.random().toString(36).substring(2, 10)}`,
            traceId: this.traceId,
            provider: {
              id: provider.id,
              name: provider.name,
              provider: provider.provider,
              modelName: provider.modelName
            },
            request: {
              prompt: params.prompt,
              systemPrompt: params.systemPrompt,
              temperature: params.temperature,
              maxTokens: params.maxTokens,
              options: params.options
            },
            response: error ? null : {
              text: result.text.substring(0, 500),
              provider: result.provider || provider.name,
              model: result.model || provider.modelName,
              usage: result.usage || {}
            },
            error: error ? {
              message: error.message,
              name: error.name
            } : null,
            startTime: startTime.toISOString(),
            endTime: endTime.toISOString(),
            duration: endTime.getTime() - startTime.getTime()
          });

          // Limit the number of stored generations
          if (generations.length > 200) {
            generations.splice(0, generations.length - 200);
          }

          this.context.globalState.update('thefuse.llm.generations', generations);

          // Log completion details
          this.log(`Generation completed in ${endTime.getTime() - startTime.getTime()}ms with ${result.provider || provider.name}/${result.model || provider.modelName}`);
          if (result.usage) {
            this.log(`Token usage: ${JSON.stringify(result.usage)}`);
          }
        } else if (error) {
          this.log(`Generation error: ${error.message}`);
        }

        // Send telemetry if enabled
        this.sendTelemetry(provider, params, result, error, startTime, endTime);
      } catch (storeError) {
        this.log(`Error storing generation data: ${storeError instanceof Error ? storeError.message : String(storeError)}`);
      }
    }
  }

  /**
   * Send telemetry data to monitoring service if enabled
   */
  private sendTelemetry(
    provider: LLMProviderConfig,
    params: LMRequestParams,
    result: LMResponse | undefined,
    error: any,
    startTime: Date,
    endTime: Date
  ): void {
    // This is a placeholder for server-side integration with Langfuse
    // The actual implementation would send data to a server endpoint
    // that integrates with the LangfuseService

    const config = vscode.workspace.getConfiguration('theFuse');
    const telemetryEnabled = config.get<boolean>('enableTelemetry', false);

    if (!telemetryEnabled) {
      return;
    }

    try {
      const apiEndpoint = config.get<string>('monitoringEndpoint', '');
      if (!apiEndpoint) {
        return;
      }

      // In a real implementation, we would make an API call to the monitoring service
      this.log(`Would send telemetry to ${apiEndpoint}`);
    } catch (error) {
      this.log(`Error sending telemetry: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }

  /**
   * Get the current trace ID
   */
  getCurrentTraceId(): string | null {
    return this.traceId;
  }

  /**
   * Set the monitoring enabled state
   */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;

    // Save the setting
    vscode.workspace.getConfiguration('theFuse').update(
      'enableLLMMonitoring',
      enabled,
      vscode.ConfigurationTarget.Global
    );

    this.log(`LLM Monitoring ${enabled ? 'enabled' : 'disabled'}`);
  }

  /**
   * Get whether monitoring is enabled
   */
  isEnabled(): boolean {
    return this.enabled;
  }

  /**
   * Get metrics for the current session
   */
  getSessionMetrics(): {
    totalGenerations: number;
    avgResponseTime: number;
    errorRate: number;
    providerUsage: Record<string, number>;
    modelUsage: Record<string, number>;
  } {
    try {
      const generations = this.context.globalState.get<any[]>('thefuse.llm.generations', []);

      if (generations.length === 0) {
        return {
          totalGenerations: 0,
          avgResponseTime: 0,
          errorRate: 0,
          providerUsage: {},
          modelUsage: {}
        };
      }

      // Calculate total generations
      const totalGenerations = generations.length;

      // Calculate average response time
      const responseTimes = generations
        .filter(g => g.duration)
        .map(g => g.duration);

      const avgResponseTime = responseTimes.length > 0
        ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
        : 0;

      // Calculate error rate
      const errorCount = generations.filter(g => g.error).length;
      const errorRate = totalGenerations > 0 ? errorCount / totalGenerations : 0;

      // Calculate provider and model usage
      const providerUsage: Record<string, number> = {};
      const modelUsage: Record<string, number> = {};

      for (const gen of generations) {
        if (gen.provider && gen.provider.provider) {
          providerUsage[gen.provider.provider] = (providerUsage[gen.provider.provider] || 0) + 1;
        }

        if (gen.response && gen.response.model) {
          modelUsage[gen.response.model] = (modelUsage[gen.response.model] || 0) + 1;
        } else if (gen.provider && gen.provider.modelName) {
          modelUsage[gen.provider.modelName] = (modelUsage[gen.provider.modelName] || 0) + 1;
        }
      }

      return {
        totalGenerations,
        avgResponseTime,
        errorRate,
        providerUsage,
        modelUsage
      };
    } catch (error) {
      this.log(`Error calculating metrics: ${error instanceof Error ? error.message : String(error)}`);
      return {
        totalGenerations: 0,
        avgResponseTime: 0,
        errorRate: 0,
        providerUsage: {},
        modelUsage: {}
      };
    }
  }
}

/**
 * Create an LLM Monitoring Client
 */
export function createLLMMonitoringClient(
  context: vscode.ExtensionContext,
  outputChannel?: vscode.OutputChannel
): LLMMonitoringClient {
  return new LLMMonitoringClient(context, outputChannel);
}


==============================================
FILE: ./src/vscode-extension/monitoring/roo-coder-monitor.tsx
==============================================

import * as vscode from 'vscode';
import { Logger } from '../core/logging';
import { TelemetryService } from '../core/telemetry';

interface MonitoringMetrics {
    toolUsage: Map<string, number>;
    responseTime: number[];
    errorCount: number;
    activeAgents: string[];
}

export class RooCoderMonitor {
    private static instance: RooCoderMonitor;
    private metrics: MonitoringMetrics;
    private logger: Logger;
    private telemetry: TelemetryService;

    private constructor() {
        this.logger = Logger.getInstance();
        this.telemetry = TelemetryService.getInstance();
        this.metrics = {
            toolUsage: new Map(),
            responseTime: [],
            errorCount: 0,
            activeAgents: []
        };
    }

    static getInstance(): RooCoderMonitor {
        if (!RooCoderMonitor.instance) {
            RooCoderMonitor.instance = new RooCoderMonitor();
        }
        return RooCoderMonitor.instance;
    }

    trackToolUsage(toolId: string, executionTime: number): void {
        const currentCount = this.metrics.toolUsage.get(toolId) || 0;
        this.metrics.toolUsage.set(toolId, currentCount + 1);
        this.metrics.responseTime.push(executionTime);

        this.telemetry.trackEvent('tool_execution', {
            toolId,
            executionTime: executionTime.toString()
        });
    }

    trackError(error: Error): void {
        this.metrics.errorCount++;
        this.telemetry.trackError(error);
    }

    updateActiveAgents(agents: string[]): void {
        this.metrics.activeAgents = agents;
        this.telemetry.trackEvent('active_agents_updated', {
            count: agents.length.toString(),
            agents: agents.join(',')
        });
    }

    async getMetricsReport(): Promise<string> {
        const report = {
            timestamp: new Date().toISOString(),
            metrics: this.metrics,
            summary: {
                totalToolExecutions: Array.from(this.metrics.toolUsage.values())
                    .reduce((a, b) => a + b, 0),
                averageResponseTime: this.metrics.responseTime.length > 0
                    ? this.metrics.responseTime.reduce((a, b) => a + b, 0) / this.metrics.responseTime.length
                    : 0,
                errorRate: this.metrics.errorCount
            }
        };

        return JSON.stringify(report, null, 2);
    }
}


==============================================
FILE: ./src/vscode-extension/one-click-start.sh
==============================================

#!/bin/bash

echo "=== The New Fuse - One-Click Startup ==="

# Create essential directories
mkdir -p out
mkdir -p ai-communication

# Create the minimal extension.js
cat > out/extension.js << 'EOF'
const vscode = require('vscode');

function activate(context) {
  console.log('The New Fuse extension is active!');
  
  // Register basic commands
  const helloCommand = vscode.commands.registerCommand('thefuse.helloWorld', () => {
    vscode.window.showInformationMessage('Hello from The New Fuse!');
  });
  
  // Add status bar item
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse AI Tools";
  statusBarItem.command = 'thefuse.helloWorld';
  statusBarItem.show();
  
  context.subscriptions.push(helloCommand, statusBarItem);
  
  // Notify user
  vscode.window.showInformationMessage('The New Fuse extension is now active!', 'Try Hello World').then(
    selection => {
      if (selection === 'Try Hello World') {
        vscode.commands.executeCommand('thefuse.helloWorld');
      }
    }
  );
}

function deactivate() {}

module.exports = { activate, deactivate };
EOF

# Create minimal package.json
cat > package.json << 'EOF'
{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "main": "./out/extension.js",
  "activationEvents": ["onStartupFinished"],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.helloWorld",
        "title": "Hello from The New Fuse"
      }
    ]
  }
}
EOF

# Find VS Code on macOS
if [ -x "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code" ]; then
  VSCODE_PATH="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
else
  VSCODE_PATH="code" # Fallback to PATH
fi

echo "Launching VS Code with The New Fuse extension..."
"$VSCODE_PATH" --new-window --extensionDevelopmentPath="$(pwd)"

echo ""
echo "The New Fuse is now running in VS Code."
echo "Look for the rocket icon in the status bar and try using the Command Palette (Cmd+Shift+P or Ctrl+Shift+P)"



==============================================
FILE: ./src/vscode-extension/one-command-setup.sh
==============================================

#!/bin/bash

echo "======================================================"
echo "  The New Fuse - VS Code Extension One-Command Setup"
echo "======================================================"
echo ""

# Create all required directories
echo "Creating directory structure..."
mkdir -p out
mkdir -p test
mkdir -p web-ui
mkdir -p .vscode
mkdir -p ai-communication

# Check for existing files and back them up if needed
if [ -f "package.json" ]; then
  echo "Backing up existing package.json..."
  cp package.json package.json.bak
fi

if [ -f "tsconfig.json" ]; then
  echo "Backing up existing tsconfig.json..."
  cp tsconfig.json tsconfig.json.bak
fi

# Create or update package.json
echo "Setting up package.json..."
cat > package.json << 'EOF'
{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination and workflow automation for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "publisher": "thefuse",
  "categories": [
    "Other",
    "Machine Learning",
    "Programming Languages"
  ],
  "activationEvents": [
    "onStartupFinished"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "thefuse.openWebUI",
        "title": "Open The New Fuse UI"
      },
      {
        "command": "thefuse.startAICollab",
        "title": "Start AI Collaboration"
      },
      {
        "command": "llm-orchestrator.showAgents",
        "title": "Show AI Agents"
      },
      {
        "command": "llm-orchestrator.discoverAgents",
        "title": "Discover AI Agents"
      },
      {
        "command": "llm-orchestrator.createCollaborativeTask",
        "title": "Create AI Collaborative Task"
      },
      {
        "command": "thefuse.ai.startCollaboration",
        "title": "Start AI Collaboration Workflow"
      },
      {
        "command": "thefuse.ai.executeTask",
        "title": "Execute AI Task"
      },
      {
        "command": "thefuse.lm.generate",
        "title": "Generate Text with Language Model"
      },
      {
        "command": "thefuse.sendFileMessage",
        "title": "Send Message via File Protocol"
      },
      {
        "command": "thefuse.toggleCollaborativeCompletion",
        "title": "Toggle Collaborative Completion Mode"
      },
      {
        "command": "thefuse.startCollaborativeCoding",
        "title": "Start Collaborative Coding with AI Team"
      },
      {
        "command": "thefuse.analyzeCodeProblem",
        "title": "Analyze Code Problem with AI Team"
      },
      {
        "command": "thefuse.ai.startCollaborativeCoding",
        "title": "Start AI Collaborative Coding"
      },
      {
        "command": "thefuse.ai.analyzeCodeProblem",
        "title": "Analyze Code Problem"
      },
      {
        "command": "thefuse.ai.consultCoder",
        "title": "Consult Specific AI Coder"
      }
    ],
    "menus": {
      "editor/context": [
        {
          "command": "thefuse.startAICollab",
          "group": "navigation"
        },
        {
          "command": "thefuse.startCollaborativeCoding",
          "group": "navigation"
        },
        {
          "command": "thefuse.analyzeCodeProblem",
          "group": "navigation"
        }
      ]
    },
    "configuration": {
      "title": "The New Fuse",
      "properties": {
        "theFuse.defaultLmProvider": {
          "type": "string",
          "default": "copilot",
          "enum": ["copilot", "anthropic", "openai", "huggingface", "local"],
          "description": "Default language model provider to use"
        },
        "theFuse.enableDebugLogging": {
          "type": "boolean",
          "default": false,
          "description": "Enable detailed logging for debugging"
        },
        "theFuse.fileProtocolDir": {
          "type": "string",
          "default": "ai-communication",
          "description": "Directory for file-based inter-extension communication"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js"
  },
  "dependencies": {
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@types/node": "20.2.5",
    "@types/uuid": "^9.0.1",
    "@types/vscode": "^1.80.0",
    "typescript": "^5.1.3"
  }
}
EOF

# Create tsconfig.json
echo "Setting up tsconfig.json..."
cat > tsconfig.json << 'EOF'
{
  "compilerOptions": {
    "module": "CommonJS",
    "target": "ES2020",
    "outDir": "out",
    "lib": ["ES2020", "DOM"],
    "sourceMap": true,
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "exclude": ["node_modules", ".vscode-test"]
}
EOF

# Create launch.json for VS Code
echo "Setting up VS Code debugging configuration..."
mkdir -p .vscode
cat > .vscode/launch.json << 'EOF'
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Launch Extension",
      "type": "extensionHost",
      "request": "launch",
      "args": [
        "--extensionDevelopmentPath=${workspaceFolder}"
      ],
      "outFiles": [
        "${workspaceFolder}/out/**/*.js"
      ],
      "preLaunchTask": "npm: watch"
    }
  ]
}
EOF

# Create tasks.json for VS Code
echo "Setting up VS Code tasks..."
cat > .vscode/tasks.json << 'EOF'
{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "npm",
      "script": "watch",
      "problemMatcher": "$tsc-watch",
      "isBackground": true,
      "presentation": {
        "reveal": "never"
      },
      "group": {
        "kind": "build",
        "isDefault": true
      }
    }
  ]
}
EOF

# Create the example code file for testing
echo "Creating example code for testing..."
mkdir -p test
cat > test/example-code.ts << 'EOF'
/**
 * Example code file for testing AI collaboration features
 */

// A simple function with some performance issues to optimize
function findDuplicates(array: number[]): number[] {
  const duplicates: number[] = [];
  
  // Inefficient algorithm - O(n²) complexity
  for (let i = 0; i < array.length; i++) {
    for (let j = i + 1; j < array.length; j++) {
      if (array[i] === array[j] && !duplicates.includes(array[i])) {
        duplicates.push(array[i]);
      }
    }
  }
  
  return duplicates;
}

// Poorly documented class that needs improvement
class DataProcessor {
  private data: any[];
  
  constructor(initialData: any[]) {
    this.data = initialData;
  }
  
  process() {
    let result = [];
    for (let i = 0; i < this.data.length; i++) {
      let item = this.data[i];
      if (item && typeof item === 'object') {
        result.push({
          id: item.id || Math.random().toString(36).substr(2, 9),
          value: item.value,
          processed: true,
          timestamp: Date.now()
        });
      }
    }
    return result;
  }
  
  filter(predicate: (item: any) => boolean) {
    return this.data.filter(predicate);
  }
  
  transform(transformer: (item: any) => any) {
    return this.data.map(transformer);
  }
}

// Export the components
export { findDuplicates, DataProcessor };
EOF

# Determine which implementation to use based on file availability
if [ -f "agent-communication.ts" ] && [ -f "ai-coder-integration.ts" ]; then
  echo "Full implementation files found, using those..."
  USE_FULL_IMPL=true
else
  echo "Full implementation files not found, using simplified versions..."
  USE_FULL_IMPL=false
  
  # Create simplified versions of core files
  echo "Creating simplified implementation files..."
  
  # Create simplified agent-communication file
  cat > agent-communication-simple.ts << 'EOF'
import * as vscode from 'vscode';
import * as crypto from 'crypto';

export interface AgentMessage {
  id: string;
  sender: string;
  recipient: string;
  action: string;
  payload: any;
  timestamp: number;
}

export class AgentClient {
  private context: vscode.ExtensionContext;
  private agentId: string;
  private messageCallbacks: ((message: AgentMessage) => Promise<void>)[] = [];
  
  constructor(context: vscode.ExtensionContext, agentId: string) {
    this.context = context;
    this.agentId = agentId;
    
    // Set up polling for workspace state messages
    setInterval(() => this.checkForMessages(), 1000);
  }
  
  // Register this agent
  async register(name: string, capabilities: string[], version: string): Promise<boolean> {
    // Store registration in workspace state
    const registrations = this.context.workspaceState.get<any[]>('thefuse.agentRegistrations', []);
    registrations.push({
      id: this.agentId,
      name,
      capabilities,
      version,
      timestamp: Date.now()
    });
    await this.context.workspaceState.update('thefuse.agentRegistrations', registrations);
    return true;
  }
  
  // Send a message to another agent
  async sendMessage(recipient: string, action: string, payload: any): Promise<boolean> {
    const message: AgentMessage = {
      id: crypto.randomUUID(),
      sender: this.agentId,
      recipient,
      action,
      payload,
      timestamp: Date.now()
    };
    
    // Add message to workspace state
    const messages = this.context.workspaceState.get<AgentMessage[]>('thefuse.messages', []);
    messages.push(message);
    await this.context.workspaceState.update('thefuse.messages', messages);
    return true;
  }
  
  // Broadcast a message to all agents
  async broadcast(action: string, payload: any): Promise<boolean> {
    return this.sendMessage('*', action, payload);
  }
  
  // Subscribe to receive messages
  async subscribe(callback: (message: AgentMessage) => Promise<void>): Promise<boolean> {
    this.messageCallbacks.push(callback);
    return true;
  }
  
  // Check for new messages
  private async checkForMessages(): Promise<void> {
    const messages = this.context.workspaceState.get<AgentMessage[]>('thefuse.messages', []);
    if (messages.length === 0) return;
    
    // Find messages for this agent
    const myMessages = messages.filter(m => 
      m.recipient === this.agentId || 
      m.recipient === '*'
    );
    
    if (myMessages.length === 0) return;
    
    // Process messages
    for (const message of myMessages) {
      for (const callback of this.messageCallbacks) {
        await callback(message);
      }
    }
    
    // Remove processed messages
    const remainingMessages = messages.filter(m => 
      m.recipient !== this.agentId && 
      m.recipient !== '*'
    );
    await this.context.workspaceState.update('thefuse.messages', remainingMessages);
  }
}

// Export factory functions
export function initializeOrchestrator(context: vscode.ExtensionContext): any {
  // Simple placeholder for the full orchestrator
  return {
    getRegisteredAgents: () => {
      return context.workspaceState.get<any[]>('thefuse.agentRegistrations', []);
    }
  };
}

export function createAgentClient(context: vscode.ExtensionContext, agentId: string): AgentClient {
  return new AgentClient(context, agentId);
}
EOF

  # Create a simple extension.ts
  cat > extension.ts << 'EOF'
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  console.log('The New Fuse extension is now active!');
  
  // Register a simple command to verify the extension is working
  const helloCommand = vscode.commands.registerCommand('thefuse.helloWorld', () => {
    vscode.window.showInformationMessage('Hello from The New Fuse!');
  });
  
  // Register a basic version of the AI collaboration command
  const startAICollabCommand = vscode.commands.registerCommand('thefuse.startAICollab', () => {
    vscode.window.showInformationMessage('AI Collaboration will be available soon!');
  });
  
  // Register other placeholder commands
  const analyzeCodeCommand = vscode.commands.registerCommand('thefuse.analyzeCodeProblem', () => {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showErrorMessage('No active editor found');
      return;
    }
    
    vscode.window.showInformationMessage('Code analysis feature will be available soon!');
  });
  
  // Add a status bar item
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse AI Tools";
  statusBarItem.command = 'thefuse.helloWorld';
  statusBarItem.show();
  
  // Register all disposables
  context.subscriptions.push(
    helloCommand,
    startAICollabCommand,
    analyzeCodeCommand,
    statusBarItem
  );
  
  // Show welcome message
  vscode.window.showInformationMessage('The New Fuse extension is now active!',
    'Learn More'
  ).then(selection => {
    if (selection === 'Learn More') {
      vscode.env.openExternal(vscode.Uri.parse('https://github.com/your-username/the-new-fuse'));
    }
  });
}

export function deactivate() {
  console.log('The New Fuse extension is now deactivated');
}
EOF
fi

# Install dependencies
echo "Installing dependencies..."
npm install

# Install TypeScript globally if it's not already installed
if ! command -v tsc &> /dev/null; then
  echo "TypeScript not found, installing globally..."
  npm install -g typescript
fi

# Install required dev dependencies
echo "Installing development dependencies..."
npm install --save-dev @types/vscode @types/node @types/uuid typescript

# Compile TypeScript files
echo "Compiling TypeScript files..."
npm run compile

# Check if compilation succeeded
if [ $? -ne 0 ]; then
  echo "⚠️ Compilation failed. Please check for errors in your TypeScript files."
  echo "  You can still continue to try launching the extension."
else
  echo "✅ Compilation successful!"
fi

# Launch options
echo ""
echo "Would you like to launch VS Code with the extension now? (y/n)"
read -r LAUNCH_NOW

if [[ $LAUNCH_NOW =~ ^[Yy]$ ]]; then
  # Try to find VS Code
  VSCODE_PATH=""
  
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS
    if [ -x "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code" ]; then
      VSCODE_PATH="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
    fi
  elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    # Linux
    if command -v code &> /dev/null; then
      VSCODE_PATH="code"
    fi
  elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
    # Windows with Git Bash or similar
    if command -v code.cmd &> /dev/null; then
      VSCODE_PATH="code.cmd"
    fi
  fi
  
  if [ -z "$VSCODE_PATH" ] && command -v code &> /dev/null; then
    VSCODE_PATH="code"
  fi
  
  if [ -n "$VSCODE_PATH" ]; then
    echo "Launching VS Code with the extension..."
    "$VSCODE_PATH" --new-window --extensionDevelopmentPath="$(pwd)"
  else
    echo "⚠️ Could not find VS Code executable. Please launch VS Code manually:"
    echo "code --extensionDevelopmentPath=\"$(pwd)\""
  fi
fi

echo ""
echo "============================================================"
echo "  Setup complete! 🎉"
echo "============================================================"
echo ""
echo "You can now use the extension in VS Code. If you encounter any issues,"
echo "check the TROUBLESHOOTING.md file or run:"
echo ""
echo "  code --extensionDevelopmentPath=\"$(pwd)\""
echo ""
echo "To see debug logs, open the Output panel in VS Code (View > Output)"
echo "and select 'The New Fuse' from the dropdown."
echo ""



==============================================
FILE: ./src/vscode-extension/package.json
==============================================

{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "Advanced AI assistant with Copilot-like chat interface for coding, workflow automation, and agent coordination",
  "version": "0.2.5",
  "publisher": "thefuse",
  "icon": "resources/fusion-icon.png",
  "engines": {
    "vscode": "^1.80.0"
  },
  "categories": [
    "AI",
    "Machine Learning",
    "Other"
  ],
  "main": "./out/extension.js",
  "activationEvents": [
    "onStartupFinished"
  ],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.openDashboard",
        "title": "Open The New Fuse Dashboard",
        "icon": "$(rocket)"
      },
      {
        "command": "thefuse.mcp.initialize",
        "title": "Initialize MCP Integration"
      },
      {
        "command": "thefuse.mcp.showTools",
        "title": "Show MCP Tools"
      },
      {
        "command": "thefuse.mcp.askAgent",
        "title": "Ask Agent with MCP Tools"
      },
      {
        "command": "thefuse.mcp.testTool",
        "title": "Test MCP Tool"
      },
      {
        "command": "thefuse.mcp.executeTestTool",
        "title": "Execute Test Tool"
      },
      {
        "command": "thefuse.mcp.browseMarketplace",
        "title": "Browse MCP Server Marketplace",
        "icon": "$(extensions)"
      },
      {
        "command": "thefuse.mcp.addServerFromMarketplace",
        "title": "Add MCP Server from Marketplace",
        "icon": "$(add)"
      },
      {
        "command": "thefuse.openMcpCommandPalette",
        "title": "Open MCP Command Palette"
      },
      {
        "command": "thefuse.openChat",
        "title": "Open The New Fuse Chat",
        "icon": "$(comment-discussion)"
      },
      {
        "command": "thefuse.openChatPanel",
        "title": "Open The New Fuse Chat in Panel",
        "icon": "$(comment-discussion)"
      },
      {
        "command": "thefuse.startNewChat",
        "title": "Start New Chat",
        "icon": "$(add)"
      },
      {
        "command": "thefuse.clearChat",
        "title": "Clear Chat",
        "icon": "$(clear-all)"
      },
      {
        "command": "thefuse.openSettings",
        "title": "Open The New Fuse Settings",
        "icon": "$(gear)"
      },
      {
        "command": "thefuse.selectMode",
        "title": "Select Roo Mode",
        "icon": "$(settings-gear)"
      },
      {
        "command": "thefuse.mode.orchestrator",
        "title": "Orchestrator Mode",
        "icon": "$(organization)"
      },
      {
        "command": "thefuse.mode.debug",
        "title": "Debug Mode",
        "icon": "$(debug)"
      },
      {
        "command": "thefuse.mode.ask",
        "title": "Ask Mode",
        "icon": "$(question)"
      },
      {
        "command": "thefuse.mode.architect",
        "title": "Architect Mode",
        "icon": "$(symbol-structure)"
      },
      {
        "command": "thefuse.mode.code",
        "title": "Code Mode",
        "icon": "$(code)"
      },
      {
        "command": "thefuse.openWorkflowBuilder",
        "title": "Open Workflow Builder",
        "icon": "$(circuit-board)"
      },
      {
        "command": "thefuse.analyzeCodeProblem",
        "title": "Analyze Code Problem",
        "icon": "$(microscope)"
      },
      {
        "command": "thefuse.startIterativeAnalysis",
        "title": "Start Iterative Code Analysis",
        "icon": "$(sync)"
      },
      {
        "command": "thefuse.continueIteration",
        "title": "Continue Analysis Iteration",
        "icon": "$(sync)"
      },
      {
        "command": "thefuse.exportAnalysisReport",
        "title": "Export Analysis Report",
        "icon": "$(file-text)"
      },
      {
        "command": "thefuse.anthropic.parseXmlFunctionCall",
        "title": "Parse Anthropic XML Function Call"
      },
      {
        "command": "thefuse.anthropic.createXmlFunctionCall",
        "title": "Create Anthropic XML Function Call"
      },
      {
        "command": "thefuse.anthropic.convertToolToXmlFormat",
        "title": "Convert Tool to Anthropic XML Format"
      },
      {
        "command": "thefuse.anthropic.convertSelectionToXmlFunctionCall",
        "title": "Convert Selection to Anthropic XML Function Call"
      }
    ],
    "viewsContainers": {
      "activitybar": [
        {
          "id": "thefuse-sidebar",
          "title": "The New Fuse",
          "icon": "resources/fusion-icon.svg"
        }
      ]
    },
    "views": {
      "thefuse-sidebar": [
        {
          "id": "thefuse.orchestratorView",
          "name": "Orchestrator",
          "when": "thefuse.currentMode == orchestrator",
          "icon": "$(organization)"
        },
        {
          "id": "thefuse.debugView",
          "name": "Debug",
          "when": "thefuse.currentMode == debug",
          "icon": "$(debug)"
        },
        {
          "id": "thefuse.askView",
          "name": "Ask",
          "when": "thefuse.currentMode == ask",
          "icon": "$(question)"
        },
        {
          "id": "thefuse.architectView",
          "name": "Architect",
          "when": "thefuse.currentMode == architect",
          "icon": "$(symbol-structure)"
        },
        {
          "id": "thefuse.codeView",
          "name": "Code",
          "when": "thefuse.currentMode == code",
          "icon": "$(code)"
        },
        {
          "id": "thefuse.agentView",
          "name": "AI Agents",
          "icon": "$(person)"
        },
        {
          "id": "thefuse.toolsView",
          "name": "MCP Tools",
          "icon": "$(tools)"
        },
        {
          "id": "thefuse.mcpServerView",
          "name": "MCP Servers",
          "icon": "$(server)"
        },
        {
          "id": "thefuse.chatView",
          "name": "Chat",
          "when": "thefuse:chatEnabled",
          "icon": "$(comment-discussion)"
        },
        {
          "id": "thefuse.settingsView",
          "name": "Settings",
          "icon": "$(gear)"
        }
      ]
    },
    "viewsWelcome": [
      {
        "view": "thefuse.chatView",
        "contents": "Start a new conversation with The New Fuse AI assistant.\n\nThe chat interface provides intelligent coding assistance similar to GitHub Copilot.\n\n[Open Chat Panel](command:thefuse.openChatPanel)\n[Start New Chat](command:thefuse.startNewChat)"
      },
      {
        "view": "thefuse.mcpServerView",
        "contents": "MCP servers provide AI agents with access to tools and capabilities.\n\n[Browse Marketplace](command:thefuse.mcp.browseMarketplace)\n[Add Server](command:thefuse.mcp.addServerFromMarketplace)"
      }
    ],
    "menus": {
      "view/title": [
        {
          "command": "thefuse.startNewChat",
          "when": "view == thefuse.chatView",
          "group": "navigation"
        },
        {
          "command": "thefuse.clearChat",
          "when": "view == thefuse.chatView",
          "group": "navigation"
        },
        {
          "command": "thefuse.openChatPanel",
          "when": "view == thefuse.chatView",
          "group": "navigation"
        },
        {
          "command": "thefuse.mcp.browseMarketplace",
          "when": "view == thefuse.mcpServerView",
          "group": "navigation"
        },
        {
          "command": "thefuse.mcp.addServerFromMarketplace",
          "when": "view == thefuse.mcpServerView",
          "group": "navigation"
        },
        {
          "command": "thefuse.selectMode",
          "group": "navigation"
        }
      ],
      "editor/context": [
        {
          "command": "thefuse.openChat",
          "group": "9_cutcopypaste",
          "when": "editorTextFocus"
        },
        {
          "command": "thefuse.analyzeCodeProblem",
          "group": "9_cutcopypaste",
          "when": "editorTextFocus && editorLangId =~ /(typescript|javascript|python|java|csharp)/"
        },
        {
          "command": "thefuse.startIterativeAnalysis",
          "group": "9_cutcopypaste",
          "when": "editorTextFocus && editorLangId =~ /(typescript|javascript|python|java|csharp)/"
        }
      ],
      "editor/title": [
        {
          "command": "thefuse.startIterativeAnalysis",
          "when": "editorLangId =~ /(typescript|javascript|python|java|csharp)/",
          "group": "navigation"
        },
        {
          "command": "thefuse.continueIteration",
          "when": "thefuse:analysisIterationActive",
          "group": "navigation"
        },
        {
          "command": "thefuse.exportAnalysisReport",
          "when": "thefuse:analysisIterationActive",
          "group": "navigation"
        }
      ],
      "commandPalette": [
        {
          "command": "thefuse.openChat",
          "group": "thefuse"
        },
        {
          "command": "thefuse.openChatPanel",
          "group": "thefuse"
        },
        {
          "command": "thefuse.startNewChat",
          "group": "thefuse"
        },
        {
          "command": "thefuse.clearChat",
          "group": "thefuse"
        },
        {
          "command": "thefuse.mcp.browseMarketplace",
          "group": "thefuse.mcp"
        },
        {
          "command": "thefuse.mcp.addServerFromMarketplace",
          "group": "thefuse.mcp"
        },
        {
          "command": "thefuse.mcp.showTools",
          "group": "thefuse.mcp"
        },
        {
          "command": "thefuse.mcp.testTool",
          "group": "thefuse.mcp"
        },
        {
          "command": "thefuse.mcp.askAgent",
          "group": "thefuse.mcp"
        },
        {
          "command": "thefuse.mode.orchestrator",
          "when": "thefuse.currentMode != orchestrator",
          "group": "thefuse.modes"
        },
        {
          "command": "thefuse.mode.debug",
          "when": "thefuse.currentMode != debug",
          "group": "thefuse.modes"
        },
        {
          "command": "thefuse.mode.ask",
          "when": "thefuse.currentMode != ask",
          "group": "thefuse.modes"
        },
        {
          "command": "thefuse.mode.architect",
          "when": "thefuse.currentMode != architect",
          "group": "thefuse.modes"
        },
        {
          "command": "thefuse.mode.code",
          "when": "thefuse.currentMode != code",
          "group": "thefuse.modes"
        }
      ]
    },
    "configuration": {
      "title": "The New Fuse",
      "properties": {
        "theFuse.currentMode": {
          "type": "string",
          "enum": ["orchestrator", "debug", "ask", "architect", "code"],
          "default": "orchestrator",
          "description": "Current operational mode for The New Fuse"
        },
        "theFuse.mcpConfigPath": {
          "type": "string",
          "default": "",
          "description": "Path to the MCP configuration file for agent coordination"
        },
        "theFuse.autoInitializeMcp": {
          "type": "boolean",
          "default": true,
          "description": "Automatically initialize MCP integration on startup for a seamless experience"
        },
        "theFuse.mcpMarketplaceUrl": {
          "type": "string",
          "default": "https://mcp.marketplace.api/servers",
          "description": "URL of the MCP Marketplace API for discovering MCP servers"
        },
        "theFuse.agentServerUrl": {
          "type": "string",
          "default": "http://localhost:3000",
          "description": "URL of the SAAS platform server for cloud-based AI capabilities"
        },
        "theFuse.enableChat": {
          "type": "boolean",
          "default": true,
          "description": "Enable The New Fuse chat interface with Copilot-like functionality"
        },
        "theFuse.llmProvider": {
          "type": "string",
          "enum": [
            "vscode",
            "openai",
            "anthropic",
            "ollama",
            "custom"
          ],
          "default": "vscode",
          "description": "LLM provider to use for chat and code assistance. 'vscode' uses VS Code's built-in LM API"
        },
        "theFuse.vscodeModel": {
          "type": "string",
          "enum": [
            "copilot-chat.completion-gpt-4",
            "copilot-chat.completion-gpt-3.5-turbo",
            "copilot-chat.generation"
          ],
          "default": "copilot-chat.completion-gpt-4",
          "description": "VS Code LM API model to use when 'vscode' is selected as the LLM provider"
        },
        "theFuse.openAIModel": {
          "type": "string",
          "enum": [
            "gpt-4",
            "gpt-4-turbo",
            "gpt-3.5-turbo"
          ],
          "default": "gpt-4",
          "description": "OpenAI model to use when 'openai' is selected as the LLM provider"
        },
        "theFuse.openAIAPIKey": {
          "type": "string",
          "default": "",
          "description": "(Required) Your OpenAI API Key. Store securely."
        },
        "theFuse.anthropicModel": {
          "type": "string",
          "enum": [
            "claude-3-opus",
            "claude-3-sonnet",
            "claude-3-haiku"
          ],
          "default": "claude-3-opus",
          "description": "Anthropic model to use when 'anthropic' is selected as the LLM provider"
        },
        "theFuse.anthropicAPIKey": {
          "type": "string",
          "default": "",
          "description": "(Required) Your Anthropic API Key. Store securely."
        },
        "theFuse.ollamaModel": {
          "type": "string",
          "enum": [
            "llama3",
            "mistral",
            "codellama",
            "phi",
            "gemma"
          ],
          "default": "codellama",
          "description": "Ollama model to use when 'ollama' is selected as the LLM provider"
        },
        "theFuse.ollamaEndpoint": {
          "type": "string",
          "default": "http://localhost:11434/api/chat",
          "description": "Ollama API endpoint URL (usually http://localhost:11434/api/chat)"
        },
        "theFuse.customModelEndpoint": {
          "type": "string",
          "default": "",
          "description": "Custom model endpoint URL to use when 'custom' is selected as the LLM provider"
        },
        "theFuse.customModelAPIKey": {
          "type": "string",
          "default": "",
          "description": "API key for custom model endpoint"
        },
        "theFuse.defaultChatView": {
          "type": "string",
          "enum": [
            "sidebar",
            "panel"
          ],
          "default": "panel",
          "description": "Default view for the chat interface. The panel view provides a more prominent, Copilot-like experience, while the sidebar integrates with other extension features."
        },
        "theFuse.chatPanelPosition": {
          "type": "string",
          "enum": [
            "beside",
            "active",
            "smart"
          ],
          "default": "smart",
          "description": "Where to position the chat panel when opened: beside the active editor, in place of it, or automatically determined based on available space"
        },
        "theFuse.chatFontSize": {
          "type": "number",
          "default": 13,
          "description": "Font size used in the chat interface (in pixels)"
        },
        "theFuse.saveChatHistory": {
          "type": "boolean",
          "default": true,
          "description": "Save chat history between sessions for continuity"
        },
        "theFuse.maxChatHistoryLength": {
          "type": "number",
          "default": 50,
          "description": "Maximum number of messages to keep in chat history per session"
        },
        "theFuse.redis.enabled": {
          "type": "boolean",
          "default": false,
          "description": "Enable Redis integration for distributed communication"
        },
        "theFuse.redis.host": {
          "type": "string",
          "default": "localhost",
          "description": "Redis server host"
        },
        "theFuse.redis.port": {
          "type": "number",
          "default": 6379,
          "description": "Redis server port"
        },
        "theFuse.redis.password": {
          "type": "string",
          "default": "",
          "description": "Redis server password"
        },
        "theFuse.redis.db": {
          "type": "number",
          "default": 0,
          "description": "Redis database index"
        },
        "theFuse.redis.keyPrefix": {
          "type": "string",
          "default": "thefuse:",
          "description": "Prefix for Redis keys"
        },
        "theFuse.redis.useTLS": {
          "type": "boolean",
          "default": false,
          "description": "Use TLS for Redis connection"
        },
        "theFuse.logging.level": {
          "type": "string",
          "enum": ["error", "warn", "info", "debug"],
          "default": "info",
          "description": "Logging level for The New Fuse extension"
        }
      }
    },
    "keybindings": [
      {
        "command": "thefuse.openChat",
        "key": "ctrl+alt+c",
        "mac": "cmd+alt+c",
        "when": "editorTextFocus"
      },
      {
        "command": "thefuse.openChatPanel",
        "key": "ctrl+alt+shift+c",
        "mac": "cmd+alt+shift+c",
        "when": "editorTextFocus"
      },
      {
        "command": "thefuse.mcp.browseMarketplace",
        "key": "ctrl+alt+m",
        "mac": "cmd+alt+m"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "lint": "eslint src --ext ts",
    "start": "node ./out/extension.js"
  },
  "dependencies": {
    "node-fetch": "^2.7.0",
    "uuid": "^9.0.0",
    "redis": "^4.6.7"
  },
  "devDependencies": {
    "@types/node": "^20.2.5",
    "@types/uuid": "^9.0.1",
    "@types/vscode": "^1.80.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.44.0",
    "typescript": "^5.1.3"
  }
}



==============================================
FILE: ./src/vscode-extension/packages/db/tsconfig.json
==============================================




==============================================
FILE: ./src/vscode-extension/protocol-registry.tsx
==============================================

import * as vscode from 'vscode';
import { AgentClient } from './agent-communication';

/**
 * Interface for a message transport protocol
 */
export interface MessageTransport {
  id: string;
  name: string;
  description: string;
  sendMessage(recipient: string, action: string, payload: any): Promise<boolean>;
  initialize(): Promise<boolean>;
  dispose(): void;
}

/**
 * Manages communication protocols for inter-extension messaging
 */
export class ProtocolRegistry {
  private context: vscode.ExtensionContext;
  private transports: Map<string, MessageTransport> = new Map();
  private selectedTransportId: string | null = null;
  private outputChannel: vscode.OutputChannel;
  
  constructor(context: vscode.ExtensionContext, outputChannel: vscode.OutputChannel) {
    this.context = context;
    this.outputChannel = outputChannel;
    
    // Load previously selected transport
    this.selectedTransportId = context.globalState.get<string>('thefuse.selectedTransport') || null;
  }
  
  /**
   * Register a message transport
   */
  registerTransport(transport: MessageTransport): void {
    if (this.transports.has(transport.id)) {
      this.log(`Transport ${transport.id} already registered`);
      return;
    }
    
    this.transports.set(transport.id, transport);
    this.log(`Registered transport: ${transport.name} (${transport.id})`);
    
    // If this is the first transport or matches our saved preference, select it
    if (!this.selectedTransportId || this.selectedTransportId === transport.id) {
      this.selectTransport(transport.id);
    }
  }
  
  /**
   * Select a transport as the active one
   */
  async selectTransport(transportId: string): Promise<boolean> {
    if (!this.transports.has(transportId)) {
      this.log(`Transport ${transportId} not found`);
      return false;
    }
    
    const transport = this.transports.get(transportId)!;
    
    // Initialize the transport
    const success = await transport.initialize();
    if (!success) {
      this.log(`Failed to initialize transport ${transportId}`);
      return false;
    }
    
    // Set as selected
    this.selectedTransportId = transportId;
    this.context.globalState.update('thefuse.selectedTransport', transportId);
    
    this.log(`Selected transport: ${transport.name} (${transport.id})`);
    return true;
  }
  
  /**
   * Get the currently selected transport
   */
  getSelectedTransport(): MessageTransport | null {
    if (!this.selectedTransportId) return null;
    return this.transports.get(this.selectedTransportId) || null;
  }
  
  /**
   * Get all registered transports
   */
  getAllTransports(): MessageTransport[] {
    return Array.from(this.transports.values());
  }
  
  /**
   * Send a message using the selected transport
   */
  async sendMessage(recipient: string, action: string, payload: any): Promise<boolean> {
    const transport = this.getSelectedTransport();
    
    if (!transport) {
      this.log('No transport selected');
      return false;
    }
    
    try {
      return await transport.sendMessage(recipient, action, payload);
    } catch (error) {
      this.log(`Error sending message via ${transport.id}: ${error.message}`);
      return false;
    }
  }
  
  /**
   * Dispose of all transports
   */
  dispose(): void {
    for (const transport of this.transports.values()) {
      transport.dispose();
    }
  }
  
  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    this.outputChannel.appendLine(`[Protocol Registry] ${message}`);
  }
}

/**
 * Create a workspace state transport
 */
export function createWorkspaceStateTransport(context: vscode.ExtensionContext, agentClient: AgentClient): MessageTransport {
  return {
    id: 'workspaceState',
    name: 'Workspace State Protocol',
    description: 'Uses VS Code workspace state for message exchange',
    
    async initialize(): Promise<boolean> {
      return true; // Nothing to initialize
    },
    
    async sendMessage(recipient: string, action: string, payload: any): Promise<boolean> {
      return agentClient.sendMessage(recipient, action, payload);
    },
    
    dispose(): void {
      // Nothing to dispose
    }
  };
}

/**
 * Create a protocol registry
 */
export function createProtocolRegistry(context: vscode.ExtensionContext, outputChannel: vscode.OutputChannel): ProtocolRegistry {
  return new ProtocolRegistry(context, outputChannel);
}



==============================================
FILE: ./src/vscode-extension/providers/AnthropicProvider.ts
==============================================

import * as vscode from 'vscode';
import { LLMProvider } from '../types/llm';

export class AnthropicProvider implements LLMProvider {
  private apiKey: string;
  private model: string;
  private outputChannel: vscode.OutputChannel;

  constructor(context: vscode.ExtensionContext) {
    this.outputChannel = vscode.window.createOutputChannel('Anthropic Provider');
    this.model = vscode.workspace.getConfiguration('theFuse').get('anthropicModel', 'claude-3-opus');
    this.apiKey = vscode.workspace.getConfiguration('theFuse').get('anthropicAPIKey', '');
  }

  async checkAvailability(): Promise<boolean> {
    if (!this.apiKey) {
      this.log('Anthropic API key not configured');
      return false;
    }
    return true;
  }

  async generateText(options: {
    prompt: string;
    systemPrompt?: string;
    temperature?: number;
    maxTokens?: number;
    stopSequences?: string[];
  }): Promise<string> {
    if (!await this.checkAvailability()) {
      throw new Error('Anthropic provider is not available');
    }

    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
            { role: 'user', content: options.prompt }
          ],
          temperature: options.temperature ?? 0.7,
          max_tokens: options.maxTokens,
          stop_sequences: options.stopSequences
        })
      });

      if (!response.ok) {
        throw new Error(`Anthropic API error: ${response.statusText}`);
      }

      const data = await response.json();
      return data.content[0].text;
    } catch (err) {
      this.log(`Error generating text: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  private log(message: string): void {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }
}


==============================================
FILE: ./src/vscode-extension/providers/OllamaProvider.ts
==============================================

import * as vscode from 'vscode';
import { LLMProvider } from '../types/llm';

export class OllamaProvider implements LLMProvider {
  private endpoint: string;
  private model: string;
  private outputChannel: vscode.OutputChannel;

  constructor(context: vscode.ExtensionContext) {
    this.outputChannel = vscode.window.createOutputChannel('Ollama Provider');
    this.model = vscode.workspace.getConfiguration('theFuse').get('ollamaModel', 'codellama');
    this.endpoint = vscode.workspace.getConfiguration('theFuse').get('ollamaEndpoint', 'http://localhost:11434/api/chat');
  }

  async checkAvailability(): Promise<boolean> {
    try {
      const response = await fetch(`${new URL(this.endpoint).origin}/api/tags`);
      if (!response.ok) {
        this.log('Ollama server not available');
        return false;
      }
      const models = await response.json();
      return models.models?.some((m: any) => m.name === this.model) ?? false;
    } catch (err) {
      this.log(`Error checking Ollama availability: ${err instanceof Error ? err.message : String(err)}`);
      return false;
    }
  }

  async generateText(options: {
    prompt: string;
    systemPrompt?: string;
    temperature?: number;
    maxTokens?: number;
    stopSequences?: string[];
  }): Promise<string> {
    if (!await this.checkAvailability()) {
      throw new Error('Ollama provider is not available');
    }

    try {
      const response = await fetch(this.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
            { role: 'user', content: options.prompt }
          ],
          options: {
            temperature: options.temperature ?? 0.7,
            num_predict: options.maxTokens,
            stop: options.stopSequences
          }
        })
      });

      if (!response.ok) {
        throw new Error(`Ollama API error: ${response.statusText}`);
      }

      const data = await response.json();
      return data.message.content;
    } catch (err) {
      this.log(`Error generating text: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  private log(message: string): void {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }
}


==============================================
FILE: ./src/vscode-extension/providers/OpenAIProvider.ts
==============================================

import * as vscode from 'vscode';
import { LLMProvider } from '../types/llm';

export class OpenAIProvider implements LLMProvider {
  private apiKey: string;
  private model: string;
  private outputChannel: vscode.OutputChannel;

  constructor(context: vscode.ExtensionContext) {
    this.outputChannel = vscode.window.createOutputChannel('OpenAI Provider');
    this.model = vscode.workspace.getConfiguration('theFuse').get('openAIModel', 'gpt-4');
    this.apiKey = vscode.workspace.getConfiguration('theFuse').get('openAIAPIKey', '');
  }

  async checkAvailability(): Promise<boolean> {
    if (!this.apiKey) {
      this.log('OpenAI API key not configured');
      return false;
    }
    return true;
  }

  async generateText(options: {
    prompt: string;
    systemPrompt?: string;
    temperature?: number;
    maxTokens?: number;
    stopSequences?: string[];
  }): Promise<string> {
    if (!await this.checkAvailability()) {
      throw new Error('OpenAI provider is not available');
    }

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            ...(options.systemPrompt ? [{ role: 'system', content: options.systemPrompt }] : []),
            { role: 'user', content: options.prompt }
          ],
          temperature: options.temperature ?? 0.7,
          max_tokens: options.maxTokens,
          stop: options.stopSequences
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.statusText}`);
      }

      const data = await response.json();
      return data.choices[0].message.content;
    } catch (err) {
      this.log(`Error generating text: ${err instanceof Error ? err.message : String(err)}`);
      throw err;
    }
  }

  private log(message: string): void {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }
}


==============================================
FILE: ./src/vscode-extension/providers/VSCodeCopilotProvider.ts
==============================================

import * as vscode from 'vscode';

/**
 * VSCodeCopilotProvider provides an interface for interacting with
 * GitHub Copilot's VS Code extension features.
 */
export class VSCodeCopilotProvider {
  private context: vscode.ExtensionContext;
  private outputChannel: vscode.OutputChannel;
  private isAvailable: boolean = false;

  constructor(context: vscode.ExtensionContext, outputChannel?: vscode.OutputChannel) {
    this.context = context;
    this.outputChannel = outputChannel || vscode.window.createOutputChannel('VS Code Copilot Provider');
    
    // Check availability
    this.checkAvailability().then(available => {
      this.isAvailable = available;
      this.log(`GitHub Copilot availability: ${available ? 'Available' : 'Not available'}`);
    });
  }

  /**
   * Check if GitHub Copilot is available in the current VS Code instance
   */
  async checkAvailability(): Promise<boolean> {
    try {
      // Check if Copilot extension is installed
      const extensions = vscode.extensions.all;
      const copilotExtension = extensions.find(ext => 
        ext.id === 'GitHub.copilot' || 
        ext.id === 'GitHub.copilot-chat'
      );
      
      if (!copilotExtension) {
        this.log('GitHub Copilot extension not found');
        return false;
      }
      
      // Try to execute a Copilot command to check if it's active
      try {
        this.log('Testing Copilot command...');
        await vscode.commands.executeCommand('github.copilot.generate', { prompt: 'test' });
        this.log('Copilot generate command successful');
        return true;
      } catch (e) {
        this.log(`Could not execute copilot.generate command: ${e instanceof Error ? e.message : String(e)}`);
        
        // Try the chat command instead
        try {
          await vscode.commands.executeCommand('github.copilot.chat', 'test');
          this.log('Copilot chat command successful');
          return true;
        } catch (e) {
          this.log(`Could not execute copilot.chat command: ${e instanceof Error ? e.message : String(e)}`);
          
          // Check if the extension is active but commands aren't ready
          if (copilotExtension.isActive) {
            this.log('Copilot extension is active but commands are unavailable');
            return true;
          }
          
          return false;
        }
      }
    } catch (err) {
      this.log(`Error checking Copilot availability: ${err instanceof Error ? err.message : String(err)}`);
      return false;
    }
  }

  /**
   * Generate text using VS Code Copilot
   */
  async generateText(options: {
    prompt: string;
    systemPrompt?: string;
    temperature?: number;
    maxTokens?: number;
    stopSequences?: string[];
  }): Promise<string> {
    if (!await this.checkAvailability()) {
      throw new Error('GitHub Copilot is not available');
    }
    
    this.log(`Generating text with Copilot: "${options.prompt.substring(0, 50)}..."`);
    
    // Try different methods based on what's available
    
    // Method 1: Try the generate command (VS Code 1.85+)
    try {
      const result = await vscode.commands.executeCommand('github.copilot.generate', {
        prompt: options.prompt,
        temperature: options.temperature,
        maxTokens: options.maxTokens,
        systemPrompt: options.systemPrompt,
        stopSequences: options.stopSequences
      });
      
      if (result && typeof result === 'string') {
        this.log('Successfully generated text with copilot.generate');
        return result;
      }
    } catch (e) {
      this.log(`Error with copilot.generate: ${e instanceof Error ? e.message : String(e)}`);
    }
    
    // Method 2: Try the chat command
    try {
      const chatMessage = options.systemPrompt 
        ? `${options.systemPrompt}\n\n${options.prompt}`
        : options.prompt;
        
      const result = await vscode.commands.executeCommand('github.copilot.chat', chatMessage);
      
      if (result && typeof result === 'string') {
        this.log('Successfully generated text with copilot.chat');
        return result;
      }
    } catch (e) {
      this.log(`Error with copilot.chat: ${e instanceof Error ? e.message : String(e)}`);
    }
    
    // Method 3: Try to use the ghost text feature indirectly (not implemented)
    
    throw new Error('Could not generate text with GitHub Copilot');
  }

  /**
   * Get Copilot configuration
   */
  async getConfig(): Promise<any> {
    try {
      const config = vscode.workspace.getConfiguration('github.copilot');
      return {
        enabled: config.get('enable', true),
        inlineSuggestEnabled: config.get('inlineSuggest.enable', true),
        ghostTextEnabled: config.get('ghostText.enable', true)
      };
    } catch (e) {
      this.log(`Error getting Copilot config: ${e instanceof Error ? e.message : String(e)}`);
      return {
        enabled: true,
        inlineSuggestEnabled: true,
        ghostTextEnabled: true
      };
    }
  }

  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
  }
}


==============================================
FILE: ./src/vscode-extension/quick-launch.sh
==============================================

#!/bin/bash

# Create the 'out' directory if it doesn't exist
mkdir -p out

# Create a minimal extension.js file
echo 'const vscode = require("vscode");

function activate(context) {
  console.log("The New Fuse extension is active!");
  
  // Register a hello world command
  const helloCommand = vscode.commands.registerCommand("thefuse.helloWorld", () => {
    vscode.window.showInformationMessage("Hello from The New Fuse!");
  });
  
  // Register the AI collaboration command
  const aiCollabCommand = vscode.commands.registerCommand("thefuse.startAICollab", () => {
    vscode.window.showInformationMessage("AI Collaboration initiated!");
  });
  
  // Add a status bar item
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse AI Tools";
  statusBarItem.command = "thefuse.helloWorld";
  statusBarItem.show();
  
  // Register all disposables
  context.subscriptions.push(helloCommand, aiCollabCommand, statusBarItem);
}

function deactivate() {}

module.exports = { activate, deactivate };' > out/extension.js

# Create a minimal package.json
echo '{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "main": "./out/extension.js",
  "activationEvents": ["onStartupFinished"],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.helloWorld",
        "title": "Hello World"
      },
      {
        "command": "thefuse.startAICollab",
        "title": "Start AI Collaboration"
      }
    ]
  }
}' > package.json

# Launch VS Code with the extension
echo "Launching VS Code with the extension..."
code --extensionDevelopmentPath="$(pwd)"

# If the above command fails, try the absolute path
if [ $? -ne 0 ]; then
  echo "Trying absolute path to VS Code..."
  /Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code --extensionDevelopmentPath="$(pwd)"
fi



==============================================
FILE: ./src/vscode-extension/quick-start.sh
==============================================

#!/bin/bash

# Ensure the setup script has been run
if [ ! -f "./package.json" ]; then
  echo "Running setup script first..."
  ./setup.sh
fi

# Install dependencies
echo "Installing dependencies..."
npm install

# Compile TypeScript files
echo "Compiling TypeScript..."
npm run compile

# Launch VS Code with the extension
echo "Launching VS Code with the extension..."
node launch-extension.js

echo "If VS Code doesn't open, try running manually:"
echo "code --extensionDevelopmentPath=$(pwd)"



==============================================
FILE: ./src/vscode-extension/reload-extension.sh
==============================================

#!/bin/bash

echo "Reloading The New Fuse extension with correct metadata..."

# Ensure the extension directory is properly set up
mkdir -p out
mkdir -p ai-communication

# Make sure package.json has the correct publisher and name
cat > package.json << 'EOF'
{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination for VS Code",
  "version": "0.1.0",
  "publisher": "thefuse",
  "engines": {
    "vscode": "^1.80.0"
  },
  "main": "./out/extension.js",
  "activationEvents": ["onStartupFinished"],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.helloWorld",
        "title": "Hello from The New Fuse"
      },
      {
        "command": "thefuse.startAICollab",
        "title": "Start AI Collaboration"
      }
    ]
  }
}
EOF

# Uninstall any previous version if it exists
code --uninstall-extension thefuse.the-new-fuse-vscode 2>/dev/null || true

# Install the extension from the current directory
if code --install-extension "$(pwd)" 2>/dev/null; then
  echo "Extension installed successfully!"
else
  echo "Installing using development mode instead..."
  code --extensionDevelopmentPath="$(pwd)"
fi

echo "Extension should now be correctly loaded with ID: thefuse.the-new-fuse-vscode"
echo "If VS Code is already open, use Command Palette > Developer: Reload Window"



==============================================
FILE: ./src/vscode-extension/resources/fusion-icon.svg
==============================================

<?xml version="1.0" encoding="UTF-8"?>
<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <linearGradient id="fusionGlow" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#FF6B6B;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#4ECDC4;stop-opacity:1" />
        </linearGradient>
    </defs>
    <g fill="none" stroke="url(#fusionGlow)" stroke-width="2" stroke-linecap="round">
        <path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/>
        <circle cx="12" cy="12" r="3" fill="url(#fusionGlow)"/>
    </g>
</svg>


==============================================
FILE: ./src/vscode-extension/rooWebSocketBridge.js
==============================================




==============================================
FILE: ./src/vscode-extension/run-extension.sh
==============================================

#!/bin/bash

echo "Compiling and running The New Fuse extension..."

# Create the communication directory (important for inter-extension communication)
mkdir -p ai-communication

# Create minimal TypeScript source files if they don't exist
if [ ! -f "extension.ts" ]; then
  # Create a simple extension.ts file
  echo "Creating minimal extension.ts..."
  cat > extension.ts << 'EOF'
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  console.log('The New Fuse extension is active!');
  
  // Register commands for AI collaboration
  const aiCollabCommand = vscode.commands.registerCommand('thefuse.startAICollab', () => {
    vscode.window.showInformationMessage('AI Collaboration initiated!');
  });
  
  // Status bar items
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse AI Tools";
  statusBarItem.command = 'thefuse.startAICollab';
  statusBarItem.show();
  
  // Register all disposables
  context.subscriptions.push(aiCollabCommand, statusBarItem);
  
  vscode.window.showInformationMessage('The New Fuse is now active! Click the rocket icon to start AI collaboration.');
}

export function deactivate() {}
EOF
fi

# Compile the TypeScript code
echo "Compiling TypeScript..."
npm run compile

# If compilation succeeded, run the extension
if [ $? -eq 0 ]; then
  echo "Launching VS Code with the extension..."
  code --extensionDevelopmentPath="$(pwd)"
else
  echo "Compilation failed. Check for errors above."
fi



==============================================
FILE: ./src/vscode-extension/setup-local.sh
==============================================

#!/bin/bash

echo "===================================================="
echo "  The New Fuse - Local Extension Setup"
echo "===================================================="
echo ""

# Create essential directories (just in case)
mkdir -p out
mkdir -p data
mkdir -p db
mkdir -p mcp-integration

# Create simplified extension.js file
mkdir -p out
cat > out/extension.js << 'EOFJS'
const vscode = require('vscode');

function activate(context) {
  console.log('The New Fuse is now active!');
  
  // Register the MCP commands
  const mcpInitCommand = vscode.commands.registerCommand('thefuse.mcp.initialize', () => {
    vscode.window.showInformationMessage('MCP Initialization started!');
    // Mock successful initialization
    setTimeout(() => {
      vscode.window.showInformationMessage('MCP Initialized with 3 test tools');
    }, 1500);
    return true;
  });
  
  const mcpShowCommand = vscode.commands.registerCommand('thefuse.mcp.showTools', () => {
    vscode.window.showQuickPick([
      { label: 'list_files', description: 'List files in a directory' },
      { label: 'read_file', description: 'Read file contents' },
      { label: 'brave_search', description: 'Search the web' }
    ], { placeHolder: 'Select an MCP tool to test' });
  });
  
  const mcpTestCommand = vscode.commands.registerCommand('thefuse.mcp.testTool', async () => {
    const selectedTool = await vscode.window.showQuickPick([
      { label: 'list_files', description: 'List files in a directory' },
      { label: 'read_file', description: 'Read file contents' },
      { label: 'brave_search', description: 'Search the web' }
    ], { placeHolder: 'Select an MCP tool to test' });
    
    if (selectedTool) {
      vscode.window.showInformationMessage(`Testing tool: ${selectedTool.label}`);
      
      // Show mock result
      const doc = await vscode.workspace.openTextDocument({
        content: JSON.stringify(['file1.txt', 'file2.md', 'example.json'], null, 2),
        language: 'json'
      });
      await vscode.window.showTextDocument(doc);
    }
  });
  
  const mcpAskCommand = vscode.commands.registerCommand('thefuse.mcp.askAgent', async () => {
    const query = await vscode.window.showInputBox({
      prompt: 'What would you like to ask?',
      placeHolder: 'e.g., List files in the data directory'
    });
    
    if (query) {
      const doc = await vscode.workspace.openTextDocument({
        content: `You asked: "${query}"\n\nI found these files:\n- file1.txt\n- file2.md\n- example.json`,
        language: 'markdown'
      });
      await vscode.window.showTextDocument(doc);
    }
  });
  
  // Add status bar item with MCP status
  const mcpStatusItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
  mcpStatusItem.text = '$(tools) MCP Tools';
  mcpStatusItem.tooltip = 'MCP Integration Status';
  mcpStatusItem.command = 'thefuse.mcp.showTools';
  mcpStatusItem.show();
  
  // Register all commands
  context.subscriptions.push(
    mcpInitCommand,
    mcpShowCommand,
    mcpTestCommand,
    mcpAskCommand,
    mcpStatusItem
  );
  
  vscode.window.showInformationMessage('The New Fuse is ready!', 'Initialize MCP').then(selection => {
    if (selection === 'Initialize MCP') {
      vscode.commands.executeCommand('thefuse.mcp.initialize');
    }
  });
}

function deactivate() {}

module.exports = { activate, deactivate };
EOFJS

# Create minimal package.json
cat > package.json << 'EOFJSON'
{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "main": "./out/extension.js",
  "activationEvents": ["onStartupFinished"],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.mcp.initialize",
        "title": "Initialize MCP Integration"
      },
      {
        "command": "thefuse.mcp.showTools",
        "title": "Show MCP Tools"
      },
      {
        "command": "thefuse.mcp.testTool",
        "title": "Test MCP Tool"
      },
      {
        "command": "thefuse.mcp.askAgent",
        "title": "Ask Agent with MCP Tools"
      }
    ]
  }
}
EOFJSON

# Create MCP config
cat > mcp_config.json << 'EOFCONFIG'
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "--allow-dir", "./data"
      ]
    }
  }
}
EOFCONFIG

# Create a launch script
cat > launch.sh << 'EOFLAUNCH'
#!/bin/bash

# Make sure VS Code can find the script and extension
CODE_PATH=""

# Find VS Code binary based on platform
if [ -x "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code" ]; then
  CODE_PATH="/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
elif command -v code &> /dev/null; then
  CODE_PATH="code"
else
  echo "Error: VS Code not found. Please make sure VS Code is installed."
  exit 1
fi

# Launch VS Code with the extension
echo "Launching VS Code with The New Fuse extension..."
"$CODE_PATH" --new-window --extensionDevelopmentPath="$(pwd)"

echo "VS Code launched! Use Command Palette (Cmd+Shift+P) and type 'MCP' to see the commands."
EOFLAUNCH

# Make the script executable
chmod +x launch.sh

echo ""
echo "Setup complete! To launch VS Code with The New Fuse extension:"
echo ""
echo "  ./launch.sh"
echo ""
echo "After VS Code opens:"
echo "1. Press Cmd+Shift+P (or Ctrl+Shift+P) to open the Command Palette"
echo "2. Type 'MCP' to see the available MCP commands"
echo "3. Select 'Initialize MCP Integration' to start"
echo ""
echo "===================================================="



==============================================
FILE: ./src/vscode-extension/setup.sh
==============================================

#!/bin/bash

# Create proper directory structure
mkdir -p out
mkdir -p test
mkdir -p web-ui
mkdir -p .vscode

# Create a basic package.json with correct scripts
echo '{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination and workflow automation for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "publisher": "thefuse",
  "categories": [
    "Other",
    "Machine Learning",
    "Programming Languages"
  ],
  "activationEvents": [
    "onStartupFinished"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "thefuse.openWebUI",
        "title": "Open The New Fuse UI"
      },
      {
        "command": "thefuse.startAICollab",
        "title": "Start AI Collaboration"
      },
      {
        "command": "thefuse.sendFileMessage",
        "title": "Send Message via File Protocol"
      },
      {
        "command": "thefuse.toggleCollaborativeCompletion",
        "title": "Toggle Collaborative Completion Mode"
      },
      {
        "command": "thefuse.startCollaborativeCoding",
        "title": "Start Collaborative Coding with AI Team"
      },
      {
        "command": "thefuse.analyzeCodeProblem",
        "title": "Analyze Code Problem with AI Team"
      }
    ],
    "menus": {
      "editor/context": [
        {
          "command": "thefuse.startAICollab",
          "group": "navigation"
        },
        {
          "command": "thefuse.startCollaborativeCoding",
          "group": "navigation"
        },
        {
          "command": "thefuse.analyzeCodeProblem",
          "group": "navigation"
        }
      ]
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "lint": "eslint src --ext ts",
    "test": "node ./out/test/runTest.js"
  },
  "dependencies": {
    "uuid": "^9.0.0",
    "axios": "^1.4.0"
  },
  "devDependencies": {
    "@types/glob": "^8.1.0",
    "@types/mocha": "^10.0.1",
    "@types/node": "20.2.5",
    "@types/uuid": "^9.0.1",
    "@types/vscode": "^1.80.0",
    "@typescript-eslint/eslint-plugin": "^5.59.8",
    "@typescript-eslint/parser": "^5.59.8",
    "@vscode/test-electron": "^2.3.8",
    "eslint": "^8.41.0",
    "glob": "^8.1.0",
    "mocha": "^10.2.0",
    "typescript": "^5.1.3"
  }
}' > package.json

# Create a basic tsconfig.json
echo '{
  "compilerOptions": {
    "module": "CommonJS",
    "target": "ES2020",
    "outDir": "out",
    "lib": ["ES2020"],
    "sourceMap": true,
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "exclude": ["node_modules", ".vscode-test"]
}' > tsconfig.json

# Create .vscode/tasks.json
echo '{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "npm",
      "script": "watch",
      "problemMatcher": "$tsc-watch",
      "isBackground": true,
      "presentation": {
        "reveal": "never"
      },
      "group": {
        "kind": "build",
        "isDefault": true
      }
    }
  ]
}' > .vscode/tasks.json

# Make setup script executable
chmod +x setup.sh

echo "Setup complete! Run these commands to get started:"
echo "npm install"
echo "npm run compile"
echo "code --extensionDevelopmentPath=\$(pwd)"



==============================================
FILE: ./src/vscode-extension/src/anthropic-xml/commands.ts
==============================================

import * as vscode from 'vscode';
import { parseXmlFunctionCall, createXmlFunctionCall } from './xml-function-call';

/**
 * Register Anthropic XML function call commands
 * 
 * @param context The extension context
 * @returns An array of disposables
 */
export function registerAnthropicXmlCommands(context: vscode.ExtensionContext): vscode.Disposable[] {
  const disposables: vscode.Disposable[] = [];
  
  // Parse XML function call
  disposables.push(
    vscode.commands.registerCommand('thefuse.anthropic.parseXmlFunctionCall', async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showErrorMessage('No active editor');
        return;
      }
      
      const selection = editor.selection;
      const text = editor.document.getText(selection);
      
      if (!text) {
        vscode.window.showErrorMessage('No text selected');
        return;
      }
      
      try {
        const parsed = parseXmlFunctionCall(text);
        
        // Create a new document with the parsed JSON
        const doc = await vscode.workspace.openTextDocument({
          content: JSON.stringify(parsed, null, 2),
          language: 'json'
        });
        
        await vscode.window.showTextDocument(doc);
      } catch (error) {
        vscode.window.showErrorMessage(`Error parsing XML function call: ${error}`);
      }
    })
  );
  
  // Create XML function call
  disposables.push(
    vscode.commands.registerCommand('thefuse.anthropic.createXmlFunctionCall', async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showErrorMessage('No active editor');
        return;
      }
      
      const selection = editor.selection;
      const text = editor.document.getText(selection);
      
      if (!text) {
        vscode.window.showErrorMessage('No text selected');
        return;
      }
      
      try {
        // Try to parse the selected text as JSON
        const json = JSON.parse(text);
        
        if (!json.name || !json.parameters) {
          vscode.window.showErrorMessage('Selected JSON must have "name" and "parameters" properties');
          return;
        }
        
        const xml = createXmlFunctionCall(json.name, json.parameters);
        
        // Create a new document with the XML
        const doc = await vscode.workspace.openTextDocument({
          content: xml,
          language: 'xml'
        });
        
        await vscode.window.showTextDocument(doc);
      } catch (error) {
        vscode.window.showErrorMessage(`Error creating XML function call: ${error}`);
      }
    })
  );
  
  // Convert tool to XML format
  disposables.push(
    vscode.commands.registerCommand('thefuse.anthropic.convertToolToXmlFormat', async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showErrorMessage('No active editor');
        return;
      }
      
      const selection = editor.selection;
      const text = editor.document.getText(selection);
      
      if (!text) {
        vscode.window.showErrorMessage('No text selected');
        return;
      }
      
      try {
        // Try to parse the selected text as JSON
        const tool = JSON.parse(text);
        
        if (!tool.name || !tool.description || !tool.parameters) {
          vscode.window.showErrorMessage('Selected JSON must have "name", "description", and "parameters" properties');
          return;
        }
        
        // Create XML format for Anthropic tool definition
        const xml = `<tool_description>
<name>${tool.name}</name>
<description>${tool.description}</description>
<parameters>
${JSON.stringify(tool.parameters, null, 2)}
</parameters>
</tool_description>`;
        
        // Create a new document with the XML
        const doc = await vscode.workspace.openTextDocument({
          content: xml,
          language: 'xml'
        });
        
        await vscode.window.showTextDocument(doc);
      } catch (error) {
        vscode.window.showErrorMessage(`Error converting tool to XML format: ${error}`);
      }
    })
  );
  
  // Convert selection to XML function call
  disposables.push(
    vscode.commands.registerCommand('thefuse.anthropic.convertSelectionToXmlFunctionCall', async () => {
      const functionName = await vscode.window.showInputBox({
        prompt: 'Enter function name',
        placeHolder: 'function_name'
      });
      
      if (!functionName) {
        return;
      }
      
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showErrorMessage('No active editor');
        return;
      }
      
      const selection = editor.selection;
      const text = editor.document.getText(selection);
      
      if (!text) {
        vscode.window.showErrorMessage('No text selected');
        return;
      }
      
      try {
        // Try to parse the selected text as JSON
        const parameters = JSON.parse(text);
        
        const xml = createXmlFunctionCall(functionName, parameters);
        
        // Replace the selection with the XML
        await editor.edit(editBuilder => {
          editBuilder.replace(selection, xml);
        });
      } catch (error) {
        vscode.window.showErrorMessage(`Error converting selection to XML function call: ${error}`);
      }
    })
  );
  
  return disposables;
}



==============================================
FILE: ./src/vscode-extension/src/anthropic-xml/xml-function-call.ts
==============================================

import * as vscode from 'vscode';

/**
 * Anthropic XML function call utilities
 * 
 * These utilities help with parsing and creating XML function calls for Anthropic models
 */

/**
 * Parse an Anthropic XML function call
 * 
 * @param xmlString The XML string to parse
 * @returns The parsed function call object
 */
export function parseXmlFunctionCall(xmlString: string): any {
  try {
    // Extract function name
    const functionNameMatch = xmlString.match(/<invoke name="([^"]+)">/);
    if (!functionNameMatch) {
      throw new Error('Function name not found in XML');
    }
    const functionName = functionNameMatch[1];
    
    // Extract parameters
    const parameters: Record<string, any> = {};
    const paramRegex = /<parameter name="([^"]+)">([^<]+)<\/antml:parameter>/g;
    let match;
    
    while ((match = paramRegex.exec(xmlString)) !== null) {
      const [_, paramName, paramValue] = match;
      
      // Try to parse as JSON if it looks like a JSON value
      try {
        if (
          (paramValue.startsWith('{') && paramValue.endsWith('}')) ||
          (paramValue.startsWith('[') && paramValue.endsWith(']')) ||
          paramValue === 'true' ||
          paramValue === 'false' ||
          !isNaN(Number(paramValue))
        ) {
          parameters[paramName] = JSON.parse(paramValue);
        } else {
          parameters[paramName] = paramValue;
        }
      } catch (e) {
        // If parsing fails, use the raw string
        parameters[paramName] = paramValue;
      }
    }
    
    return {
      name: functionName,
      parameters
    };
  } catch (error) {
    console.error('Error parsing XML function call:', error);
    throw error;
  }
}

/**
 * Create an Anthropic XML function call
 * 
 * @param functionName The name of the function
 * @param parameters The parameters for the function
 * @returns The XML function call string
 */
export function createXmlFunctionCall(functionName: string, parameters: Record<string, any>): string {
  try {
    let xml = `<function_calls>\n<invoke name="${functionName}">\n`;
    
    for (const [paramName, paramValue] of Object.entries(parameters)) {
      const stringValue = typeof paramValue === 'object' 
        ? JSON.stringify(paramValue) 
        : String(paramValue);
      
      xml += `<parameter name="${paramName}">${stringValue}</parameter>\n`;
    }
    
    xml += `</invoke>\n</function_calls>`;
    return xml;
  } catch (error) {
    console.error('Error creating XML function call:', error);
    throw error;
  }
}



==============================================
FILE: ./src/vscode-extension/src/chat/chat-interface.ts
==============================================

import * as vscode from 'vscode';
import { v4 as uuidv4 } from 'uuid';
import { LLMProviderManager } from '../llm/LLMProviderManager'; // Assuming path
import { AgentMCPIntegration } from '../../mcp-integration'; // Assuming path

/**
 * Chat message types
 */
export interface ChatMessage {
    id: string;
    role: 'user' | 'assistant' | 'system';
    content: string;
    timestamp: number;
}

/**
 * Chat session to store conversation history
 */
export interface ChatSession {
    id: string;
    name: string;
    messages: ChatMessage[];
    createdAt: number;
    updatedAt: number;
}

/**
 * Provider for the chat sidebar view
 */
export class ChatViewProvider implements vscode.WebviewViewProvider {
    public static readonly viewType = 'thefuse.chatView';
    private _view?: vscode.WebviewView;
    private _sessions: ChatSession[] = [];
    private _currentSessionId?: string;
    private _lmBridge: LLMProviderManager; // Added
    private _agentIntegration: AgentMCPIntegration; // Added

    constructor(
        private readonly _extensionUri: vscode.Uri,
        private readonly _extensionContext: vscode.ExtensionContext,
        lmBridge: LLMProviderManager, // Added
        agentIntegration: AgentMCPIntegration // Added
    ) {
        this._lmBridge = lmBridge; // Added
        this._agentIntegration = agentIntegration; // Added

        // Load saved sessions if any
        this._sessions = this._extensionContext.globalState.get<ChatSession[]>('thefuse.chatSessions', []);
        this._currentSessionId = this._extensionContext.globalState.get<string>('thefuse.currentChatSessionId');
        
        // Create a default session if none exists
        if (this._sessions.length === 0) {
            this._createNewSession('New Chat');
        }
    }

    resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        this._view = webviewView;

        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [this._extensionUri]
        };

        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

        // Handle messages from the webview
        webviewView.webview.onDidReceiveMessage(message => {
            switch (message.command) {
                case 'sendMessage':
                    this._handleUserMessage(message.text);
                    break;
                case 'newChat':
                    this._createNewSession('New Chat');
                    this._updateWebview();
                    break;
                case 'clearChat':
                    this._clearCurrentSession();
                    this._updateWebview();
                    break;
                case 'selectSession':
                    this._currentSessionId = message.sessionId;
                    this._saveState();
                    this._updateWebview();
                    break;
            }
        });

        // Initial update
        this._updateWebview();
    }

    /**
     * Get the current chat session
     */
    private _getCurrentSession(): ChatSession | undefined {
        return this._sessions.find(s => s.id === this._currentSessionId);
    }

    /**
     * Create a new chat session
     */
    private _createNewSession(name: string): void {
        const newSession: ChatSession = {
            id: uuidv4(),
            name,
            messages: [],
            createdAt: Date.now(),
            updatedAt: Date.now()
        };
        
        this._sessions.push(newSession);
        this._currentSessionId = newSession.id;
        this._saveState();
    }

    /**
     * Clear the current chat session
     */
    private _clearCurrentSession(): void {
        const currentSession = this._getCurrentSession();
        if (currentSession) {
            currentSession.messages = [];
            currentSession.updatedAt = Date.now();
            this._saveState();
        }
    }

    /**
     * Handle a user message
     */
    private async _handleUserMessage(text: string): Promise<void> {
        const currentSession = this._getCurrentSession();
        if (!currentSession) return;

        // Add user message
        const userMessage: ChatMessage = {
            id: uuidv4(),
            role: 'user',
            content: text,
            timestamp: Date.now()
        };
        
        currentSession.messages.push(userMessage);
        currentSession.updatedAt = Date.now();
        this._saveState();
        this._updateWebview(); // Update UI immediately with user message

        // Show loading indicator in webview
        this._view?.webview.postMessage({ command: 'showLoading' });

        try {
            // Use the AgentMCPIntegration to handle the query
            // This integration should internally get tools and interact with the LM
            const responseContent = await this._agentIntegration.askAgent(text, currentSession.messages);

            const assistantMessage: ChatMessage = {
                id: uuidv4(),
                role: 'assistant',
                content: responseContent || 'Sorry, I could not process that.', // Use response or fallback
                timestamp: Date.now()
            };
            
            currentSession.messages.push(assistantMessage);

        } catch (error: any) {
            console.error('Error getting assistant response via AgentIntegration:', error);
            vscode.window.showErrorMessage(`Error processing message: ${error.message}`);
            // Add an error message to the chat
            const errorMessage: ChatMessage = {
                id: uuidv4(),
                role: 'assistant',
                content: `Sorry, an error occurred: ${error.message}`,
                timestamp: Date.now()
            };
            currentSession.messages.push(errorMessage);
        } finally {
            // Hide loading indicator
            this._view?.webview.postMessage({ command: 'hideLoading' });
            // Update state and UI with the response or error
            currentSession.updatedAt = Date.now();
            this._saveState();
            this._updateWebview();
        }
    }

    /**
     * Save the chat state
     */
    private _saveState(): void {
        this._extensionContext.globalState.update('thefuse.chatSessions', this._sessions);
        this._extensionContext.globalState.update('thefuse.currentChatSessionId', this._currentSessionId);
    }

    /**
     * Update the webview content
     */
    private _updateWebview(): void {
        if (this._view) {
            this._view.webview.html = this._getHtmlForWebview(this._view.webview);
        }
    }

    /**
     * Get the HTML for the webview
     */
    private _getHtmlForWebview(webview: vscode.Webview): string {
        const currentSession = this._getCurrentSession();
        const messages = currentSession ? currentSession.messages : [];
        const sessions = this._sessions.map(s => ({
            id: s.id,
            name: s.name,
            isActive: s.id === this._currentSessionId
        }));

        // Get nonce for CSP
        const nonce = getNonce();

        // Get URIs for webview resources
        const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'web-ui', 'chat-ui.js'));
        const styleUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'web-ui', 'chat-ui.css'));
        const toolkitUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, 'node_modules', '@vscode', 'webview-ui-toolkit', 'dist', 'toolkit.js'));

        // Create message HTML using a more structured approach
        const messagesHtml = messages.map(msg => {
            const roleClass = msg.role === 'user' ? 'user' : 'assistant';
            const roleLabel = msg.role === 'user' ? 'You' : 'Trae'; // Use 'Trae' for assistant
            const timestamp = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            // Basic markdown handling (needs improvement for full Trae parity)
            const formattedContent = this._formatMessageContent(msg.content);

            return `
                <div class="message-container message-${roleClass}">
                    <div class="message-header">
                        <span class="role">${roleLabel}</span>
                        <span class="timestamp">${timestamp}</span>
                    </div>
                    <div class="message-content">${formattedContent}</div>
                </div>
            `;
        }).join('');

        // Create sessions dropdown HTML
        const sessionsHtml = sessions.map(session => `
            <vscode-option value="${session.id}" ${session.isActive ? 'selected' : ''}>${session.name}</vscode-option>
        `).join('');

        // Main HTML structure using VS Code Webview UI Toolkit
        return `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}' ${webview.cspSource}; img-src ${webview.cspSource} https:;">
                <title>The New Fuse Chat</title>
                <script type="module" nonce="${nonce}" src="${toolkitUri}"></script>
                <link rel="stylesheet" href="${styleUri}">
            </head>
            <body>
                <div class="chat-container">
                    <header class="chat-header">
                        <vscode-dropdown id="session-select" class="session-dropdown">
                            ${sessionsHtml}
                        </vscode-dropdown>
                        <vscode-button id="new-chat-button" appearance="secondary" title="New Chat">+</vscode-button>
                        <vscode-button id="clear-chat-button" appearance="secondary" title="Clear Chat">🗑️</vscode-button>
                    </header>

                    <div id="message-list" class="message-list">
                        ${messages.length === 0 ? '<div class="welcome-message"><h2>Welcome to The New Fuse Chat</h2><p>Start by typing your message below.</p></div>' : messagesHtml}
                        <div id="loading-indicator" class="loading-indicator" style="display: none;">
                            <vscode-progress-ring></vscode-progress-ring>
                        </div>
                    </div>

                    <footer class="input-area">
                        <vscode-text-area id="message-input" class="message-input" placeholder="Type your message here..." resize="vertical"></vscode-text-area>
                        <vscode-button id="send-button" class="send-button" appearance="primary">Send</vscode-button>
                    </footer>
                </div>

                <script nonce="${nonce}" src="${scriptUri}"></script>
            </body>
            </html>`;
    }

    /**
     * Format message content (basic markdown for now)
     * TODO: Enhance this to match Trae's rendering (code blocks, lists, etc.)
     */
    private _formatMessageContent(content: string): string {
        // Escape HTML to prevent injection
        let escapedContent = content
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");

        // Basic code block handling (```language\ncode```)
        escapedContent = escapedContent.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
            const languageClass = lang ? `language-${lang}` : '';
            // Needs proper syntax highlighting integration
            return `<pre><code class="${languageClass}">${code.trim()}</code></pre>`;
        });

        // Basic inline code handling (`code`)
        escapedContent = escapedContent.replace(/`([^`]+)`/g, '<code>$1</code>');

        // Basic bold handling (**bold**)
        escapedContent = escapedContent.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');

        // Basic italic handling (*italic*)
        escapedContent = escapedContent.replace(/\*([^\*]+)\*/g, '<em>$1</em>');

        // Convert newlines to <br>
        escapedContent = escapedContent.replace(/\n/g, '<br>');

        return escapedContent;
    }
}

// Helper function to generate nonce
function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

/**
 * Chat panel WebView implementation for a floating window
 */
export class ChatPanel {
    public static currentPanel: ChatPanel | undefined;
    private static readonly viewType = 'thefuseChatPanel';
    private readonly _panel: vscode.WebviewPanel;
    private readonly _extensionUri: vscode.Uri;
    private _disposables: vscode.Disposable[] = [];
    private _messages: ChatMessage[] = [];

    public static createOrShow(extensionUri: vscode.Uri) {
        // If panel already exists, show it
        if (ChatPanel.currentPanel) {
            ChatPanel.currentPanel._panel.reveal();
            return;
        }

        // Get configuration for chat panel position
        const config = vscode.workspace.getConfiguration('theFuse');
        const panelPosition = config.get<'active' | 'beside' | 'smart'>('chatPanelPosition', 'smart');
        const viewColumn = panelPosition === 'active' ? vscode.ViewColumn.Active : 
                          (panelPosition === 'beside' ? vscode.ViewColumn.Beside : 
                           (vscode.window.activeTextEditor ? vscode.ViewColumn.Beside : vscode.ViewColumn.Active));

        // Create a new panel in a more Copilot-like position
        const panel = vscode.window.createWebviewPanel(
            ChatPanel.viewType,
            'The New Fuse Chat',
            viewColumn,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [extensionUri]
            }
        );

        // Make panel narrower for a more chat-like experience
        panel.onDidChangeViewState(e => {
            if (e.webviewPanel.visible) {
                // Adjust panel size - this is a workaround as there's no direct way to set width
                setTimeout(() => {
                    vscode.commands.executeCommand('workbench.action.toggleSidebarPosition');
                    vscode.commands.executeCommand('workbench.action.toggleSidebarPosition');
                }, 100);
            }
        });

        ChatPanel.currentPanel = new ChatPanel(panel, extensionUri);
    }

    private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {
        this._panel = panel;
        this._extensionUri = extensionUri;

        // Set initial HTML content
        this._updateWebviewContent();

        // Handle panel disposal
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

        // Handle webview messages
        this._panel.webview.onDidReceiveMessage(
            message => {
                switch (message.command) {
                    case 'sendMessage':
                        this._handleUserMessage(message.text);
                        break;
                    case 'clearChat':
                        this._messages = [];
                        this._updateWebviewContent();
                        break;
                    case 'newChat':
                        this._messages = [];
                        this._updateWebviewContent();
                        break;
                }
            },
            null,
            this._disposables
        );
    }

    private _handleUserMessage(text: string) {
        // Add user message
        this._messages.push({
            id: uuidv4(),
            role: 'user',
            content: text,
            timestamp: Date.now()
        });
        
        this._updateWebviewContent();

        // Simulate assistant response (to be replaced with actual AI response)
        setTimeout(() => {
            this._messages.push({
                id: uuidv4(),
                role: 'assistant',
                content: `I received your message: "${text}"\n\nThis is a placeholder response from The New Fuse. In a complete implementation, this would be an actual response from an AI model.`,
                timestamp: Date.now()
            });
            this._updateWebviewContent();
        }, 1000);
    }

    private _updateWebviewContent() {
        // Get font size from configuration
        const config = vscode.workspace.getConfiguration('theFuse');
        const fontSize = config.get('chatFontSize', 13);
        
        // Generate message HTML
        let messagesHtml = '';
        for (const msg of this._messages) {
            const roleClass = msg.role === 'user' ? 'user-message' : 'assistant-message';
            const roleIcon = msg.role === 'user' ? '$(person)' : '$(sparkle)';
            
            messagesHtml += `
                <div class="message ${roleClass}">
                    <div class="message-header">
                        <span class="message-icon">${roleIcon}</span>
                        <span class="message-role">${msg.role === 'user' ? 'You' : 'The New Fuse'}</span>
                    </div>
                    <div class="message-content">${this._formatMessageContent(msg.content)}</div>
                </div>
            `;
        }

        this._panel.webview.html = `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>The New Fuse Chat</title>
                <style>
                    body {
                        font-family: var(--vscode-font-family);
                        font-size: var(--vscode-font-size);
                        color: var(--vscode-foreground);
                        padding: 0;
                        margin: 0;
                        display: flex;
                        flex-direction: column;
                        height: 100vh;
                        overflow: hidden;
                    }
                    .header {
                        padding: 8px 12px;
                        border-bottom: 1px solid var(--vscode-panel-border);
                        display: flex;
                        align-items: center;
                        background-color: var(--vscode-editor-background);
                    }
                    .header h2 {
                        margin: 0;
                        flex: 1;
                        font-size: 14px;
                        display: flex;
                        align-items: center;
                    }
                    .header h2::before {
                        content: '';
                        display: inline-block;
                        width: 16px;
                        height: 16px;
                        background-color: var(--vscode-button-background);
                        margin-right: 8px;
                        border-radius: 50%;
                    }
                    .header-buttons {
                        display: flex;
                        gap: 8px;
                    }
                    .header button {
                        background: transparent;
                        color: var(--vscode-foreground);
                        border: none;
                        padding: 4px 8px;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        font-size: 12px;
                        border-radius: 3px;
                    }
                    .header button:hover {
                        background: var(--vscode-button-hoverBackground);
                    }
                    .messages {
                        flex: 1;
                        overflow-y: auto;
                        padding: 16px;
                        background-color: var(--vscode-editor-background);
                    }
                    .message {
                        margin-bottom: 24px;
                        max-width: 100%;
                    }
                    .user-message .message-content {
                        background-color: var(--vscode-button-background);
                        color: var(--vscode-button-foreground);
                        padding: 8px 12px;
                        border-radius: 6px;
                    }
                    .assistant-message .message-content {
                        background-color: var(--vscode-input-background);
                        border: 1px solid var(--vscode-input-border);
                        padding: 8px 12px;
                        border-radius: 6px;
                    }
                    .message-header {
                        display: flex;
                        align-items: center;
                        margin-bottom: 6px;
                        font-size: 12px;
                        font-weight: 500;
                    }
                    .message-icon {
                        margin-right: 6px;
                    }
                    .message-role {
                        font-weight: 600;
                    }
                    .message-content {
                        white-space: pre-wrap;
                        word-break: break-word;
                        line-height: 1.5;
                    }
                    .message-content code {
                        font-family: var(--vscode-editor-font-family);
                        background: var(--vscode-textCodeBlock-background);
                        padding: 2px 4px;
                        border-radius: 3px;
                        font-size: 90%;
                    }
                    .message-content pre {
                        background: var(--vscode-textCodeBlock-background);
                        padding: 12px;
                        border-radius: 6px;
                        overflow-x: auto;
                        margin: 8px 0;
                    }
                    .message-content pre code {
                        background: transparent;
                        padding: 0;
                        border-radius: 0;
                    }
                    .input-area {
                        padding: 12px 16px;
                        border-top: 1px solid var(--vscode-panel-border);
                        background-color: var(--vscode-editor-background);
                    }
                    .input-box {
                        width: 100%;
                        display: flex;
                        border-radius: 8px;
                        overflow: hidden;
                        border: 1px solid var(--vscode-input-border);
                        box-shadow: 0 0 2px rgba(0, 0, 0, 0.1);
                    }
                    .input-box textarea {
                        flex: 1;
                        min-height: 40px;
                        max-height: 200px;
                        background: var(--vscode-input-background);
                        color: var(--vscode-input-foreground);
                        border: none;
                        padding: 10px 12px;
                        resize: none;
                        font-family: var(--vscode-font-family);
                        font-size: ${fontSize}px;
                        line-height: 1.5;
                    }
                    .input-box textarea:focus {
                        outline: none;
                    }
                    .input-box button {
                        width: 60px;
                        background: var(--vscode-button-background);
                        color: var(--vscode-button-foreground);
                        border: none;
                        cursor: pointer;
                        font-weight: 500;
                        transition: background-color 0.2s;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                    .input-box button:hover {
                        background: var(--vscode-button-hoverBackground);
                    }
                    .input-box button:disabled {
                        opacity: 0.6;
                        cursor: not-allowed;
                    }
                    .welcome-message {
                        text-align: center;
                        padding: 40px 20px;
                    }
                    .welcome-message h2 {
                        margin-bottom: 20px;
                        font-weight: 500;
                        font-size: 18px;
                    }
                    .welcome-message p {
                        margin-bottom: 15px;
                        color: var(--vscode-descriptionForeground);
                    }
                    .welcome-message .logo {
                        font-size: 36px;
                        margin-bottom: 16px;
                    }
                    .codicon {
                        font-family: codicon;
                        line-height: 1;
                    }
                    .actions-container {
                        position: absolute;
                        right: 8px;
                        top: 8px;
                        display: none;
                    }
                    .message:hover .actions-container {
                        display: flex;
                    }
                    .action-button {
                        background: transparent;
                        border: none;
                        color: var(--vscode-descriptionForeground);
                        cursor: pointer;
                        padding: 2px;
                        margin-left: 4px;
                        opacity: 0.7;
                    }
                    .action-button:hover {
                        opacity: 1;
                    }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2>The New Fuse AI Chat</h2>
                    <div class="header-buttons">
                        <button id="newChatBtn" title="New Chat">
                            <span class="codicon">$(add)</span> New Chat
                        </button>
                        <button id="clearChatBtn" title="Clear Chat">
                            <span class="codicon">$(clear-all)</span> Clear
                        </button>
                    </div>
                </div>
                
                <div class="messages" id="messages">
                    ${this._messages.length > 0 ? messagesHtml : `
                        <div class="welcome-message">
                            <div class="logo">✨</div>
                            <h2>The New Fuse AI Assistant</h2>
                            <p>Ask me anything about coding, debugging, or software development.</p>
                            <p>I can help with code explanations, generate code, provide programming guidance, and more.</p>
                        </div>
                    `}
                </div>
                
                <div class="input-area">
                    <div class="input-box">
                        <textarea id="messageInput" placeholder="Ask The New Fuse something..." rows="1"></textarea>
                        <button id="sendBtn" title="Send Message">
                            <span class="codicon">$(send)</span>
                        </button>
                    </div>
                </div>
                
                <script>
                    (function() {
                        const vscode = acquireVsCodeApi();
                        const messageInput = document.getElementById('messageInput');
                        const sendBtn = document.getElementById('sendBtn');
                        const newChatBtn = document.getElementById('newChatBtn');
                        const clearChatBtn = document.getElementById('clearChatBtn');
                        const messagesContainer = document.getElementById('messages');
                        
                        // Auto-resize textarea
                        function autoResizeTextarea() {
                            messageInput.style.height = 'auto';
                            const newHeight = Math.min(messageInput.scrollHeight, 200);
                            messageInput.style.height = newHeight + 'px';
                        }
                        
                        // Scroll to bottom of messages
                        function scrollToBottom() {
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        }
                        
                        // Scroll to bottom initially
                        scrollToBottom();
                        
                        // Send message
                        function sendMessage() {
                            const text = messageInput.value.trim();
                            if (text) {
                                vscode.postMessage({
                                    command: 'sendMessage',
                                    text: text
                                });
                                messageInput.value = '';
                                messageInput.style.height = 'auto';
                                updateSendButton();
                            }
                        }
                        
                        // Update send button state
                        function updateSendButton() {
                            sendBtn.disabled = messageInput.value.trim() === '';
                        }
                        
                        // Set up event listeners
                        messageInput.addEventListener('input', () => {
                            updateSendButton();
                            autoResizeTextarea();
                        });
                        
                        messageInput.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' && !e.shiftKey) {
                                e.preventDefault();
                                sendMessage();
                            }
                        });
                        
                        sendBtn.addEventListener('click', sendMessage);
                        
                        newChatBtn.addEventListener('click', () => {
                            vscode.postMessage({ command: 'newChat' });
                        });
                        
                        clearChatBtn.addEventListener('click', () => {
                            vscode.postMessage({ command: 'clearChat' });
                        });
                        
                        // Observer for scrolling to bottom when new messages arrive
                        const observer = new MutationObserver(() => {
                            scrollToBottom();
                        });
                        
                        observer.observe(messagesContainer, { 
                            childList: true, 
                            subtree: true 
                        });
                        
                        // Focus input field
                        setTimeout(() => {
                            messageInput.focus();
                        }, 300);
                        
                        // Initial button state
                        updateSendButton();
                    }());
                </script>
            </body>
            </html>`;
    }

    private _formatMessageContent(content: string): string {
        // Very basic formatting, could be enhanced with a proper Markdown parser
        let formattedContent = content;
        
        // Format code blocks
        formattedContent = formattedContent.replace(/```([\s\S]*?)```/g, (_, code) => {
            return `<pre><code>${code}</code></pre>`;
        });
        
        // Format inline code
        formattedContent = formattedContent.replace(/`([^`]+)`/g, (_, code) => {
            return `<code>${code}</code>`;
        });
        
        // Convert newlines to <br>
        formattedContent = formattedContent.replace(/\n/g, '<br>');
        
        return formattedContent;
    }

    public dispose() {
        ChatPanel.currentPanel = undefined;
        
        // Clean up resources
        this._panel.dispose();
        while (this._disposables.length) {
            const disposable = this._disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
}


==============================================
FILE: ./src/vscode-extension/src/command-monitor.ts
==============================================

import * as vscode from 'vscode';

/**
 * CommandMonitor class for monitoring and routing commands based on the current mode
 */
export class CommandMonitor {
  private static instance: CommandMonitor;
  private disposables: vscode.Disposable[] = [];
  private commandHistory: Array<{command: string, args: unknown[], timestamp: Date}> = [];
  private currentMode: string = 'orchestrator'; // Default mode

  private constructor(private context: vscode.ExtensionContext) {
    // Initialize with the stored mode or default to 'orchestrator'
    this.currentMode = context.globalState.get<string>('thefuse.currentMode') || 'orchestrator';
    
    // Set the context variable for UI visibility
    vscode.commands.executeCommand('setContext', 'thefuse.currentMode', this.currentMode);
    
    // Monitor command executions
    this.disposables.push(
      vscode.commands.onDidExecuteCommand(this.onCommandExecuted.bind(this))
    );
  }

  /**
   * Get the singleton instance of CommandMonitor
   */
  public static getInstance(context: vscode.ExtensionContext): CommandMonitor {
    if (!CommandMonitor.instance) {
      CommandMonitor.instance = new CommandMonitor(context);
    }
    return CommandMonitor.instance;
  }

  /**
   * Handle command execution
   */
  private async onCommandExecuted(e: vscode.CommandEvent): Promise<void> {
    // Record the command
    this.commandHistory.push({
      command: e.command,
      args: [],
      timestamp: new Date()
    });

    // Route the command based on the current mode
    await this.routeCommand(e.command);
  }

  /**
   * Route commands to the appropriate handler based on the current mode
   */
  private async routeCommand(command: string): Promise<void> {
    // Skip routing for mode-switching commands
    if (command.startsWith('thefuse.mode.')) {
      return;
    }

    try {
      // Import the appropriate handler dynamically
      const handlerModule = await this.getHandlerForCurrentMode();
      if (handlerModule && handlerModule.handle) {
        await handlerModule.handle(command);
      }
    } catch (error) {
      console.error(`Error routing command ${command} in mode ${this.currentMode}:`, error);
    }
  }

  /**
   * Get the handler module for the current mode
   */
  private async getHandlerForCurrentMode(): Promise<any> {
    try {
      // Dynamic import of the handler based on the current mode
      switch (this.currentMode) {
        case 'orchestrator':
          return await import('./modes/orchestratorHandler');
        case 'debug':
          return await import('./modes/debugHandler');
        case 'ask':
          return await import('./modes/askHandler');
        case 'architect':
          return await import('./modes/architectHandler');
        case 'code':
          return await import('./modes/codeHandler');
        default:
          console.warn(`No handler found for mode: ${this.currentMode}`);
          return null;
      }
    } catch (error) {
      console.error(`Error importing handler for mode ${this.currentMode}:`, error);
      return null;
    }
  }

  /**
   * Set the current mode
   */
  public async setMode(mode: string): Promise<void> {
    if (this.currentMode === mode) {
      return; // No change needed
    }

    this.currentMode = mode;
    
    // Store the mode in extension state
    await this.context.globalState.update('thefuse.currentMode', mode);
    
    // Update the context variable for UI visibility
    await vscode.commands.executeCommand('setContext', 'thefuse.currentMode', mode);
    
    // Update the configuration
    const config = vscode.workspace.getConfiguration('theFuse');
    await config.update('currentMode', mode, vscode.ConfigurationTarget.Global);
    
    // Show notification
    vscode.window.showInformationMessage(`Switched to ${mode} mode`);
  }

  /**
   * Get the current mode
   */
  public getCurrentMode(): string {
    return this.currentMode;
  }

  /**
   * Get command history
   */
  public getCommandHistory(): Array<{command: string, args: unknown[], timestamp: Date}> {
    return [...this.commandHistory];
  }

  /**
   * Dispose of resources
   */
  public dispose(): void {
    this.disposables.forEach(d => d.dispose());
  }
}

/**
 * Register mode-related commands
 */
export function registerModeCommands(context: vscode.ExtensionContext): vscode.Disposable[] {
  const commandMonitor = CommandMonitor.getInstance(context);
  
  const disposables: vscode.Disposable[] = [];
  
  // Register the select mode command
  disposables.push(
    vscode.commands.registerCommand('thefuse.selectMode', async () => {
      const modes = ['orchestrator', 'debug', 'ask', 'architect', 'code'];
      const currentMode = commandMonitor.getCurrentMode();
      
      const selectedMode = await vscode.window.showQuickPick(
        modes.map(mode => ({
          label: `${mode.charAt(0).toUpperCase() + mode.slice(1)} Mode`,
          description: mode === currentMode ? '(Current)' : '',
          mode
        })),
        {
          placeHolder: 'Select a mode',
          title: 'The New Fuse Mode'
        }
      );
      
      if (selectedMode) {
        await commandMonitor.setMode(selectedMode.mode);
      }
    })
  );
  
  // Register individual mode commands
  disposables.push(
    vscode.commands.registerCommand('thefuse.mode.orchestrator', () => 
      commandMonitor.setMode('orchestrator')
    ),
    vscode.commands.registerCommand('thefuse.mode.debug', () => 
      commandMonitor.setMode('debug')
    ),
    vscode.commands.registerCommand('thefuse.mode.ask', () => 
      commandMonitor.setMode('ask')
    ),
    vscode.commands.registerCommand('thefuse.mode.architect', () => 
      commandMonitor.setMode('architect')
    ),
    vscode.commands.registerCommand('thefuse.mode.code', () => 
      commandMonitor.setMode('code')
    )
  );
  
  return disposables;
}



==============================================
FILE: ./src/vscode-extension/src/commands/README.md
==============================================

# VS Code Extension Commands

This directory contains the implementation of VS Code extension commands for The New Fuse.

## Verification Commands

The `verification-commands.ts` file implements commands for the AI Verification Agent:

- `thefuse.verification.initialize`: Initializes a verification agent
- `thefuse.verification.verifyClaim`: Verifies a claim using a verification agent
- `thefuse.verification.setLevel`: Changes the verification level of a verification agent

### Features

- LLM-based verification in production mode
- Simulated verification in development mode
- Caching of verification results
- Event-based communication with other components

### Testing

Unit tests for the verification commands are in the `__tests__` directory.

## Usage

See the [verification agent documentation](../docs/verification-agent.md) for detailed usage instructions.



==============================================
FILE: ./src/vscode-extension/src/commands/__tests__/verification-commands.test.ts
==============================================

/**
 * Tests for verification commands
 */

import * as vscode from 'vscode';
import { 
  VerificationCommandsManager, 
  registerVerificationCommands,
  VerificationLevel,
  VerificationEventType
} from '../verification-commands';

// Mock VS Code APIs
jest.mock('vscode', () => {
  const originalModule = jest.requireActual('vscode');
  
  return {
    ...originalModule,
    window: {
      createOutputChannel: jest.fn().mockReturnValue({
        appendLine: jest.fn(),
        clear: jest.fn(),
        show: jest.fn(),
        hide: jest.fn(),
        dispose: jest.fn()
      })
    },
    commands: {
      registerCommand: jest.fn().mockReturnValue({ dispose: jest.fn() })
    },
    EventEmitter: class {
      event = jest.fn();
      fire = jest.fn();
    },
    Disposable: class {
      constructor(public callback: () => void) {}
      dispose() {
        this.callback();
      }
    }
  };
});

// Mock file system
jest.mock('fs', () => ({
  existsSync: jest.fn().mockReturnValue(false),
  mkdirSync: jest.fn(),
  writeFileSync: jest.fn(),
  readFileSync: jest.fn()
}));

// Mock crypto
jest.mock('crypto', () => ({
  createHash: jest.fn().mockReturnValue({
    update: jest.fn().mockReturnThis(),
    digest: jest.fn().mockReturnValue('mock-hash')
  })
}));

// Mock LLM service
const mockLLMService = {
  generateCompletion: jest.fn().mockResolvedValue({
    status: 'verified',
    confidenceScore: 0.8,
    explanation: 'This claim is verified based on multiple sources',
    sources: [
      {
        name: 'Test Source',
        url: 'https://example.com/test',
        type: 'official',
        reliability: 0.9,
        excerpt: 'This is a test excerpt'
      }
    ]
  })
};

describe('VerificationCommandsManager', () => {
  let context: vscode.ExtensionContext;
  let manager: VerificationCommandsManager;
  
  beforeEach(() => {
    // Mock extension context
    context = {
      subscriptions: [],
      globalStorageUri: { fsPath: '/mock/path' } as any,
      extensionUri: { fsPath: '/mock/extension/path' } as any,
      extensionPath: '/mock/extension/path',
      asAbsolutePath: jest.fn().mockImplementation(p => `/mock/extension/path/${p}`),
      storagePath: '/mock/storage/path',
      globalState: {
        get: jest.fn(),
        update: jest.fn(),
        setKeysForSync: jest.fn()
      } as any,
      workspaceState: {
        get: jest.fn(),
        update: jest.fn()
      } as any,
      secrets: {
        get: jest.fn(),
        store: jest.fn(),
        delete: jest.fn()
      } as any,
      extensionMode: 1,
      logUri: { fsPath: '/mock/log/path' } as any,
      logPath: '/mock/log/path',
      globalStoragePath: '/mock/global/storage/path',
      environmentVariableCollection: {} as any
    };
    
    // Create manager instance
    manager = registerVerificationCommands(context, mockLLMService);
  });
  
  afterEach(() => {
    jest.clearAllMocks();
  });
  
  describe('initializeAgent', () => {
    it('should initialize an agent with valid parameters', async () => {
      // @ts-ignore - Access private method for testing
      const result = await manager['initializeAgent']({
        id: 'test-agent-1',
        name: 'Test Agent',
        verificationLevel: VerificationLevel.STANDARD,
        trustedSources: ['source1', 'source2'],
        minConfidenceThreshold: 0.7,
        maxResponseTime: 30,
        supportedProtocols: ['protocol1'],
        capabilities: ['capability1']
      });
      
      expect(result.success).toBe(true);
      expect(result.message).toContain('Initialized verification agent');
      
      // @ts-ignore - Access private property for testing
      const agents = manager['registeredAgents'];
      expect(agents.size).toBe(1);
      expect(agents.get('test-agent-1')).toBeDefined();
      expect(agents.get('test-agent-1')?.name).toBe('Test Agent');
    });
    
    it('should fail to initialize an agent with missing parameters', async () => {
      // @ts-ignore - Access private method for testing
      const result = await manager['initializeAgent']({
        // Missing id and name
        verificationLevel: VerificationLevel.STANDARD
      });
      
      expect(result.success).toBe(false);
      expect(result.message).toContain('Missing required parameters');
    });
  });
  
  describe('verifyClaim', () => {
    beforeEach(async () => {
      // Initialize an agent first
      // @ts-ignore - Access private method for testing
      await manager['initializeAgent']({
        id: 'test-agent-1',
        name: 'Test Agent',
        verificationLevel: VerificationLevel.STANDARD,
        trustedSources: ['source1', 'source2'],
        minConfidenceThreshold: 0.7,
        maxResponseTime: 30,
        supportedProtocols: ['protocol1'],
        capabilities: ['capability1']
      });
    });
    
    it('should verify a claim with valid parameters', async () => {
      // @ts-ignore - Access private method for testing
      const result = await manager['verifyClaim']({
        agentId: 'test-agent-1',
        claim: {
          id: 'claim-1',
          text: 'This is a test claim',
          verificationStatus: 'unverified',
          confidenceScore: 0
        }
      });
      
      expect(result.success).toBe(true);
      expect(result.verifiedClaim).toBeDefined();
      expect(result.verifiedClaim.verificationStatus).toBeDefined();
      expect(result.verifiedClaim.confidenceScore).toBeGreaterThan(0);
      expect(result.verifiedClaim.verificationSources).toBeDefined();
    });
    
    it('should fail to verify a claim with invalid agent ID', async () => {
      // @ts-ignore - Access private method for testing
      const result = await manager['verifyClaim']({
        agentId: 'non-existent-agent',
        claim: {
          id: 'claim-1',
          text: 'This is a test claim',
          verificationStatus: 'unverified',
          confidenceScore: 0
        }
      });
      
      expect(result.success).toBe(false);
      expect(result.message).toContain('Agent not found');
    });
    
    it('should fail to verify a claim with missing parameters', async () => {
      // @ts-ignore - Access private method for testing
      const result = await manager['verifyClaim']({
        // Missing claim
        agentId: 'test-agent-1'
      });
      
      expect(result.success).toBe(false);
      expect(result.message).toContain('Missing required parameters');
    });
  });
  
  describe('setVerificationLevel', () => {
    beforeEach(async () => {
      // Initialize an agent first
      // @ts-ignore - Access private method for testing
      await manager['initializeAgent']({
        id: 'test-agent-1',
        name: 'Test Agent',
        verificationLevel: VerificationLevel.STANDARD,
        trustedSources: ['source1', 'source2'],
        minConfidenceThreshold: 0.7,
        maxResponseTime: 30,
        supportedProtocols: ['protocol1'],
        capabilities: ['capability1']
      });
    });
    
    it('should set verification level with valid parameters', async () => {
      // @ts-ignore - Access private method for testing
      const result = await manager['setVerificationLevel']({
        agentId: 'test-agent-1',
        level: VerificationLevel.STRICT
      });
      
      expect(result.success).toBe(true);
      expect(result.message).toContain('Updated verification level');
      
      // @ts-ignore - Access private property for testing
      const agent = manager['registeredAgents'].get('test-agent-1');
      expect(agent?.verificationLevel).toBe(VerificationLevel.STRICT);
    });
    
    it('should fail to set verification level with invalid agent ID', async () => {
      // @ts-ignore - Access private method for testing
      const result = await manager['setVerificationLevel']({
        agentId: 'non-existent-agent',
        level: VerificationLevel.STRICT
      });
      
      expect(result.success).toBe(false);
      expect(result.message).toContain('Agent not found');
    });
    
    it('should fail to set verification level with invalid level', async () => {
      // @ts-ignore - Access private method for testing
      const result = await manager['setVerificationLevel']({
        agentId: 'test-agent-1',
        level: 'invalid-level' as any
      });
      
      expect(result.success).toBe(false);
      expect(result.message).toContain('Invalid verification level');
    });
  });
  
  describe('Event handling', () => {
    let eventListener: jest.Mock;
    let disposable: vscode.Disposable;
    
    beforeEach(async () => {
      // Initialize an agent
      // @ts-ignore - Access private method for testing
      await manager['initializeAgent']({
        id: 'test-agent-1',
        name: 'Test Agent',
        verificationLevel: VerificationLevel.STANDARD
      });
      
      // Set up event listener
      eventListener = jest.fn();
      disposable = manager.addEventListener(VerificationEventType.CLAIM_VERIFIED, eventListener);
    });
    
    afterEach(() => {
      disposable.dispose();
    });
    
    it('should emit events when verifying claims', async () => {
      // @ts-ignore - Access private method for testing
      await manager['verifyClaim']({
        agentId: 'test-agent-1',
        claim: {
          id: 'claim-1',
          text: 'This is a test claim',
          verificationStatus: 'unverified',
          confidenceScore: 0
        }
      });
      
      // @ts-ignore - Access private property for testing
      expect(manager['eventEmitter'].fire).toHaveBeenCalled();
    });
    
    it('should remove event listeners when disposed', () => {
      disposable.dispose();
      
      // @ts-ignore - Access private property for testing
      const listeners = manager['eventListeners'].get(VerificationEventType.CLAIM_VERIFIED) || [];
      expect(listeners).not.toContain(eventListener);
    });
  });
});



==============================================
FILE: ./src/vscode-extension/src/commands/summarization-commands.ts
==============================================

// filepath: /Users/danielgoldberg/Desktop/A1-Inter-LLM-Com/The New Fuse/src/vscode-extension/src/commands/summarization-commands.ts
import * as vscode from 'vscode';
import { LLMProviderService } from '../services/llm-provider.service';
import { 
  SummarizationLevel, 
  SummarizationStyle,
  ContentPriority 
} from '../../../types/agent-protocols';

/**
 * Summarization Service - Handles text summarization using LLMs
 */
export class SummarizationService {
  private static instance: SummarizationService;
  private readonly llmService: LLMProviderService;
  private registeredAgents: Map<string, any> = new Map();
  
  private constructor() {
    this.llmService = LLMProviderService.getInstance();
  }
  
  public static getInstance(): SummarizationService {
    if (!SummarizationService.instance) {
      SummarizationService.instance = new SummarizationService();
    }
    return SummarizationService.instance;
  }
  
  /**
   * Register summarization commands with VS Code
   */
  public registerCommands(context: vscode.ExtensionContext): void {
    const commands = [
      vscode.commands.registerCommand('thefuse.summarization.initialize', this.initializeAgent.bind(this)),
      vscode.commands.registerCommand('thefuse.summarization.summarize', this.summarizeContent.bind(this)),
      vscode.commands.registerCommand('thefuse.summarization.setLevel', this.setSummaryLevel.bind(this)),
      vscode.commands.registerCommand('thefuse.summarization.setStyle', this.setSummaryStyle.bind(this)),
      vscode.commands.registerCommand('thefuse.summarization.setPriorities', this.setContentPriorities.bind(this)),
    ];
    
    commands.forEach(command => context.subscriptions.push(command));
  }
  
  /**
   * Initialize a summarization agent
   */
  private async initializeAgent(params: any): Promise<any> {
    try {
      if (!params.id || !params.name) {
        throw new Error('Missing required parameters: id, name');
      }
      
      // Store agent configuration
      this.registeredAgents.set(params.id, {
        ...params,
        summaries: [],
        lastUpdated: new Date().toISOString()
      });
      
      return {
        success: true,
        message: `Initialized summarization agent: ${params.name}`,
        summaries: [] // Start with empty summaries
      };
    } catch (error) {
      console.error('Error initializing summarization agent:', error);
      return {
        success: false,
        message: `Failed to initialize summarization agent: ${error.message}`
      };
    }
  }
  
  /**
   * Summarize content using LLM
   */
  private async summarizeContent(params: any): Promise<any> {
    try {
      if (!params.agentId || !params.content) {
        throw new Error('Missing required parameters: agentId, content');
      }
      
      const agent = this.registeredAgents.get(params.agentId);
      if (!agent) {
        throw new Error(`Agent not found: ${params.agentId}`);
      }
      
      const summaryLevel = params.summaryLevel || agent.defaultSummaryLevel || SummarizationLevel.CONCISE;
      const summaryStyle = params.summaryStyle || agent.defaultSummaryStyle || SummarizationStyle.FACTUAL;
      const contentPriorities = params.contentPriorities || agent.defaultContentPriorities || [ContentPriority.KEY_FINDINGS];
      
      // Build prompt for summarization
      const prompt = this.buildSummarizationPrompt(
        params.content,
        summaryLevel,
        summaryStyle,
        contentPriorities,
        params.maxLength || agent.maxSummaryLength || 2000,
        params.minCompressionRatio || agent.minCompressionRatio || 0.3,
        params.preserveKeyConcepts !== undefined ? params.preserveKeyConcepts : agent.preserveKeyConcepts !== undefined ? agent.preserveKeyConcepts : true,
        params.maintainKeyTerms || agent.maintainKeyTerms || []
      );
      
      // Use LLM service to generate summary
      const response = await this.llmService.generateCompletion({
        model: 'gpt-4-turbo', // Use appropriate model from configuration
        messages: [
          { role: 'system', content: 'You are an expert summarization assistant that creates concise, accurate summaries while preserving key information.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.3, // Lower temperature for more focused output
        max_tokens: Math.min(params.maxLength || agent.maxSummaryLength || 2000, 4000), // Ensure within token limits
        response_format: { type: 'json_object' } // Request JSON response
      });
      
      // Parse the response
      let result;
      try {
        if (typeof response === 'string') {
          // Extract JSON from the response if needed
          const jsonMatch = response.match(/```json([\s\S]*?)```/) || response.match(/{[\s\S]*}/);
          const jsonStr = jsonMatch ? jsonMatch[0].replace(/```json|```/g, '') : response;
          result = JSON.parse(jsonStr);
        } else {
          result = response;
        }
      } catch (e) {
        console.warn('Failed to parse JSON response, using text response instead:', e);
        result = {
          summary: typeof response === 'string' ? response : 'Failed to generate summary',
          keyInsights: [],
          sentiment: 'neutral'
        };
      }
      
      // Store the summary in agent's history
      const summary = {
        id: crypto.randomUUID(),
        title: params.title || 'Untitled',
        originalText: params.content,
        summarizedText: result.summary,
        summaryLevel,
        summaryStyle,
        contentPriorities,
        createdAt: new Date().toISOString(),
        keyInsights: result.keyInsights || [],
        sentiment: result.sentiment || 'neutral',
        metadata: params.metadata || {}
      };
      
      const agentData = this.registeredAgents.get(params.agentId);
      agentData.summaries.push(summary);
      
      // Limit the number of stored summaries
      if (agentData.summaries.length > (agent.retainedSummaryCount || 10)) {
        agentData.summaries.shift();
      }
      
      this.registeredAgents.set(params.agentId, agentData);
      
      return {
        success: true,
        summary: result.summary,
        keyInsights: result.keyInsights || [],
        sentiment: result.sentiment || 'neutral'
      };
      
    } catch (error) {
      console.error('Error summarizing content:', error);
      return {
        success: false,
        message: `Failed to summarize content: ${error.message}`
      };
    }
  }
  
  /**
   * Set the summary level for an agent
   */
  private async setSummaryLevel(params: any): Promise<any> {
    try {
      if (!params.agentId || !params.level) {
        throw new Error('Missing required parameters: agentId, level');
      }
      
      const agent = this.registeredAgents.get(params.agentId);
      if (!agent) {
        throw new Error(`Agent not found: ${params.agentId}`);
      }
      
      // Validate level
      if (!Object.values(SummarizationLevel).includes(params.level)) {
        throw new Error(`Invalid summarization level: ${params.level}`);
      }
      
      // Update agent configuration
      agent.defaultSummaryLevel = params.level;
      agent.lastUpdated = new Date().toISOString();
      
      this.registeredAgents.set(params.agentId, agent);
      
      return {
        success: true,
        message: `Updated summarization level to: ${params.level}`
      };
    } catch (error) {
      console.error('Error setting summary level:', error);
      return {
        success: false,
        message: `Failed to set summary level: ${error.message}`
      };
    }
  }
  
  /**
   * Set the summary style for an agent
   */
  private async setSummaryStyle(params: any): Promise<any> {
    try {
      if (!params.agentId || !params.style) {
        throw new Error('Missing required parameters: agentId, style');
      }
      
      const agent = this.registeredAgents.get(params.agentId);
      if (!agent) {
        throw new Error(`Agent not found: ${params.agentId}`);
      }
      
      // Validate style
      if (!Object.values(SummarizationStyle).includes(params.style)) {
        throw new Error(`Invalid summarization style: ${params.style}`);
      }
      
      // Update agent configuration
      agent.defaultSummaryStyle = params.style;
      agent.lastUpdated = new Date().toISOString();
      
      this.registeredAgents.set(params.agentId, agent);
      
      return {
        success: true,
        message: `Updated summarization style to: ${params.style}`
      };
    } catch (error) {
      console.error('Error setting summary style:', error);
      return {
        success: false,
        message: `Failed to set summary style: ${error.message}`
      };
    }
  }
  
  /**
   * Set the content priorities for an agent
   */
  private async setContentPriorities(params: any): Promise<any> {
    try {
      if (!params.agentId || !params.priorities || !Array.isArray(params.priorities)) {
        throw new Error('Missing required parameters: agentId, priorities (array)');
      }
      
      const agent = this.registeredAgents.get(params.agentId);
      if (!agent) {
        throw new Error(`Agent not found: ${params.agentId}`);
      }
      
      // Validate priorities
      for (const priority of params.priorities) {
        if (!Object.values(ContentPriority).includes(priority)) {
          throw new Error(`Invalid content priority: ${priority}`);
        }
      }
      
      // Update agent configuration
      agent.defaultContentPriorities = params.priorities;
      agent.lastUpdated = new Date().toISOString();
      
      this.registeredAgents.set(params.agentId, agent);
      
      return {
        success: true,
        message: `Updated content priorities: ${params.priorities.join(', ')}`
      };
    } catch (error) {
      console.error('Error setting content priorities:', error);
      return {
        success: false,
        message: `Failed to set content priorities: ${error.message}`
      };
    }
  }
  
  /**
   * Build a prompt for the summarization LLM
   */
  private buildSummarizationPrompt(
    content: string,
    summaryLevel: SummarizationLevel,
    summaryStyle: SummarizationStyle,
    contentPriorities: ContentPriority[],
    maxLength: number,
    minCompressionRatio: number,
    preserveKeyConcepts: boolean,
    maintainKeyTerms: string[]
  ): string {
    // Determine target length based on summarization level and original content
    const originalLength = content.length;
    let targetCompressionRatio;
    
    switch (summaryLevel) {
      case SummarizationLevel.BRIEF:
        targetCompressionRatio = 0.1; // 90% reduction
        break;
      case SummarizationLevel.CONCISE:
        targetCompressionRatio = 0.25; // 75% reduction
        break;
      case SummarizationLevel.DETAILED:
        targetCompressionRatio = 0.4; // 60% reduction
        break;
      case SummarizationLevel.COMPREHENSIVE:
        targetCompressionRatio = 0.6; // 40% reduction
        break;
      default:
        targetCompressionRatio = 0.3; // Default 70% reduction
    }
    
    // Apply minimum compression ratio
    targetCompressionRatio = Math.max(minCompressionRatio, targetCompressionRatio);
    
    // Calculate target character count
    const targetLength = Math.min(originalLength * targetCompressionRatio, maxLength);
    
    // Format content priorities for prompt
    const prioritiesText = contentPriorities
      .map(p => `- ${p.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}`)
      .join('\n');
    
    // Format key terms to maintain
    const keyTermsText = maintainKeyTerms && maintainKeyTerms.length > 0
      ? `\nKey terms to preserve in the summary:\n${maintainKeyTerms.map(term => `- ${term}`).join('\n')}`
      : '';
    
    // Build the prompt
    return `
I need you to summarize the following text:

${content}

Please create a ${summaryLevel} summary in a ${summaryStyle} style. The summary should be approximately ${Math.round(targetLength)} characters (about ${Math.round(targetLength / 5)} words).

Focus on these content priorities:
${prioritiesText}
${keyTermsText}
${preserveKeyConcepts ? '\nEnsure that key concepts, important terms, and critical information are preserved in the summary.' : ''}

Please format your response as a JSON object with the following structure:
{
  "summary": "Your summary text here",
  "keyInsights": ["Key insight 1", "Key insight 2", "Key insight 3"],
  "sentiment": "positive|neutral|negative"
}

The summary should be self-contained and understandable without referring to the original text.
`;
  }
}

// Export singleton instance creation function
export function createSummarizationService(): SummarizationService {
  return SummarizationService.getInstance();
}


==============================================
FILE: ./src/vscode-extension/src/commands/verification-commands.ts
==============================================

/**
 * Verification Commands
 *
 * This module provides commands for the AI Verification Agent to verify claims
 * and manage verification settings.
 */

import * as vscode from 'vscode';
import { log, logError } from '../utils/logging';
import * as crypto from 'crypto';
import * as path from 'path';
import * as fs from 'fs';

/**
 * Verification level enum
 */
export enum VerificationLevel {
  STRICT = 'strict',       // Requires multiple credible sources
  STANDARD = 'standard',   // Requires at least one credible source
  PERMISSIVE = 'permissive' // Accept with minimal verification
}

/**
 * Source type enum
 */
export enum SourceType {
  ACADEMIC = 'academic',
  NEWS = 'news',
  OFFICIAL = 'official',
  EXPERT = 'expert',
  CROWD = 'crowd',
  UNKNOWN = 'unknown'
}

/**
 * Verification source interface
 */
export interface VerificationSource {
  name: string;
  url: string;
  type: SourceType;
  reliability: number; // 0.0-1.0
  excerpt?: string;
  creationDate?: string; // ISO date string
  retrievedAt: string; // ISO date string
}

/**
 * Claim interface
 */
export interface Claim {
  id: string;
  text: string;
  source?: string;
  metadata?: any;
  verificationStatus: 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
  confidenceScore: number; // 0.0-1.0
  verificationSources?: VerificationSource[];
  verifiedAt?: string; // ISO date string
  tags?: string[];
}

/**
 * Verification agent data
 */
export interface VerificationAgentData {
  id: string;
  name: string;
  verificationLevel: VerificationLevel;
  claims: Claim[];
  pendingClaims: Claim[];
  status: 'idle' | 'busy' | 'error';
  lastUpdated: string | null;
  supportedProtocols: string[];
  capabilities: string[];
  trustedSources: string[];
  minConfidenceThreshold: number; // 0.0-1.0
  maxResponseTime: number; // seconds
}

/**
 * LLM Service interface for verification
 */
interface LLMService {
  generateCompletion(params: {
    model: string;
    messages: Array<{role: string, content: string}>;
    temperature?: number;
    max_tokens?: number;
    response_format?: {type: string};
  }): Promise<any>;
}

/**
 * Cache entry for verification results
 */
interface VerificationCacheEntry {
  claim: string;
  result: {
    status: 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
    confidenceScore: number;
    sources: VerificationSource[];
  };
  timestamp: number;
  expiresAt: number;
}

/**
 * Verification event types
 */
export enum VerificationEventType {
  AGENT_INITIALIZED = 'agent_initialized',
  CLAIM_VERIFIED = 'claim_verified',
  VERIFICATION_LEVEL_CHANGED = 'verification_level_changed',
  VERIFICATION_ERROR = 'verification_error'
}

/**
 * Verification event
 */
export interface VerificationEvent {
  type: VerificationEventType;
  agentId: string;
  timestamp: string;
  data: any;
}

/**
 * Verification event listener
 */
export type VerificationEventListener = (event: VerificationEvent) => void;

/**
 * Verification commands manager
 */
export class VerificationCommandsManager {
  private context: vscode.ExtensionContext;
  private registeredAgents: Map<string, VerificationAgentData> = new Map();
  private outputChannel: vscode.OutputChannel;
  private llmService: LLMService | null = null;
  private verificationCache: Map<string, VerificationCacheEntry> = new Map();
  private cacheDir: string;
  private readonly CACHE_EXPIRATION = 24 * 60 * 60 * 1000; // 24 hours
  private eventListeners: Map<VerificationEventType, VerificationEventListener[]> = new Map();
  private eventEmitter = new vscode.EventEmitter<VerificationEvent>();
  public readonly onVerificationEvent = this.eventEmitter.event;

  /**
   * Constructor
   * @param context VS Code extension context
   * @param llmService Optional LLM service for verification
   */
  constructor(context: vscode.ExtensionContext, llmService?: LLMService) {
    this.context = context;
    this.outputChannel = vscode.window.createOutputChannel('AI Verification');
    this.llmService = llmService || null;

    // Set up cache directory
    this.cacheDir = path.join(context.globalStorageUri.fsPath, 'verification-cache');
    this.ensureCacheDirectory();
    this.loadCache();

    // Register commands
    this.registerCommands();
  }

  /**
   * Ensure cache directory exists
   */
  private ensureCacheDirectory(): void {
    try {
      if (!fs.existsSync(this.cacheDir)) {
        fs.mkdirSync(this.cacheDir, { recursive: true });
        this.log(`Created cache directory: ${this.cacheDir}`);
      }
    } catch (error) {
      this.logError('Error creating cache directory:', error);
    }
  }

  /**
   * Load cache from disk
   */
  private loadCache(): void {
    try {
      const cacheFile = path.join(this.cacheDir, 'verification-cache.json');

      if (fs.existsSync(cacheFile)) {
        const cacheData = JSON.parse(fs.readFileSync(cacheFile, 'utf8'));

        // Convert to Map and filter expired entries
        const now = Date.now();
        Object.entries(cacheData).forEach(([key, entry]: [string, any]) => {
          if (entry.expiresAt > now) {
            this.verificationCache.set(key, entry as VerificationCacheEntry);
          }
        });

        this.log(`Loaded ${this.verificationCache.size} cache entries`);
      }
    } catch (error) {
      this.logError('Error loading cache:', error);
      // Reset cache if loading fails
      this.verificationCache.clear();
    }
  }

  /**
   * Save cache to disk
   */
  private saveCache(): void {
    try {
      const cacheFile = path.join(this.cacheDir, 'verification-cache.json');

      // Convert Map to object for JSON serialization
      const cacheData = Object.fromEntries(this.verificationCache.entries());

      fs.writeFileSync(cacheFile, JSON.stringify(cacheData, null, 2), 'utf8');
      this.log(`Saved ${this.verificationCache.size} cache entries`);
    } catch (error) {
      this.logError('Error saving cache:', error);
    }
  }

  /**
   * Register verification commands with VS Code
   */
  private registerCommands(): void {
    const commands = [
      vscode.commands.registerCommand('thefuse.verification.initialize', this.initializeAgent.bind(this)),
      vscode.commands.registerCommand('thefuse.verification.verifyClaim', this.verifyClaim.bind(this)),
      vscode.commands.registerCommand('thefuse.verification.setLevel', this.setVerificationLevel.bind(this)),
    ];

    commands.forEach(command => this.context.subscriptions.push(command));

    this.log('Verification commands registered');
  }

  /**
   * Initialize a verification agent
   */
  private async initializeAgent(params: any): Promise<any> {
    try {
      this.log(`Initializing verification agent: ${JSON.stringify(params)}`);

      if (!params.id || !params.name) {
        throw new Error('Missing required parameters: id, name');
      }

      // Store agent configuration
      this.registeredAgents.set(params.id, {
        ...params,
        claims: [],
        pendingClaims: [],
        status: 'idle',
        lastUpdated: new Date().toISOString()
      });

      this.log(`Verification agent initialized: ${params.name} (${params.id})`);

      // Emit initialization event
      this.emitEvent(VerificationEventType.AGENT_INITIALIZED, params.id, {
        name: params.name,
        verificationLevel: params.verificationLevel || VerificationLevel.STANDARD
      });

      return {
        success: true,
        message: `Initialized verification agent: ${params.name}`,
        claims: [] // Start with empty claims
      };
    } catch (error) {
      this.logError('Error initializing verification agent:', error);

      // Emit error event
      this.emitEvent(VerificationEventType.VERIFICATION_ERROR, params.id || 'unknown', {
        operation: 'initialize',
        error: error instanceof Error ? error.message : String(error)
      });

      return {
        success: false,
        message: `Failed to initialize verification agent: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Verify a claim
   */
  private async verifyClaim(params: any): Promise<any> {
    try {
      this.log(`Verifying claim: ${JSON.stringify(params)}`);

      if (!params.agentId || !params.claim) {
        throw new Error('Missing required parameters: agentId, claim');
      }

      const agent = this.registeredAgents.get(params.agentId);
      if (!agent) {
        throw new Error(`Agent not found: ${params.agentId}`);
      }

      // Get the claim to verify
      const claim = params.claim;

      // Generate a cache key based on the claim text and verification level
      const cacheKey = this.generateCacheKey(claim.text, agent.verificationLevel);

      // Check if we have a cached result
      const cachedResult = this.verificationCache.get(cacheKey);
      if (cachedResult && cachedResult.expiresAt > Date.now()) {
        this.log(`Using cached verification result for claim: ${claim.id}`);

        // Update the claim with cached verification results
        const verifiedClaim: Claim = {
          ...claim,
          verificationStatus: cachedResult.result.status,
          confidenceScore: cachedResult.result.confidenceScore,
          verificationSources: cachedResult.result.sources,
          verifiedAt: new Date().toISOString()
        };

        return {
          success: true,
          verifiedClaim,
          fromCache: true
        };
      }

      // No cache hit, perform verification
      let verificationResult;

      // If LLM service is available, use it for verification
      if (this.llmService) {
        verificationResult = await this.verifyClaimWithLLM(claim, agent);
      } else {
        // Fall back to simulated verification
        this.log('No LLM service available, using simulated verification');

        // Simulate verification delay
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Generate verification result
        verificationResult = this.simulateVerification(claim, agent.verificationLevel);
      }

      // Cache the verification result
      this.cacheVerificationResult(cacheKey, claim.text, verificationResult);

      // Update the claim with verification results
      const verifiedClaim: Claim = {
        ...claim,
        verificationStatus: verificationResult.status,
        confidenceScore: verificationResult.confidenceScore,
        verificationSources: verificationResult.sources,
        verifiedAt: new Date().toISOString()
      };

      this.log(`Claim verified: ${verifiedClaim.id} (${verifiedClaim.verificationStatus})`);

      // Emit claim verified event
      this.emitEvent(VerificationEventType.CLAIM_VERIFIED, params.agentId, {
        claim: verifiedClaim,
        fromCache: false
      });

      return {
        success: true,
        verifiedClaim
      };
    } catch (error) {
      this.logError('Error verifying claim:', error);

      // Emit error event
      this.emitEvent(VerificationEventType.VERIFICATION_ERROR, params.agentId || 'unknown', {
        operation: 'verifyClaim',
        claimId: params.claim?.id,
        error: error instanceof Error ? error.message : String(error)
      });

      return {
        success: false,
        message: `Failed to verify claim: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Generate a cache key for a claim
   */
  private generateCacheKey(claimText: string, verificationLevel: VerificationLevel): string {
    // Create a hash of the claim text and verification level
    return crypto
      .createHash('md5')
      .update(`${claimText}:${verificationLevel}`)
      .digest('hex');
  }

  /**
   * Cache a verification result
   */
  private cacheVerificationResult(
    cacheKey: string,
    claimText: string,
    result: {
      status: 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
      confidenceScore: number;
      sources: VerificationSource[];
    }
  ): void {
    // Create cache entry
    const cacheEntry: VerificationCacheEntry = {
      claim: claimText,
      result,
      timestamp: Date.now(),
      expiresAt: Date.now() + this.CACHE_EXPIRATION
    };

    // Add to cache
    this.verificationCache.set(cacheKey, cacheEntry);

    // Save cache to disk
    this.saveCache();

    this.log(`Cached verification result for key: ${cacheKey}`);
  }

  /**
   * Verify a claim using LLM
   */
  private async verifyClaimWithLLM(claim: Claim, agent: VerificationAgentData): Promise<{
    status: 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
    confidenceScore: number;
    sources: VerificationSource[];
  }> {
    this.log(`Verifying claim with LLM: ${claim.text}`);

    try {
      // Prepare the prompt for the LLM
      const prompt = this.buildVerificationPrompt(claim, agent);

      // Call the LLM service
      const response = await this.llmService!.generateCompletion({
        model: 'gpt-4-turbo', // Use appropriate model
        messages: [
          {
            role: 'system',
            content: 'You are an expert fact-checking assistant. Your task is to verify claims by searching for reliable sources and providing a verification status with confidence score.'
          },
          { role: 'user', content: prompt }
        ],
        temperature: 0.2, // Lower temperature for more factual responses
        max_tokens: 2000,
        response_format: { type: 'json_object' }
      });

      // Parse the response
      let result;
      try {
        if (typeof response === 'string') {
          // Extract JSON from the response if needed
          const jsonMatch = response.match(/```json([\s\S]*?)```/) || response.match(/{[\s\S]*}/);
          const jsonStr = jsonMatch ? jsonMatch[0].replace(/```json|```/g, '') : response;
          result = JSON.parse(jsonStr);
        } else {
          result = response;
        }
      } catch (e) {
        this.logError('Failed to parse LLM response:', e);
        throw new Error('Failed to parse verification result');
      }

      // Validate and transform the result
      if (!result.status || !result.confidenceScore || !result.sources) {
        throw new Error('Invalid verification result format');
      }

      // Ensure status is one of the valid values
      const status = result.status as 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
      if (!['verified', 'refuted', 'unverified', 'insufficient_data'].includes(status)) {
        throw new Error(`Invalid verification status: ${result.status}`);
      }

      // Ensure confidence score is a number between 0 and 1
      const confidenceScore = parseFloat(result.confidenceScore);
      if (isNaN(confidenceScore) || confidenceScore < 0 || confidenceScore > 1) {
        throw new Error(`Invalid confidence score: ${result.confidenceScore}`);
      }

      // Transform sources to match our format
      const sources: VerificationSource[] = result.sources.map((source: any) => ({
        name: source.name || 'Unknown Source',
        url: source.url || '',
        type: this.mapSourceType(source.type),
        reliability: parseFloat(source.reliability) || 0.5,
        excerpt: source.excerpt || '',
        creationDate: source.creationDate || new Date().toISOString(),
        retrievedAt: new Date().toISOString()
      }));

      return {
        status,
        confidenceScore,
        sources
      };
    } catch (error) {
      this.logError('Error in LLM verification:', error);

      // Fall back to simulated verification
      this.log('Falling back to simulated verification');
      return this.simulateVerification(claim, agent.verificationLevel);
    }
  }

  /**
   * Build a prompt for LLM verification
   */
  private buildVerificationPrompt(claim: Claim, agent: VerificationAgentData): string {
    const verificationLevel = agent.verificationLevel;
    const trustedSources = agent.trustedSources.join(', ');

    return `
# Claim Verification Request

## Claim to Verify
"${claim.text}"

${claim.source ? `## Claimed Source\n${claim.source}` : ''}

## Verification Parameters
- Verification Level: ${verificationLevel}
- Minimum Confidence Threshold: ${agent.minConfidenceThreshold}
- Trusted Sources: ${trustedSources}

## Instructions
1. Analyze the claim carefully
2. Search for reliable sources to verify or refute the claim
3. Consider the verification level:
   - STRICT: Requires multiple credible sources
   - STANDARD: Requires at least one credible source
   - PERMISSIVE: Accept with minimal verification
4. Provide a verification status: "verified", "refuted", "unverified", or "insufficient_data"
5. Assign a confidence score between 0.0 and 1.0
6. List the sources you used, including their reliability

## Response Format
Provide your response in the following JSON format:
\`\`\`json
{
  "status": "verified|refuted|unverified|insufficient_data",
  "confidenceScore": 0.0-1.0,
  "explanation": "Detailed explanation of your verification process and conclusion",
  "sources": [
    {
      "name": "Source Name",
      "url": "Source URL",
      "type": "academic|news|official|expert|crowd|unknown",
      "reliability": 0.0-1.0,
      "excerpt": "Relevant excerpt from the source"
    }
  ]
}
\`\`\`
`;
  }

  /**
   * Map source type string to SourceType enum
   */
  private mapSourceType(typeStr: string): SourceType {
    const typeMap: Record<string, SourceType> = {
      'academic': SourceType.ACADEMIC,
      'news': SourceType.NEWS,
      'official': SourceType.OFFICIAL,
      'expert': SourceType.EXPERT,
      'crowd': SourceType.CROWD
    };

    return typeMap[typeStr.toLowerCase()] || SourceType.UNKNOWN;
  }

  /**
   * Set verification level
   */
  private async setVerificationLevel(params: any): Promise<any> {
    try {
      this.log(`Setting verification level: ${JSON.stringify(params)}`);

      if (!params.agentId || !params.level) {
        throw new Error('Missing required parameters: agentId, level');
      }

      const agent = this.registeredAgents.get(params.agentId);
      if (!agent) {
        throw new Error(`Agent not found: ${params.agentId}`);
      }

      // Validate level
      if (!Object.values(VerificationLevel).includes(params.level)) {
        throw new Error(`Invalid verification level: ${params.level}`);
      }

      // Update agent configuration
      const oldLevel = agent.verificationLevel;
      agent.verificationLevel = params.level;
      agent.lastUpdated = new Date().toISOString();

      this.registeredAgents.set(params.agentId, agent);

      this.log(`Verification level updated: ${params.level}`);

      // Emit verification level changed event
      this.emitEvent(VerificationEventType.VERIFICATION_LEVEL_CHANGED, params.agentId, {
        oldLevel,
        newLevel: params.level
      });

      return {
        success: true,
        message: `Updated verification level to: ${params.level}`
      };
    } catch (error) {
      this.logError('Error setting verification level:', error);

      // Emit error event
      this.emitEvent(VerificationEventType.VERIFICATION_ERROR, params.agentId || 'unknown', {
        operation: 'setVerificationLevel',
        level: params.level,
        error: error instanceof Error ? error.message : String(error)
      });

      return {
        success: false,
        message: `Failed to set verification level: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Simulate verification of a claim
   * In a real implementation, this would use LLM or other services to verify the claim
   */
  private simulateVerification(claim: Claim, level: VerificationLevel): {
    status: 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
    confidenceScore: number;
    sources: VerificationSource[];
  } {
    // Generate random verification result
    const random = Math.random();

    // Adjust verification threshold based on level
    let verificationThreshold = 0.5; // Default for STANDARD
    if (level === VerificationLevel.STRICT) {
      verificationThreshold = 0.7;
    } else if (level === VerificationLevel.PERMISSIVE) {
      verificationThreshold = 0.3;
    }

    // Determine verification status
    let status: 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
    let confidenceScore: number;

    if (random < 0.1) {
      // 10% chance of insufficient data
      status = 'insufficient_data';
      confidenceScore = 0.1 + Math.random() * 0.2; // 0.1-0.3
    } else if (random < 0.3) {
      // 20% chance of refuted
      status = 'refuted';
      confidenceScore = 0.6 + Math.random() * 0.4; // 0.6-1.0
    } else if (random < verificationThreshold) {
      // Chance based on verification level of unverified
      status = 'unverified';
      confidenceScore = 0.3 + Math.random() * 0.3; // 0.3-0.6
    } else {
      // Remaining chance of verified
      status = 'verified';
      confidenceScore = 0.7 + Math.random() * 0.3; // 0.7-1.0
    }

    // Generate random sources
    const sourceCount = status === 'verified' ? 2 + Math.floor(Math.random() * 3) : // 2-4 sources for verified
                        status === 'refuted' ? 1 + Math.floor(Math.random() * 2) : // 1-2 sources for refuted
                        status === 'unverified' ? Math.floor(Math.random() * 2) : // 0-1 sources for unverified
                        0; // No sources for insufficient data

    const sources: VerificationSource[] = [];
    for (let i = 0; i < sourceCount; i++) {
      sources.push(this.generateRandomSource(status));
    }

    return {
      status,
      confidenceScore,
      sources
    };
  }

  /**
   * Generate a random verification source
   */
  private generateRandomSource(status: 'verified' | 'refuted' | 'unverified' | 'insufficient_data'): VerificationSource {
    const sourceTypes = Object.values(SourceType);
    const randomType = sourceTypes[Math.floor(Math.random() * sourceTypes.length)];

    // Higher reliability for verified claims
    const baseReliability = status === 'verified' ? 0.7 :
                           status === 'refuted' ? 0.6 :
                           0.4;
    const reliability = baseReliability + Math.random() * 0.3;

    // Generate a random domain based on the source type
    let domain = '';
    switch (randomType) {
      case SourceType.ACADEMIC:
        domain = ['scholar.google.com', 'arxiv.org', 'nature.com', 'science.org', 'nih.gov'][Math.floor(Math.random() * 5)];
        break;
      case SourceType.NEWS:
        domain = ['reuters.com', 'apnews.com', 'bbc.com', 'nytimes.com', 'wsj.com'][Math.floor(Math.random() * 5)];
        break;
      case SourceType.OFFICIAL:
        domain = ['who.int', 'un.org', 'europa.eu', 'whitehouse.gov', 'nasa.gov'][Math.floor(Math.random() * 5)];
        break;
      case SourceType.EXPERT:
        domain = ['medium.com', 'substack.com', 'linkedin.com', 'github.com', 'stackoverflow.com'][Math.floor(Math.random() * 5)];
        break;
      case SourceType.CROWD:
        domain = ['reddit.com', 'twitter.com', 'quora.com', 'facebook.com', 'wikipedia.org'][Math.floor(Math.random() * 5)];
        break;
      default:
        domain = ['example.com', 'unknown-source.org'][Math.floor(Math.random() * 2)];
    }

    return {
      name: `${randomType.charAt(0).toUpperCase() + randomType.slice(1)} Source ${Math.floor(Math.random() * 1000)}`,
      url: `https://${domain}/article-${Math.floor(Math.random() * 10000)}`,
      type: randomType,
      reliability,
      excerpt: `This is a simulated excerpt from the source that ${status === 'verified' ? 'supports' : status === 'refuted' ? 'contradicts' : 'partially addresses'} the claim.`,
      creationDate: new Date(Date.now() - Math.floor(Math.random() * 30 * 24 * 60 * 60 * 1000)).toISOString(), // Random date in the last 30 days
      retrievedAt: new Date().toISOString()
    };
  }

  /**
   * Log a message to the output channel
   */
  private log(message: string): void {
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ${message}`);
    log(message);
  }

  /**
   * Log an error to the output channel
   */
  private logError(message: string, error: any): void {
    const errorMessage = error instanceof Error ? error.message : String(error);
    this.outputChannel.appendLine(`[${new Date().toISOString()}] ERROR: ${message} ${errorMessage}`);
    logError(message, error);
  }

  /**
   * Add an event listener
   */
  public addEventListener(type: VerificationEventType, listener: VerificationEventListener): vscode.Disposable {
    if (!this.eventListeners.has(type)) {
      this.eventListeners.set(type, []);
    }

    this.eventListeners.get(type)!.push(listener);

    // Return a disposable to remove the listener
    return new vscode.Disposable(() => {
      this.removeEventListener(type, listener);
    });
  }

  /**
   * Remove an event listener
   */
  public removeEventListener(type: VerificationEventType, listener: VerificationEventListener): void {
    if (!this.eventListeners.has(type)) {
      return;
    }

    const listeners = this.eventListeners.get(type)!;
    const index = listeners.indexOf(listener);

    if (index !== -1) {
      listeners.splice(index, 1);
    }
  }

  /**
   * Emit an event
   */
  private emitEvent(type: VerificationEventType, agentId: string, data: any): void {
    const event: VerificationEvent = {
      type,
      agentId,
      timestamp: new Date().toISOString(),
      data
    };

    // Emit the event
    this.eventEmitter.fire(event);

    // Notify listeners
    if (this.eventListeners.has(type)) {
      this.eventListeners.get(type)!.forEach(listener => {
        try {
          listener(event);
        } catch (error) {
          this.logError('Error in event listener:', error);
        }
      });
    }

    this.log(`Emitted event: ${type} for agent: ${agentId}`);
  }
}

/**
 * Create and register verification commands
 * @param context VS Code extension context
 * @param llmService Optional LLM service for verification
 * @returns VerificationCommandsManager instance
 */
export function registerVerificationCommands(
  context: vscode.ExtensionContext,
  llmService?: LLMService
): VerificationCommandsManager {
  return new VerificationCommandsManager(context, llmService);
}



==============================================
FILE: ./src/vscode-extension/src/communication-panel.tsx
==============================================

import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export class CommunicationPanel {
  public static currentPanel: CommunicationPanel | undefined;
  private static readonly viewType = 'aiCommunicationPanel';
  
  private readonly _panel: vscode.WebviewPanel;
  private readonly _extensionUri: vscode.Uri;
  private _disposables: vscode.Disposable[] = [];
  
  public static createOrShow(extensionUri: vscode.Uri) {
    const column = vscode.window.activeTextEditor
      ? vscode.window.activeTextEditor.viewColumn
      : undefined;
    
    // If we already have a panel, show it
    if (CommunicationPanel.currentPanel) {
      CommunicationPanel.currentPanel._panel.reveal(column);
      return;
    }
    
    // Otherwise, create a new panel
    const panel = vscode.window.createWebviewPanel(
      CommunicationPanel.viewType,
      'AI Communication Hub',
      column || vscode.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          vscode.Uri.joinPath(extensionUri, 'web-ui')
        ]
      }
    );
    
    CommunicationPanel.currentPanel = new CommunicationPanel(panel, extensionUri);
  }
  
  private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {
    this._panel = panel;
    this._extensionUri = extensionUri;
    
    // Set the webview's initial html content
    this._update();
    
    // Listen for when the panel is disposed
    // This happens when the user closes the panel or when the panel is closed programmatically
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
    
    // Handle messages from the webview
    this._panel.webview.onDidReceiveMessage(
      async (message) => {
        switch (message.command) {
          case 'discoverAgents':
            await vscode.commands.executeCommand('llm-orchestrator.discoverAgents');
            this._sendAgentsToWebview();
            break;
            
          case 'startCollaboration':
            vscode.commands.executeCommand('thefuse.startAICollab');
            break;
            
          case 'sendMessage':
            await vscode.commands.executeCommand('thefuse.sendFileMessage', message.recipient, message.action, message.payload);
            break;
            
          case 'analyzeCode':
            vscode.commands.executeCommand('thefuse.analyzeCodeProblem');
            break;
            
          case 'startCoding':
            vscode.commands.executeCommand('thefuse.startCollaborativeCoding');
            break;
            
          case 'toggleCompletion':
            vscode.commands.executeCommand('thefuse.toggleCollaborativeCompletion');
            break;
            
          case 'registerMcpHandler':
            vscode.commands.executeCommand('thefuse.mcp.registerHandler', message.namespace, message.handler);
            break;
        }
      },
      null,
      this._disposables
    );
  }
  
  private async _sendAgentsToWebview() {
    const agents = await vscode.commands.executeCommand('llm-orchestrator.getRegisteredAgents');
    this._panel.webview.postMessage({ 
      command: 'updateAgents', 
      agents 
    });
  }
  
  private _update() {
    const webview = this._panel.webview;
    this._panel.title = "AI Communication Hub";
    this._panel.webview.html = this._getHtmlForWebview(webview);
    
    // Send initial data
    this._sendAgentsToWebview();
  }
  
  private _getHtmlForWebview(webview: vscode.Webview) {
    // Local path to script and css for the webview
    const scriptUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'web-ui', 'communication-panel.js')
    );
    
    const styleUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, 'web-ui', 'communication-panel.css')
    );
    
    const nonce = getNonce();
    
    // Use a placeholder to load the actual HTML content if it exists, or use this default if not
    try {
      const htmlPath = path.join(this._extensionUri.fsPath, 'web-ui', 'communication-panel.html');
      if (fs.existsSync(htmlPath)) {
        let html = fs.readFileSync(htmlPath, 'utf8');
        // Replace placeholders in the HTML
        return html
          .replace(/\$\{webview\.cspSource\}/g, webview.cspSource)
          .replace(/\$\{styleUri\}/g, styleUri.toString())
          .replace(/\$\{scriptUri\}/g, scriptUri.toString())
          .replace(/\$\{nonce\}/g, nonce);
      }
    } catch (error) {
      console.error("Failed to load HTML template:", error);
    }
    
    // Default HTML if template not found
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}';">
    <title>AI Communication Hub</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            padding: 20px;
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .header {
            padding-bottom: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--vscode-panel-border);
        }
        
        .card {
            background-color: var(--vscode-editor-inactiveSelectionBackground);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid var(--vscode-panel-border);
        }
        
        .card h2 {
            margin-top: 0;
            color: var(--vscode-editor-foreground);
        }
        
        .action-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .action-button {
            padding: 10px;
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: background-color 0.2s;
        }
        
        .action-button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }
        
        .action-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 16px;
        }
        
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            border-bottom-color: var(--vscode-button-background);
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .agents-list {
            margin-top: 16px;
        }
        
        .agent-item {
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            background-color: var(--vscode-editor-inactiveSelectionBackground);
        }
        
        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .agent-name {
            font-weight: bold;
        }
        
        .agent-capabilities {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .capability-tag {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            background-color: var(--vscode-badge-background);
            color: var(--vscode-badge-foreground);
        }
        
        .form-row {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            margin-bottom: 4px;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 8px;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            border-radius: 4px;
        }
        
        .submit-button {
            padding: 8px 16px;
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .communication-log {
            margin-top: 16px;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            padding: 8px;
            background-color: var(--vscode-editor-background);
        }
        
        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid var(--vscode-panel-border);
        }
        
        .log-timestamp {
            font-size: 12px;
            color: var(--vscode-descriptionForeground);
        }
        
        .log-message {
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>AI Communication Hub</h1>
            <p>Coordinate AI extensions and manage inter-agent communication</p>
        </div>
        
        <div class="action-grid">
            <button class="action-button" id="btn-discover">
                <div class="action-icon">🔍</div>
                <span>Discover AI Agents</span>
            </button>
            <button class="action-button" id="btn-collaboration">
                <div class="action-icon">🤝</div>
                <span>Start AI Collaboration</span>
            </button>
            <button class="action-button" id="btn-coding">
                <div class="action-icon">💻</div>
                <span>Collaborative Coding</span>
            </button>
            <button class="action-button" id="btn-analyze">
                <div class="action-icon">🔬</div>
                <span>Analyze Code</span>
            </button>
            <button class="action-button" id="btn-completion">
                <div class="action-icon">✨</div>
                <span>Toggle Completions</span>
            </button>
            <button class="action-button" id="btn-mcp">
                <div class="action-icon">📡</div>
                <span>MCP Settings</span>
            </button>
        </div>
        
        <div class="tabs">
            <div class="tab active" data-tab="tab-agents">AI Agents</div>
            <div class="tab" data-tab="tab-send">Send Message</div>
            <div class="tab" data-tab="tab-mcp">MCP Protocol</div>
            <div class="tab" data-tab="tab-log">Communication Log</div>
        </div>
        
        <div class="tab-content active" id="tab-agents">
            <button id="refresh-agents">Refresh Agents List</button>
            <div class="agents-list" id="agents-container">
                <p>No agents discovered yet. Click "Discover AI Agents" to find available AI extensions.</p>
            </div>
        </div>
        
        <div class="tab-content" id="tab-send">
            <div class="card">
                <h2>Send Direct Message</h2>
                <div class="form-row">
                    <label for="recipient">Recipient:</label>
                    <select id="recipient"></select>
                </div>
                <div class="form-row">
                    <label for="action">Action:</label>
                    <input type="text" id="action" placeholder="e.g., generateCode, explainCode">
                </div>
                <div class="form-row">
                    <label for="payload">Payload (JSON):</label>
                    <textarea id="payload" rows="6" placeholder='{"prompt": "Write a function to calculate Fibonacci numbers"}'></textarea>
                </div>
                <button class="submit-button" id="send-message">Send Message</button>
            </div>
        </div>
        
        <div class="tab-content" id="tab-mcp">
            <div class="card">
                <h2>Message Control Protocol (MCP)</h2>
                <p>Register handlers for MCP messages to enable autonomous agent communication.</p>
                <div class="form-row">
                    <label for="mcp-namespace">Namespace:</label>
                    <input type="text" id="mcp-namespace" placeholder="e.g., com.example.ai">
                </div>
                <div class="form-row">
                    <label for="mcp-command">Command:</label>
                    <input type="text" id="mcp-command" placeholder="e.g., generateResponse">
                </div>
                <div class="form-row">
                    <label for="mcp-handler">Handler Function:</label>
                    <textarea id="mcp-handler" rows="6" placeholder="function(message) { return { success: true, response: 'Hello' }; }"></textarea>
                </div>
                <button class="submit-button" id="register-mcp">Register MCP Handler</button>
            </div>
        </div>
        
        <div class="tab-content" id="tab-log">
            <div class="card">
                <h2>Communication Log</h2>
                <div class="communication-log" id="comms-log">
                    <!-- Log entries will be added here -->
                </div>
            </div>
        </div>
    </div>
    
    <script nonce="${nonce}">
        const vscode = acquireVsCodeApi();
        
        // Initialize the UI
        document.addEventListener('DOMContentLoaded', () => {
            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                });
            });
            
            // Button actions
            document.getElementById('btn-discover').addEventListener('click', () => {
                vscode.postMessage({ command: 'discoverAgents' });
                logMessage('Discovering AI agents...');
            });
            
            document.getElementById('btn-collaboration').addEventListener('click', () => {
                vscode.postMessage({ command: 'startCollaboration' });
                logMessage('Starting AI collaboration...');
            });
            
            document.getElementById('btn-coding').addEventListener('click', () => {
                vscode.postMessage({ command: 'startCoding' });
                logMessage('Starting collaborative coding...');
            });
            
            document.getElementById('btn-analyze').addEventListener('click', () => {
                vscode.postMessage({ command: 'analyzeCode' });
                logMessage('Starting code analysis...');
            });
            
            document.getElementById('btn-completion').addEventListener('click', () => {
                vscode.postMessage({ command: 'toggleCompletion' });
                logMessage('Toggling collaborative completion...');
            });
            
            document.getElementById('refresh-agents').addEventListener('click', () => {
                vscode.postMessage({ command: 'discoverAgents' });
            });
            
            document.getElementById('send-message').addEventListener('click', () => {
                const recipient = document.getElementById('recipient').value;
                const action = document.getElementById('action').value;
                const payload = document.getElementById('payload').value;
                
                if (!recipient || !action || !payload) {
                    logMessage('Error: All fields are required', 'error');
                    return;
                }
                
                try {
                    const parsedPayload = JSON.parse(payload);
                    vscode.postMessage({
                        command: 'sendMessage',
                        recipient,
                        action,
                        payload: parsedPayload
                    });
                    logMessage('Sent message to ' + recipient + ': ' + action);
                } catch (e) {
                    logMessage('Error: Invalid JSON payload', 'error');
                }
            });
            
            document.getElementById('register-mcp').addEventListener('click', () => {
                const namespace = document.getElementById('mcp-namespace').value;
                const command = document.getElementById('mcp-command').value;
                const handler = document.getElementById('mcp-handler').value;
                
                if (!namespace || !command || !handler) {
                    logMessage('Error: All MCP fields are required', 'error');
                    return;
                }
                
                vscode.postMessage({
                    command: 'registerMcpHandler',
                    namespace: namespace + '.' + command,
                    handler
                });
                logMessage('Registered MCP handler for ' + namespace + '.' + command);
            });
        });
        
        // Handle messages from the extension
        window.addEventListener('message', event => {
            const message = event.data;
            
            switch (message.command) {
                case 'updateAgents':
                    updateAgentsList(message.agents);
                    break;
                    
                case 'logMessage':
                    logMessage(message.text, message.type);
                    break;
            }
        });
        
        // Update the agents list
        function updateAgentsList(agents): any {
            const container = document.getElementById('agents-container');
            const recipientSelect = document.getElementById('recipient');
            
            // Clear existing content
            container.innerHTML = '';
            recipientSelect.innerHTML = '';
            
            if (!agents || agents.length === 0) {
                container.innerHTML = '<p>No agents discovered. Click "Discover AI Agents" to find available AI extensions.</p>';
                return;
            }
            
            agents.forEach(agent => {
                // Add to the detailed view
                const agentEl = document.createElement('div');
                agentEl.className = 'agent-item';
                
                const header = document.createElement('div');
                header.className = 'agent-header';
                
                const name = document.createElement('div');
                name.className = 'agent-name';
                name.textContent = agent.name || agent.id;
                
                header.appendChild(name);
                agentEl.appendChild(header);
                
                if (agent.capabilities && agent.capabilities.length) {
                    const capsContainer = document.createElement('div');
                    capsContainer.className = 'agent-capabilities';
                    
                    agent.capabilities.forEach(cap => {
                        const capTag = document.createElement('span');
                        capTag.className = 'capability-tag';
                        capTag.textContent = cap;
                        capsContainer.appendChild(capTag);
                    });
                    
                    agentEl.appendChild(capsContainer);
                }
                
                container.appendChild(agentEl);
                
                // Add to the recipient dropdown
                const option = document.createElement('option');
                option.value = agent.id;
                option.textContent = agent.name || agent.id;
                recipientSelect.appendChild(option);
            });
            
            logMessage('Found ' + agents.length + ' AI agents');
        }
        
        // Add a message to the log
        function logMessage(message, type = 'info'): any {
            const log = document.getElementById('comms-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            const timestamp = document.createElement('div');
            timestamp.className = 'log-timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();
            
            const messageEl = document.createElement('div');
            messageEl.className = 'log-message';
            if (type === 'error') {
                messageEl.style.color = 'var(--vscode-errorForeground)';
            }
            messageEl.textContent = message;
            
            entry.appendChild(timestamp);
            entry.appendChild(messageEl);
            
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        // Request initial agents list
        vscode.postMessage({ command: 'discoverAgents' });
    </script>
</body>
</html>`;
  }
  
  public dispose() {
    CommunicationPanel.currentPanel = undefined;
    
    // Clean up our resources
    this._panel.dispose();
    
    while (this._disposables.length) {
      const x = this._disposables.pop();
      if (x) {
        x.dispose();
      }
    }
  }
}

function getNonce(): any {
  let text = '';
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}



==============================================
FILE: ./src/vscode-extension/src/extension-discovery/agent-discovery-manager.ts
==============================================

import * as vscode from 'vscode';

export class AgentDiscoveryManager {
    constructor(private context: vscode.ExtensionContext) {}

    public discoverAgents(): Promise<string[]> {
        // Mock implementation - will be enhanced later
        return Promise.resolve(['Agent 1', 'Agent 2', 'Sample Agent']);
    }

    public registerAgent(agentId: string): Promise<boolean> {
        // Mock implementation - will be enhanced later
        console.log(`Registering agent: ${agentId}`);
        return Promise.resolve(true);
    }
}



==============================================
FILE: ./src/vscode-extension/src/extension.ts
==============================================

import * as vscode from 'vscode';
import { registerMCPIntegration } from '../mcp-integration'; // Adjust path if needed
import { ChatViewProvider } from './chat/chat-interface'; // Adjust path if needed
import { LLMProviderManager } from './llm/LLMProviderManager'; // Assuming this exists
import { registerVerificationCommands } from './commands/verification-commands';
import { initializeLogging, log } from './utils/logging';
import { MockLLMService } from './llm/mock-llm-service';
import { CommandMonitor, registerModeCommands } from './command-monitor';
import { VscodeToolIntegration } from './mcp/tool-integration'; // For MCP tool integration
import { registerDefaultTools } from './mcp/default-tools'; // For registering default MCP tools
import { registerAnthropicXmlCommands } from './anthropic-xml/commands'; // For Anthropic XML function call commands
import { A2ACoordinator } from '../../../services/A2ACoordinator';
import { TaskType, Priority } from '../../../services/RooCodeCommunication';
import { handleCodeTask } from '../../../services/TaskHandler';
import { CodeIndexer } from '../../../services/CodeIndexer';

// Import view providers
import { OrchestratorViewProvider } from './views/OrchestratorViewProvider';
import { DebugViewProvider } from './views/DebugViewProvider';
import { AskViewProvider } from './views/AskViewProvider';
import { ArchitectViewProvider } from './views/ArchitectViewProvider';
import { CodeViewProvider } from './views/CodeViewProvider';

/**
 * Activate the extension
 */
export function activate(context: vscode.ExtensionContext) {
  // Initialize logging
  const outputChannel = initializeLogging();

  log('The New Fuse VSCode Extension is now active!');
  console.log('The New Fuse VSCode Extension is now active!');

  // Initialize the command monitor for mode handling
  const commandMonitor = CommandMonitor.getInstance(context);

  // Initialize LLM Provider Manager
  const lmBridge = new LLMProviderManager(context);
  // TODO: Add actual providers to lmBridge

  // Initialize tool integration for MCP
  const toolIntegration = new VscodeToolIntegration(context);

  // Register default MCP tools
  registerDefaultTools(toolIntegration);

  // Register MCP Integration and get manager + agent integration
  const { mcpManager, agentIntegration } = registerMCPIntegration(context, lmBridge);

  // Register mode commands
  const modeCommandDisposables = registerModeCommands(context);
  modeCommandDisposables.forEach(disposable => context.subscriptions.push(disposable));

  // Register view providers for each mode
  registerViewProviders(context);

  // Register Chat View Provider
  const chatViewProvider = new ChatViewProvider(context.extensionUri, context, lmBridge, agentIntegration);
  context.subscriptions.push(
    vscode.window.registerWebviewViewProvider(ChatViewProvider.viewType, chatViewProvider)
  );

  // Set the chat enabled context
  vscode.commands.executeCommand('setContext', 'thefuse:chatEnabled', true);

  // Create mock LLM service for development mode
  const mockLLMService = new MockLLMService();

  // Register verification commands with LLM service
  const verificationManager = registerVerificationCommands(
    context,
    context.extensionMode === vscode.ExtensionMode.Development ? mockLLMService : undefined
  );

  // Log verification service initialization
  log(`Verification commands registered with ${context.extensionMode === vscode.ExtensionMode.Development ? 'mock' : 'no'} LLM service`);

  // Register basic commands
  registerBasicCommands(context);

  // Register Anthropic XML function call commands
  const anthropicXmlCommandDisposables = registerAnthropicXmlCommands(context);
  anthropicXmlCommandDisposables.forEach(disposable => context.subscriptions.push(disposable));

  // Create status bar item
  const statusBarItem = createStatusBarItem(commandMonitor);
  context.subscriptions.push(statusBarItem);

  // Initialize with the current mode
  const currentMode = commandMonitor.getCurrentMode();
  log(`Initialized with mode: ${currentMode}`);
  vscode.window.showInformationMessage(`The New Fuse is running in ${currentMode} mode`);

  // Initialize A2A Coordinator for distributed agent tasks
  const redisUrl = vscode.workspace.getConfiguration('thefuse').get<string>('redisUrl') || 'redis://localhost:6379';
  const coordinator = new A2ACoordinator(redisUrl);
  coordinator.initialize().then(() => {
    log('[A2A] Coordinator initialized');
    // start agentA worker loop
    coordinator.startWorker('agentA', async task => {
      log(`[A2A][agentA] Handling ${task.taskId} on ${task.filePath}`);
      await handleCodeTask({ ...task, taskId: task.taskId }, 'agentA');
    });
    // start agentB worker loop
    coordinator.startWorker('agentB', async task => {
      log(`[A2A][agentB] Handling ${task.taskId} on ${task.filePath}`);
      await handleCodeTask({ ...task, taskId: task.taskId }, 'agentB');
    });
  }).catch(err => log(`[A2A] Coordinator init error: ${err}`));

  // Register enqueueTask command
  const enqueueCmd = vscode.commands.registerCommand('thefuse.enqueueTask', async () => {
    const typeItems: TaskType[] = ['code_review','refactoring','file_consolidation','consolidation_analysis','code_generation','system_design'];
    const type = await vscode.window.showQuickPick(typeItems, { placeHolder: 'Select task type' });
    if (!type) return;
    const fileUris = await vscode.window.showOpenDialog({ canSelectMany: false, openLabel: 'Select file for task' });
    if (!fileUris) return;
    const filePath = fileUris[0].fsPath;
    const description = await vscode.window.showInputBox({ prompt: 'Enter task description' }) || '';
    const priorityItems: Priority[] = ['low','medium','high','critical'];
    const priority = await vscode.window.showQuickPick(priorityItems, { placeHolder: 'Select priority' });
    if (!priority) return;
    const taskId = `task-${Date.now()}`;
    try {
      const id = await coordinator.addTask({ taskId, type, filePath, description, priority });
      vscode.window.showInformationMessage(`Enqueued task ${id}`);
    } catch (err) {
      vscode.window.showErrorMessage(`Failed to enqueue task: ${err}`);
    }
  });
  context.subscriptions.push(enqueueCmd);

  // Register indexWorkspace command
  const indexCmd = vscode.commands.registerCommand('thefuse.indexWorkspace', async () => {
    const redisUrl = vscode.workspace.getConfiguration('thefuse').get<string>('redisUrl')!;
    const root = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (!root) {
      vscode.window.showErrorMessage('No workspace folder found to index');
      return;
    }
    const indexer = new CodeIndexer(redisUrl);
    await indexer.initialize();
    const count = await indexer.indexWorkspace(root);
    vscode.window.showInformationMessage(`Indexed ${count} files into Redis search index`);
  });

  // Register searchCode command
  const searchCmd = vscode.commands.registerCommand('thefuse.searchCode', async () => {
    const term = await vscode.window.showInputBox({ prompt: 'Enter search term for code' });
    if (!term) return;
    const redisUrl = vscode.workspace.getConfiguration('thefuse').get<string>('redisUrl')!;
    const indexer = new CodeIndexer(redisUrl);
    await indexer.initialize();
    const results = await indexer.search(term);
    if (results.length === 0) {
      vscode.window.showInformationMessage('No matches found');
    } else {
      const items = results.map(r => ({ label: r.filePath }));
      const pick = await vscode.window.showQuickPick(items, { placeHolder: 'Select file to open' });
      if (pick) {
        const doc = await vscode.workspace.openTextDocument(pick.label);
        await vscode.window.showTextDocument(doc);
      }
    }
  });

  context.subscriptions.push(indexCmd, searchCmd);
}

/**
 * Register view providers for each mode
 */
function registerViewProviders(context: vscode.ExtensionContext) {
  // Register mode-specific view providers
  context.subscriptions.push(
    vscode.window.registerWebviewViewProvider(
      OrchestratorViewProvider.viewType,
      new OrchestratorViewProvider(context.extensionUri, context)
    ),
    vscode.window.registerWebviewViewProvider(
      DebugViewProvider.viewType,
      new DebugViewProvider(context.extensionUri, context)
    ),
    vscode.window.registerWebviewViewProvider(
      AskViewProvider.viewType,
      new AskViewProvider(context.extensionUri, context)
    ),
    vscode.window.registerWebviewViewProvider(
      ArchitectViewProvider.viewType,
      new ArchitectViewProvider(context.extensionUri, context)
    ),
    vscode.window.registerWebviewViewProvider(
      CodeViewProvider.viewType,
      new CodeViewProvider(context.extensionUri, context)
    )
  );
}

/**
 * Register basic commands
 */
function registerBasicCommands(context: vscode.ExtensionContext) {
  // Register hello world command
  const helloWorldCommand = vscode.commands.registerCommand('thefuse.helloWorld', () => {
    vscode.window.showInformationMessage('Hello from The New Fuse!');
  });

  // Register open dashboard command
  const openDashboardCommand = vscode.commands.registerCommand('thefuse.openDashboard', () => {
    vscode.window.showInformationMessage('Opening The New Fuse Dashboard');
    // TODO: Implement dashboard opening logic
  });

  // Register open chat command
  const openChatCommand = vscode.commands.registerCommand('thefuse.openChat', () => {
    vscode.window.showInformationMessage('Opening The New Fuse Chat');
    // TODO: Implement chat opening logic
  });

  // Register open chat panel command
  const openChatPanelCommand = vscode.commands.registerCommand('thefuse.openChatPanel', () => {
    vscode.window.showInformationMessage('Opening The New Fuse Chat Panel');
    // TODO: Implement chat panel opening logic
  });

  // Register start new chat command
  const startNewChatCommand = vscode.commands.registerCommand('thefuse.startNewChat', () => {
    vscode.window.showInformationMessage('Starting New Chat');
    // TODO: Implement new chat logic
  });

  // Register clear chat command
  const clearChatCommand = vscode.commands.registerCommand('thefuse.clearChat', () => {
    vscode.window.showInformationMessage('Clearing Chat');
    // TODO: Implement chat clearing logic
  });

  // Register open settings command
  const openSettingsCommand = vscode.commands.registerCommand('thefuse.openSettings', () => {
    vscode.window.showInformationMessage('Opening The New Fuse Settings');
    // TODO: Implement settings opening logic
  });

  // Register workflow builder command
  const openWorkflowBuilderCommand = vscode.commands.registerCommand('thefuse.openWorkflowBuilder', () => {
    vscode.window.showInformationMessage('Opening Workflow Builder');
    // TODO: Implement workflow builder opening logic
  });

  // Register code analysis commands
  const analyzeCodeProblemCommand = vscode.commands.registerCommand('thefuse.analyzeCodeProblem', () => {
    vscode.window.showInformationMessage('Analyzing Code Problem');
    // TODO: Implement code problem analysis logic
  });

  const startIterativeAnalysisCommand = vscode.commands.registerCommand('thefuse.startIterativeAnalysis', () => {
    vscode.window.showInformationMessage('Starting Iterative Code Analysis');
    // TODO: Implement iterative code analysis logic

    // Set the context variable for UI visibility
    vscode.commands.executeCommand('setContext', 'thefuse:analysisIterationActive', true);
  });

  const continueIterationCommand = vscode.commands.registerCommand('thefuse.continueIteration', () => {
    vscode.window.showInformationMessage('Continuing Analysis Iteration');
    // TODO: Implement iteration continuation logic
  });

  const exportAnalysisReportCommand = vscode.commands.registerCommand('thefuse.exportAnalysisReport', () => {
    vscode.window.showInformationMessage('Exporting Analysis Report');
    // TODO: Implement report export logic
  });

  // Register MCP-related commands
  const showMcpToolsCommand = vscode.commands.registerCommand('thefuse.mcp.showTools', () => {
    vscode.window.showInformationMessage('Showing MCP Tools');
    // This will be handled by the MCP integration
  });

  const testMcpToolCommand = vscode.commands.registerCommand('thefuse.mcp.testTool', () => {
    vscode.window.showInformationMessage('Testing MCP Tool');
    // This will be handled by the MCP integration
  });

  const askAgentWithToolsCommand = vscode.commands.registerCommand('thefuse.mcp.askAgent', () => {
    vscode.window.showInformationMessage('Asking Agent with MCP Tools');
    // This will be handled by the MCP integration
  });

  const browseMcpMarketplaceCommand = vscode.commands.registerCommand('thefuse.mcp.browseMarketplace', () => {
    vscode.window.showInformationMessage('Browsing MCP Server Marketplace');
    // TODO: Implement marketplace browsing logic
  });

  const addServerFromMarketplaceCommand = vscode.commands.registerCommand('thefuse.mcp.addServerFromMarketplace', () => {
    vscode.window.showInformationMessage('Adding MCP Server from Marketplace');
    // TODO: Implement server addition logic
  });

  // Add all commands to subscriptions
  context.subscriptions.push(
    helloWorldCommand,
    openDashboardCommand,
    openChatCommand,
    openChatPanelCommand,
    startNewChatCommand,
    clearChatCommand,
    openSettingsCommand,
    openWorkflowBuilderCommand,
    analyzeCodeProblemCommand,
    startIterativeAnalysisCommand,
    continueIterationCommand,
    exportAnalysisReportCommand,
    showMcpToolsCommand,
    testMcpToolCommand,
    askAgentWithToolsCommand,
    browseMcpMarketplaceCommand,
    addServerFromMarketplaceCommand
  );
}

/**
 * Create status bar item
 */
function createStatusBarItem(commandMonitor: CommandMonitor): vscode.StatusBarItem {
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
  statusBarItem.text = `$(rocket) The New Fuse: ${commandMonitor.getCurrentMode()} mode`;
  statusBarItem.command = 'thefuse.selectMode';
  statusBarItem.tooltip = 'Click to change The New Fuse mode';
  statusBarItem.show();

  return statusBarItem;
}

/**
 * Deactivate the extension
 */
export function deactivate(): void {
  log('The New Fuse VSCode Extension is now deactivated!');
}



==============================================
FILE: ./src/vscode-extension/src/llm/LLMProviderManager.ts
==============================================

import * as vscode from 'vscode';
import { LLMProvider } from '../../types/llm';
import { ExtensionContext } from 'vscode';

// Export the TheFuseAPI interface to avoid private type errors
export interface TheFuseAPI {
  getLLMProviders(): Promise<LLMProvider[]>;
  // Add other methods as needed
}

/**
 * LLMProviderManager handles the registration, selection, and management
 * of LLM providers within the VS Code extension.
 */
export class LLMProviderManager {
  private providers: Map<string, LLMProvider> = new Map();
  private selectedProviderId: string | undefined;
  private statusBarItem: vscode.StatusBarItem;
  private onProviderChangedEmitter = new vscode.EventEmitter<string>();
  private context: ExtensionContext;
  private api: TheFuseAPI;

  readonly onProviderChanged = this.onProviderChangedEmitter.event;

  constructor(context: ExtensionContext, api: TheFuseAPI) {
    this.context = context;
    this.api = api;
    
    // Create status bar item
    this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    this.statusBarItem.command = 'thefuse.selectLLMProvider';
    this.statusBarItem.tooltip = 'Select LLM Provider';
    context.subscriptions.push(this.statusBarItem);
    
    // Register commands
    context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.selectLLMProvider', this.showProviderSelectionQuickPick.bind(this))
    );
    context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.addCustomLLMProvider', this.showAddCustomProviderQuickPick.bind(this))
    );
    context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.manageLLMProviders', this.showManageProvidersQuickPick.bind(this))
    );
    
    // Initialize default providers
    this.initializeDefaultProviders();
    
    // Show in status bar
    this.updateStatusBar();
    this.statusBarItem.show();
  }

  /**
   * Initialize the default LLM providers
   */
  private async initializeDefaultProviders() {
    try {
      // Register VS Code Copilot provider if available
      const copilotProvider = new VSCodeCopilotProvider(this.context);
      const isVSCodeCopilotAvailable = await copilotProvider.checkAvailability();
      
      if (isVSCodeCopilotAvailable) {
        this.registerProvider({
          id: 'vscode-copilot',
          name: 'GitHub Copilot',
          description: 'GitHub Copilot AI assistant',
          provider: 'github',
          modelName: 'copilot',
          isDefault: true,
          isBuiltin: true
        });
      }
      
      // Try to fetch providers from The New Fuse API
      try {
        const apiProviders = await this.api.getLLMProviders();
        for (const provider of apiProviders) {
          this.registerProvider({
            ...provider,
            isBuiltin: false
          });
        }
      } catch (err) {
        console.error('Failed to fetch LLM providers from API:', err);
      }
      
      // Load saved custom providers from extension storage
      try {
        const customProviders = this.context.globalState.get<LLMProvider[]>('thefuse.customLLMProviders', []);
        for (const provider of customProviders) {
          if (!this.providers.has(provider.id)) {
            this.registerProvider({
              ...provider,
              isCustom: true,
              isBuiltin: false
            });
          }
        }
      } catch (err) {
        console.error('Failed to load custom LLM providers:', err);
      }
      
      // Check if we have any providers
      if (this.providers.size === 0) {
        // Add fallback provider configurations if no providers available
        this.registerProvider({
          id: 'gpt-4',
          name: 'OpenAI GPT-4',
          description: 'OpenAI GPT-4 model',
          provider: 'openai',
          modelName: 'gpt-4',
          isDefault: !isVSCodeCopilotAvailable,
          isBuiltin: false
        });
        
        this.registerProvider({
          id: 'gpt-3.5-turbo',
          name: 'OpenAI GPT-3.5 Turbo',
          description: 'OpenAI GPT-3.5 Turbo model',
          provider: 'openai',
          modelName: 'gpt-3.5-turbo',
          isBuiltin: false
        });
      }
      
      // Select default provider
      const defaultProvider = Array.from(this.providers.values()).find(p => p.isDefault);
      if (defaultProvider) {
        this.selectProvider(defaultProvider.id);
      } else if (this.providers.size > 0) {
        this.selectProvider(this.providers.values().next().value.id);
      }
    } catch (err) {
      console.error('Error initializing LLM providers:', err);
      vscode.window.showErrorMessage('Failed to initialize LLM providers');
    }
  }
  
  /**
   * Register a new LLM provider
   */
  registerProvider(provider: LLMProvider) {
    this.providers.set(provider.id, provider);
    this.updateStatusBar();
    
    // If this is the only provider, select it
    if (this.providers.size === 1) {
      this.selectProvider(provider.id);
    }
    
    return provider;
  }
  
  /**
   * Get a provider by ID
   */
  getProvider(id: string): LLMProvider | undefined {
    return this.providers.get(id);
  }
  
  /**
   * Get all registered providers
   */
  getAllProviders(): LLMProvider[] {
    return Array.from(this.providers.values());
  }
  
  /**
   * Get the currently selected provider
   */
  getSelectedProvider(): LLMProvider | undefined {
    return this.selectedProviderId ? this.providers.get(this.selectedProviderId) : undefined;
  }
  
  /**
   * Select a provider by ID
   */
  selectProvider(id: string) {
    const provider = this.providers.get(id);
    if (!provider) {
      console.warn(`Provider with id ${id} not found`);
      return false;
    }
    
    this.selectedProviderId = id;
    this.updateStatusBar();
    this.onProviderChangedEmitter.fire(id);
    
    return true;
  }
  
  /**
   * Remove a provider by ID
   */
  removeProvider(id: string) {
    const provider = this.providers.get(id);
    if (!provider) {
      return false;
    }
    
    // Don't allow removing built-in providers
    if (provider.isBuiltin) {
      vscode.window.showWarningMessage(`Cannot remove built-in provider ${provider.name}`);
      return false;
    }
    
    this.providers.delete(id);
    
    // Update custom providers in storage
    this.saveCustomProviders();
    
    // If the removed provider was selected, select another one
    if (this.selectedProviderId === id) {
      const defaultProvider = Array.from(this.providers.values()).find(p => p.isDefault);
      if (defaultProvider) {
        this.selectProvider(defaultProvider.id);
      } else if (this.providers.size > 0) {
        this.selectProvider(this.providers.values().next().value.id);
      } else {
        this.selectedProviderId = undefined;
      }
    }
    
    this.updateStatusBar();
    return true;
  }
  
  /**
   * Save custom providers to extension storage
   */
  private saveCustomProviders() {
    const customProviders = Array.from(this.providers.values())
      .filter(p => p.isCustom);
    
    this.context.globalState.update('thefuse.customLLMProviders', customProviders);
  }
  
  /**
   * Show quick pick to select a provider
   */
  private async showProviderSelectionQuickPick() {
    const providerItems = Array.from(this.providers.values()).map(provider => ({
      label: provider.name,
      description: provider.isDefault ? '(Default)' : '',
      detail: provider.description || provider.modelName,
      provider
    }));
    
    const selectedItem = await vscode.window.showQuickPick(providerItems, {
      placeHolder: 'Select LLM Provider',
      title: 'The New Fuse: Select LLM Provider'
    });
    
    if (selectedItem) {
      this.selectProvider(selectedItem.provider.id);
    }
  }
  
  /**
   * Show quick pick to add a custom provider
   */
  private async showAddCustomProviderQuickPick() {
    const providerTypes = [
      { label: 'OpenAI', id: 'openai' },
      { label: 'Anthropic', id: 'anthropic' },
      { label: 'Gemini (Google)', id: 'gemini' },
      { label: 'Other', id: 'other' }
    ];
    
    const selectedType = await vscode.window.showQuickPick(providerTypes, {
      placeHolder: 'Select Provider Type',
      title: 'The New Fuse: Add Custom LLM Provider'
    });
    
    if (!selectedType) {
      return;
    }
    
    const name = await vscode.window.showInputBox({
      prompt: 'Enter a name for this provider',
      placeHolder: 'e.g. My GPT-4',
      title: 'Provider Name'
    });
    
    if (!name) {
      return;
    }
    
    const apiKey = await vscode.window.showInputBox({
      prompt: 'Enter your API key',
      password: true,
      title: 'API Key'
    });
    
    if (!apiKey) {
      return;
    }
    
    let modelName = '';
    
    if (selectedType.id === 'openai') {
      const models = [
        { label: 'GPT-4', id: 'gpt-4' },
        { label: 'GPT-4 Turbo', id: 'gpt-4-turbo' },
        { label: 'GPT-3.5 Turbo', id: 'gpt-3.5-turbo' },
        { label: 'GPT-4o', id: 'gpt-4o' }
      ];
      
      const selectedModel = await vscode.window.showQuickPick(models, {
        placeHolder: 'Select Model',
        title: 'OpenAI Model'
      });
      
      if (!selectedModel) {
        return;
      }
      
      modelName = selectedModel.id;
    } else if (selectedType.id === 'anthropic') {
      const models = [
        { label: 'Claude 3 Opus', id: 'claude-3-opus-20240229' },
        { label: 'Claude 3 Sonnet', id: 'claude-3-sonnet-20240229' },
        { label: 'Claude 3 Haiku', id: 'claude-3-haiku-20240307' }
      ];
      
      const selectedModel = await vscode.window.showQuickPick(models, {
        placeHolder: 'Select Model',
        title: 'Anthropic Model'
      });
      
      if (!selectedModel) {
        return;
      }
      
      modelName = selectedModel.id;
    } else if (selectedType.id === 'gemini') {
      const models = [
        { label: 'Gemini Pro', id: 'gemini-pro' },
        { label: 'Gemini Ultra', id: 'gemini-ultra' }
      ];
      
      const selectedModel = await vscode.window.showQuickPick(models, {
        placeHolder: 'Select Model',
        title: 'Gemini Model'
      });
      
      if (!selectedModel) {
        return;
      }
      
      modelName = selectedModel.id;
    } else {
      modelName = await vscode.window.showInputBox({
        prompt: 'Enter model name',
        placeHolder: 'e.g. mistral-7b-instruct',
        title: 'Model Name'
      });
      
      if (!modelName) {
        return;
      }
    }
    
    const apiEndpoint = await vscode.window.showInputBox({
      prompt: 'Enter API endpoint (optional)',
      placeHolder: 'e.g. https://api.openai.com/v1',
      title: 'API Endpoint',
      value: selectedType.id === 'openai' ? 'https://api.openai.com/v1' :
             selectedType.id === 'anthropic' ? 'https://api.anthropic.com' : ''
    });
    
    const id = `custom-${Date.now()}`;
    const newProvider: LLMProvider = {
      id,
      name,
      provider: selectedType.id,
      modelName,
      apiKey,
      apiEndpoint: apiEndpoint || undefined,
      isCustom: true,
      isBuiltin: false
    };
    
    this.registerProvider(newProvider);
    this.saveCustomProviders();
    
    // Set as selected provider
    this.selectProvider(id);
    
    vscode.window.showInformationMessage(`Added custom provider: ${name}`);
  }
  
  /**
   * Show quick pick to manage providers
   */
  private async showManageProvidersQuickPick() {
    const providers = this.getAllProviders();
    const items = providers.map(provider => ({
      label: provider.name,
      description: provider.isDefault ? '(Default)' : 
                   provider.isBuiltin ? '(Built-in)' : 
                   provider.isCustom ? '(Custom)' : '',
      provider
    }));
    
    items.push({ 
      label: '+ Add Custom Provider', 
      description: '',
      provider: { id: 'add-new', name: '', provider: '', modelName: '' }
    });
    
    const selectedItem = await vscode.window.showQuickPick(items, {
      placeHolder: 'Manage LLM Providers',
      title: 'The New Fuse: Manage LLM Providers'
    });
    
    if (!selectedItem) {
      return;
    }
    
    if (selectedItem.provider.id === 'add-new') {
      this.showAddCustomProviderQuickPick();
      return;
    }
    
    const options = [
      { label: 'Select', id: 'select' },
      { label: 'Set as Default', id: 'default' }
    ];
    
    if (selectedItem.provider.isCustom) {
      options.push({ label: 'Delete', id: 'delete' });
    }
    
    const action = await vscode.window.showQuickPick(options, {
      placeHolder: `Action for ${selectedItem.provider.name}`,
      title: 'Select Action'
    });
    
    if (!action) {
      return;
    }
    
    switch (action.id) {
      case 'select':
        this.selectProvider(selectedItem.provider.id);
        vscode.window.showInformationMessage(`Selected provider: ${selectedItem.provider.name}`);
        break;
      case 'default':
        // Update all providers to remove default flag
        for (const provider of providers) {
          provider.isDefault = false;
        }
        // Set the selected provider as default
        selectedItem.provider.isDefault = true;
        this.saveCustomProviders();
        this.updateStatusBar();
        vscode.window.showInformationMessage(`Set ${selectedItem.provider.name} as default provider`);
        break;
      case 'delete':
        this.removeProvider(selectedItem.provider.id);
        vscode.window.showInformationMessage(`Removed provider: ${selectedItem.provider.name}`);
        break;
    }
  }
  
  /**
   * Update the status bar item
   */
  private updateStatusBar() {
    const selectedProvider = this.getSelectedProvider();
    if (selectedProvider) {
      this.statusBarItem.text = `$(hubot) ${selectedProvider.name}`;
    } else {
      this.statusBarItem.text = '$(hubot) Select LLM';
    }
  }
}


==============================================
FILE: ./src/vscode-extension/src/llm/mock-llm-service.ts
==============================================

/**
 * Mock LLM Service for testing
 */

/**
 * Mock LLM Service implementation
 */
export class MockLLMService {
  /**
   * Generate a completion using the specified model and messages
   */
  async generateCompletion(params: {
    model: string;
    messages: Array<{role: string, content: string}>;
    temperature?: number;
    max_tokens?: number;
    response_format?: {type: string};
  }): Promise<any> {
    // Extract the claim from the messages
    const userMessage = params.messages.find(m => m.role === 'user')?.content || '';
    const claimMatch = userMessage.match(/"([^"]+)"/);
    const claim = claimMatch ? claimMatch[1] : 'Unknown claim';
    
    // Determine verification result based on the claim content
    let status: 'verified' | 'refuted' | 'unverified' | 'insufficient_data';
    let confidenceScore: number;
    
    if (claim.toLowerCase().includes('verified')) {
      status = 'verified';
      confidenceScore = 0.9;
    } else if (claim.toLowerCase().includes('refuted')) {
      status = 'refuted';
      confidenceScore = 0.8;
    } else if (claim.toLowerCase().includes('insufficient')) {
      status = 'insufficient_data';
      confidenceScore = 0.3;
    } else {
      status = 'unverified';
      confidenceScore = 0.5;
    }
    
    // Generate mock sources
    const sources = [
      {
        name: 'Mock Source 1',
        url: 'https://example.com/source1',
        type: 'official',
        reliability: 0.9,
        excerpt: `This source ${status === 'verified' ? 'confirms' : status === 'refuted' ? 'refutes' : 'partially addresses'} the claim.`
      }
    ];
    
    // Add a second source for verified claims
    if (status === 'verified') {
      sources.push({
        name: 'Mock Source 2',
        url: 'https://example.com/source2',
        type: 'academic',
        reliability: 0.95,
        excerpt: 'This academic source provides additional confirmation of the claim.'
      });
    }
    
    // Simulate processing delay
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Return mock response
    return {
      status,
      confidenceScore,
      explanation: `This claim is ${status} based on the available sources.`,
      sources
    };
  }
}



==============================================
FILE: ./src/vscode-extension/src/mcp/default-tools.ts
==============================================

import { VscodeToolIntegration } from './tool-integration';

/**
 * Register default MCP tools
 */
export function registerDefaultTools(toolIntegration: VscodeToolIntegration): void {
  // File Management Tools
  registerFileManagementTools(toolIntegration);
  
  // Process Management Tools
  registerProcessManagementTools(toolIntegration);
  
  // Web Interaction Tools
  registerWebInteractionTools(toolIntegration);
  
  // Code Analysis Tools
  registerCodeAnalysisTools(toolIntegration);
  
  // Integration Tools
  registerIntegrationTools(toolIntegration);
  
  // Memory Tools
  registerMemoryTools(toolIntegration);
}

/**
 * Register file management tools
 */
function registerFileManagementTools(toolIntegration: VscodeToolIntegration): void {
  // Save File Tool
  toolIntegration.registerTool({
    name: 'save-file',
    description: 'Save a new file. Use this tool to write new files with the attached content.',
    parameters: {
      type: 'object',
      properties: {
        file_path: {
          type: 'string',
          description: 'The path of the file to save.'
        },
        file_content: {
          type: 'string',
          description: 'The content of the file.'
        },
        add_last_line_newline: {
          type: 'boolean',
          description: 'Whether to add a newline at the end of the file (default: true).'
        }
      },
      required: ['file_path', 'file_content']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `File saved: ${params.file_path}` };
    }
  });
  
  // File Editor Tool
  toolIntegration.registerTool({
    name: 'str-replace-editor',
    description: 'Custom editing tool for viewing, creating and editing files',
    parameters: {
      type: 'object',
      properties: {
        command: {
          type: 'string',
          enum: ['view', 'str_replace', 'insert'],
          description: 'The commands to run. Allowed options are: "view", "str_replace", "insert".'
        },
        path: {
          type: 'string',
          description: 'Full path to file relative to the workspace root.'
        },
        view_range: {
          type: 'array',
          items: {
            type: 'integer'
          },
          description: 'Optional parameter of `view` command when `path` points to a file.'
        },
        old_str_1: {
          type: 'string',
          description: 'Required parameter of `str_replace` command containing the string in `path` to replace.'
        },
        new_str_1: {
          type: 'string',
          description: 'Required parameter of `str_replace` command containing the new string.'
        },
        old_str_start_line_number_1: {
          type: 'integer',
          description: 'The line number of the first line of `old_str_1` in the file.'
        },
        old_str_end_line_number_1: {
          type: 'integer',
          description: 'The line number of the last line of `old_str_1` in the file.'
        },
        insert_line_1: {
          type: 'integer',
          description: 'Required parameter of `insert` command. The line number after which to insert the new string.'
        }
      },
      required: ['command', 'path']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `File operation completed: ${params.path}` };
    }
  });
  
  // Remove Files Tool
  toolIntegration.registerTool({
    name: 'remove-files',
    description: 'Remove files. ONLY use this tool to delete files in the user\'s workspace.',
    parameters: {
      type: 'object',
      properties: {
        file_paths: {
          type: 'array',
          items: {
            type: 'string'
          },
          description: 'The paths of the files to remove.'
        }
      },
      required: ['file_paths']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Files removed: ${params.file_paths.join(', ')}` };
    }
  });
}

/**
 * Register process management tools
 */
function registerProcessManagementTools(toolIntegration: VscodeToolIntegration): void {
  // Launch Process Tool
  toolIntegration.registerTool({
    name: 'launch-process',
    description: 'Launch a new process with a shell command.',
    parameters: {
      type: 'object',
      properties: {
        command: {
          type: 'string',
          description: 'The shell command to execute.'
        },
        wait: {
          type: 'boolean',
          description: 'Whether to wait for the command to complete.'
        },
        max_wait_seconds: {
          type: 'number',
          description: 'Number of seconds to wait for the command to complete.'
        },
        cwd: {
          type: 'string',
          description: 'Working directory for the command.'
        }
      },
      required: ['command', 'wait', 'max_wait_seconds']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Process launched: ${params.command}` };
    }
  });
  
  // Read Process Tool
  toolIntegration.registerTool({
    name: 'read-process',
    description: 'Read output from a terminal.',
    parameters: {
      type: 'object',
      properties: {
        terminal_id: {
          type: 'integer',
          description: 'Terminal ID to read from.'
        },
        wait: {
          type: 'boolean',
          description: 'Whether to wait for the command to complete.'
        },
        max_wait_seconds: {
          type: 'number',
          description: 'Number of seconds to wait for the command to complete.'
        }
      },
      required: ['terminal_id', 'wait', 'max_wait_seconds']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Process output read from terminal ${params.terminal_id}` };
    }
  });
  
  // Write Process Tool
  toolIntegration.registerTool({
    name: 'write-process',
    description: 'Write input to a terminal.',
    parameters: {
      type: 'object',
      properties: {
        terminal_id: {
          type: 'integer',
          description: 'Terminal ID to write to.'
        },
        input_text: {
          type: 'string',
          description: 'Text to write to the process\'s stdin.'
        }
      },
      required: ['terminal_id', 'input_text']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Input written to terminal ${params.terminal_id}` };
    }
  });
  
  // Kill Process Tool
  toolIntegration.registerTool({
    name: 'kill-process',
    description: 'Kill a process by its terminal ID.',
    parameters: {
      type: 'object',
      properties: {
        terminal_id: {
          type: 'integer',
          description: 'Terminal ID to kill.'
        }
      },
      required: ['terminal_id']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Process killed in terminal ${params.terminal_id}` };
    }
  });
  
  // List Processes Tool
  toolIntegration.registerTool({
    name: 'list-processes',
    description: 'List all known terminals and their states.',
    parameters: {
      type: 'object',
      properties: {}
    },
    execute: async () => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: 'Processes listed' };
    }
  });
}

/**
 * Register web interaction tools
 */
function registerWebInteractionTools(toolIntegration: VscodeToolIntegration): void {
  // Web Search Tool
  toolIntegration.registerTool({
    name: 'web-search',
    description: 'Search the web for information.',
    parameters: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'The search query to send.'
        },
        num_results: {
          type: 'integer',
          description: 'Number of results to return',
          default: 5,
          minimum: 1,
          maximum: 10
        }
      },
      required: ['query']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Web search for: ${params.query}` };
    }
  });
  
  // Web Fetch Tool
  toolIntegration.registerTool({
    name: 'web-fetch',
    description: 'Fetches data from a webpage and converts it into Markdown.',
    parameters: {
      type: 'object',
      properties: {
        url: {
          type: 'string',
          description: 'The URL to fetch.'
        }
      },
      required: ['url']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Web content fetched from: ${params.url}` };
    }
  });
  
  // Open Browser Tool
  toolIntegration.registerTool({
    name: 'open-browser',
    description: 'Open a URL in the default browser.',
    parameters: {
      type: 'object',
      properties: {
        url: {
          type: 'string',
          description: 'The URL to open in the browser.'
        }
      },
      required: ['url']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Browser opened with URL: ${params.url}` };
    }
  });
}

/**
 * Register code analysis tools
 */
function registerCodeAnalysisTools(toolIntegration: VscodeToolIntegration): void {
  // Codebase Retrieval Tool
  toolIntegration.registerTool({
    name: 'codebase-retrieval',
    description: 'This tool is Augment\'s context engine, the world\'s best codebase context engine.',
    parameters: {
      type: 'object',
      properties: {
        information_request: {
          type: 'string',
          description: 'A description of the information you need.'
        }
      },
      required: ['information_request']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Codebase information retrieved for: ${params.information_request}` };
    }
  });
  
  // Diagnostics Tool
  toolIntegration.registerTool({
    name: 'diagnostics',
    description: 'Get issues (errors, warnings, etc.) from the IDE.',
    parameters: {
      type: 'object',
      properties: {
        paths: {
          type: 'array',
          items: {
            type: 'string'
          },
          description: 'Optional list of file paths to get issues for from the IDE.'
        }
      }
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: 'Diagnostics retrieved' };
    }
  });
}

/**
 * Register integration tools
 */
function registerIntegrationTools(toolIntegration: VscodeToolIntegration): void {
  // GitHub API Tool
  toolIntegration.registerTool({
    name: 'github-api',
    description: 'Make GitHub API calls.',
    parameters: {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'GitHub API path.'
        },
        method: {
          type: 'string',
          enum: ['GET', 'POST', 'PATCH', 'PUT'],
          default: 'GET',
          description: 'HTTP method to use.'
        },
        data: {
          description: 'Data to send - automatically handled as query params for GET or JSON body for POST.'
        },
        summary: {
          type: 'string',
          description: 'A short human-readable summary of what this API call will do.'
        },
        details: {
          type: 'boolean',
          default: false,
          description: 'If false (default), it will only contain the most essential fields.'
        }
      },
      required: ['path']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `GitHub API call to: ${params.path}` };
    }
  });
  
  // Linear Tool
  toolIntegration.registerTool({
    name: 'linear',
    description: 'Make queries against the Linear API using natural language.',
    parameters: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Natural language query for Linear API.'
        },
        summary: {
          type: 'string',
          description: 'One sentence description of the intent of this tool call.'
        },
        is_read_only: {
          type: 'boolean',
          default: false,
          description: 'Whether this tool call will require mutating Linear\'s state.'
        }
      },
      required: ['summary', 'query']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Linear API query: ${params.query}` };
    }
  });
  
  // Jira Tool
  toolIntegration.registerTool({
    name: 'jira',
    description: 'Make Jira API calls with flexible endpoints.',
    parameters: {
      type: 'object',
      properties: {
        endpoint: {
          type: 'string',
          description: 'The API endpoint path.'
        },
        method: {
          type: 'string',
          enum: ['GET', 'POST', 'PUT'],
          default: 'GET',
          description: 'HTTP method to use.'
        },
        data: {
          description: 'Data to send - automatically handled as query params for GET or JSON body for POST/PUT.'
        },
        summary: {
          type: 'string',
          description: 'A short human-readable summary of what this API call will do.'
        }
      },
      required: ['endpoint']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Jira API call to: ${params.endpoint}` };
    }
  });
  
  // Confluence Tool
  toolIntegration.registerTool({
    name: 'confluence',
    description: 'Make Confluence API calls with flexible endpoints.',
    parameters: {
      type: 'object',
      properties: {
        endpoint: {
          type: 'string',
          description: 'The API endpoint path.'
        },
        method: {
          type: 'string',
          enum: ['GET', 'POST', 'PUT'],
          default: 'GET',
          description: 'HTTP method to use.'
        },
        data: {
          description: 'Data to send - automatically handled as query params for GET or JSON body for POST/PUT.'
        },
        summary: {
          type: 'string',
          description: 'A short human-readable summary of what this API call will do.'
        }
      },
      required: ['endpoint']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Confluence API call to: ${params.endpoint}` };
    }
  });
  
  // Notion Tool
  toolIntegration.registerTool({
    name: 'notion',
    description: 'Use this tool to access content in Notion, a knowledge base for teams.',
    parameters: {
      type: 'object',
      properties: {
        method: {
          type: 'string',
          enum: ['read_page', 'search_pages', 'read_database'],
          description: 'The Notion API method to call.'
        },
        href: {
          type: 'string',
          description: 'The URL to the resource being accessed.'
        },
        params: {
          description: 'The parameters to pass to the API method.'
        },
        summary: {
          type: 'string',
          description: 'A short human-readable summary of what this tool call will do.'
        }
      },
      required: ['summary', 'href', 'method', 'params']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Notion API call: ${params.method}` };
    }
  });
}

/**
 * Register memory tools
 */
function registerMemoryTools(toolIntegration: VscodeToolIntegration): void {
  // Remember Tool
  toolIntegration.registerTool({
    name: 'remember',
    description: 'Call this tool when user asks you to remember something.',
    parameters: {
      type: 'object',
      properties: {
        memory: {
          type: 'string',
          description: 'The concise (1 sentence) memory to remember.'
        }
      },
      required: ['memory']
    },
    execute: async (params) => {
      // Implementation will be handled by the MCP integration
      return { success: true, message: `Memory stored: ${params.memory}` };
    }
  });
}



==============================================
FILE: ./src/vscode-extension/src/mcp/tool-integration.ts
==============================================

import * as vscode from 'vscode';

/**
 * Tool parameter schema
 */
interface ToolParameterSchema {
  type: string;
  properties: Record<string, any>;
  required?: string[];
}

/**
 * Tool definition
 */
interface ToolDefinition {
  name: string;
  description: string;
  parameters: ToolParameterSchema;
  execute: (params: any) => Promise<any>;
}

/**
 * VSCode Tool Integration for MCP
 */
export class VscodeToolIntegration {
  private tools: Map<string, ToolDefinition> = new Map();
  private context: vscode.ExtensionContext;

  constructor(context: vscode.ExtensionContext) {
    this.context = context;
    this.registerCommands();
  }

  /**
   * Register a tool with the integration
   */
  public registerTool(tool: ToolDefinition): void {
    this.tools.set(tool.name, tool);
    console.log(`Registered tool: ${tool.name}`);
  }

  /**
   * Get a tool by name
   */
  public getTool(name: string): ToolDefinition | undefined {
    return this.tools.get(name);
  }

  /**
   * Get all registered tools
   */
  public getAllTools(): ToolDefinition[] {
    return Array.from(this.tools.values());
  }

  /**
   * Execute a tool by name with parameters
   */
  public async executeTool(name: string, params: any): Promise<any> {
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(`Tool not found: ${name}`);
    }

    try {
      return await tool.execute(params);
    } catch (error) {
      console.error(`Error executing tool ${name}:`, error);
      throw error;
    }
  }

  /**
   * Register commands for tool integration
   */
  private registerCommands(): void {
    // Register command to show available tools
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.mcp.showTools', () => {
        this.showToolsList();
      })
    );

    // Register command to test a tool
    this.context.subscriptions.push(
      vscode.commands.registerCommand('thefuse.mcp.testTool', async () => {
        await this.testTool();
      })
    );
  }

  /**
   * Show a list of available tools
   */
  private async showToolsList(): Promise<void> {
    const tools = this.getAllTools();
    
    if (tools.length === 0) {
      vscode.window.showInformationMessage('No MCP tools are registered.');
      return;
    }

    const toolItems = tools.map(tool => ({
      label: tool.name,
      description: tool.description,
      tool
    }));

    const selectedTool = await vscode.window.showQuickPick(toolItems, {
      placeHolder: 'Select a tool to view details',
      title: 'MCP Tools'
    });

    if (selectedTool) {
      const toolDetails = `
# ${selectedTool.tool.name}

${selectedTool.tool.description}

## Parameters

\`\`\`json
${JSON.stringify(selectedTool.tool.parameters, null, 2)}
\`\`\`
`;

      const doc = await vscode.workspace.openTextDocument({
        content: toolDetails,
        language: 'markdown'
      });
      
      await vscode.window.showTextDocument(doc);
    }
  }

  /**
   * Test a tool with user-provided parameters
   */
  private async testTool(): Promise<void> {
    const tools = this.getAllTools();
    
    if (tools.length === 0) {
      vscode.window.showInformationMessage('No MCP tools are registered.');
      return;
    }

    const toolItems = tools.map(tool => ({
      label: tool.name,
      description: tool.description,
      tool
    }));

    const selectedTool = await vscode.window.showQuickPick(toolItems, {
      placeHolder: 'Select a tool to test',
      title: 'Test MCP Tool'
    });

    if (!selectedTool) {
      return;
    }

    // Create a JSON template for the parameters
    const requiredParams = selectedTool.tool.parameters.required || [];
    const paramTemplate: Record<string, any> = {};
    
    for (const paramName of requiredParams) {
      const paramDef = selectedTool.tool.parameters.properties[paramName];
      if (paramDef) {
        paramTemplate[paramName] = getDefaultValueForType(paramDef.type);
      }
    }

    // Open an editor with the parameter template
    const doc = await vscode.workspace.openTextDocument({
      content: JSON.stringify(paramTemplate, null, 2),
      language: 'json'
    });
    
    const editor = await vscode.window.showTextDocument(doc);
    
    // Register a command to execute the tool with the parameters
    const disposable = vscode.commands.registerCommand('thefuse.mcp.executeTestTool', async () => {
      try {
        const params = JSON.parse(editor.document.getText());
        const result = await this.executeTool(selectedTool.tool.name, params);
        
        // Show the result
        const resultDoc = await vscode.workspace.openTextDocument({
          content: JSON.stringify(result, null, 2),
          language: 'json'
        });
        
        await vscode.window.showTextDocument(resultDoc);
        
        vscode.window.showInformationMessage(`Tool ${selectedTool.tool.name} executed successfully.`);
      } catch (error) {
        vscode.window.showErrorMessage(`Error executing tool: ${error}`);
      }
    });
    
    this.context.subscriptions.push(disposable);
    
    // Show a message to the user
    vscode.window.showInformationMessage(
      `Edit the parameters for ${selectedTool.tool.name} and run the 'Execute Test Tool' command when ready.`,
      'Execute Test Tool'
    ).then(selection => {
      if (selection === 'Execute Test Tool') {
        vscode.commands.executeCommand('thefuse.mcp.executeTestTool');
      }
    });
  }
}

/**
 * Get a default value for a parameter type
 */
function getDefaultValueForType(type: string): any {
  switch (type) {
    case 'string':
      return '';
    case 'number':
    case 'integer':
      return 0;
    case 'boolean':
      return false;
    case 'array':
      return [];
    case 'object':
      return {};
    default:
      return null;
  }
}



==============================================
FILE: ./src/vscode-extension/src/modes/architectHandler.ts
==============================================

import * as vscode from 'vscode';

/**
 * Handler for Architect mode
 * 
 * Architect mode is specialized for system design and planning tasks
 */
export async function handle(command: string): Promise<void> {
  console.log(`Architect handler processing command: ${command}`);
  
  // Handle specific commands differently in architect mode
  switch (command) {
    case 'thefuse.openChat':
      // In architect mode, the chat might focus on system design
      vscode.window.showInformationMessage('Opening architecture-focused chat interface');
      break;
      
    case 'thefuse.mcp.askAgent':
      // In architect mode, this might focus on design patterns and architecture
      vscode.window.showInformationMessage('Consulting architecture specialist agent');
      break;
      
    // Add more command handlers specific to architect mode
  }
}

/**
 * Initialize the architect mode
 */
export function initialize(): void {
  console.log('Initializing architect mode');
  // Set up any architect-specific state or UI
}

/**
 * Clean up when leaving architect mode
 */
export function cleanup(): void {
  console.log('Cleaning up architect mode');
  // Clean up any architect-specific state or UI
}



==============================================
FILE: ./src/vscode-extension/src/modes/askHandler.ts
==============================================

import * as vscode from 'vscode';

/**
 * Handler for Ask mode
 * 
 * Ask mode provides a simplified interface for direct queries to specific agents
 */
export async function handle(command: string): Promise<void> {
  console.log(`Ask handler processing command: ${command}`);
  
  // Handle specific commands differently in ask mode
  switch (command) {
    case 'thefuse.openChat':
      // In ask mode, the chat might be more focused on Q&A
      vscode.window.showInformationMessage('Opening direct query chat interface');
      break;
      
    case 'thefuse.mcp.askAgent':
      // In ask mode, this might be more straightforward
      vscode.window.showInformationMessage('Sending direct query to selected agent');
      break;
      
    // Add more command handlers specific to ask mode
  }
}

/**
 * Initialize the ask mode
 */
export function initialize(): void {
  console.log('Initializing ask mode');
  // Set up any ask-specific state or UI
}

/**
 * Clean up when leaving ask mode
 */
export function cleanup(): void {
  console.log('Cleaning up ask mode');
  // Clean up any ask-specific state or UI
}



==============================================
FILE: ./src/vscode-extension/src/modes/codeHandler.ts
==============================================

import * as vscode from 'vscode';

/**
 * Handler for Code mode
 * 
 * Code mode is focused on code generation and modification
 */
export async function handle(command: string): Promise<void> {
  console.log(`Code handler processing command: ${command}`);
  
  // Handle specific commands differently in code mode
  switch (command) {
    case 'thefuse.openChat':
      // In code mode, the chat might focus on code generation
      vscode.window.showInformationMessage('Opening code-focused chat interface');
      break;
      
    case 'thefuse.mcp.askAgent':
      // In code mode, this might focus on code generation and refactoring
      vscode.window.showInformationMessage('Consulting code specialist agent');
      break;
      
    // Add more command handlers specific to code mode
  }
}

/**
 * Initialize the code mode
 */
export function initialize(): void {
  console.log('Initializing code mode');
  // Set up any code-specific state or UI
}

/**
 * Clean up when leaving code mode
 */
export function cleanup(): void {
  console.log('Cleaning up code mode');
  // Clean up any code-specific state or UI
}



==============================================
FILE: ./src/vscode-extension/src/modes/debugHandler.ts
==============================================

import * as vscode from 'vscode';

/**
 * Handler for Debug mode
 * 
 * Debug mode is focused on inspecting agent-to-agent message traffic and debugging workflows
 */
export async function handle(command: string): Promise<void> {
  console.log(`Debug handler processing command: ${command}`);
  
  // Handle specific commands differently in debug mode
  switch (command) {
    case 'thefuse.openChat':
      // In debug mode, the chat might show debugging information
      vscode.window.showInformationMessage('Opening debug-focused chat with message inspection');
      break;
      
    case 'thefuse.mcp.askAgent':
      // In debug mode, this might show detailed execution steps
      vscode.window.showInformationMessage('Executing with detailed step tracing enabled');
      break;
      
    // Add more command handlers specific to debug mode
  }
}

/**
 * Initialize the debug mode
 */
export function initialize(): void {
  console.log('Initializing debug mode');
  // Set up any debug-specific state or UI
}

/**
 * Clean up when leaving debug mode
 */
export function cleanup(): void {
  console.log('Cleaning up debug mode');
  // Clean up any debug-specific state or UI
}



==============================================
FILE: ./src/vscode-extension/src/modes/orchestratorHandler.ts
==============================================

import * as vscode from 'vscode';

/**
 * Handler for Orchestrator mode
 * 
 * Orchestrator mode is focused on coordinating multiple agents working together
 */
export async function handle(command: string): Promise<void> {
  console.log(`Orchestrator handler processing command: ${command}`);
  
  // Handle specific commands differently in orchestrator mode
  switch (command) {
    case 'thefuse.openChat':
      // In orchestrator mode, the chat might show multiple agent conversations
      vscode.window.showInformationMessage('Opening multi-agent orchestration chat');
      break;
      
    case 'thefuse.mcp.askAgent':
      // In orchestrator mode, this might route to multiple agents
      vscode.window.showInformationMessage('Routing query to multiple coordinated agents');
      break;
      
    // Add more command handlers specific to orchestrator mode
  }
}

/**
 * Initialize the orchestrator mode
 */
export function initialize(): void {
  console.log('Initializing orchestrator mode');
  // Set up any orchestrator-specific state or UI
}

/**
 * Clean up when leaving orchestrator mode
 */
export function cleanup(): void {
  console.log('Cleaning up orchestrator mode');
  // Clean up any orchestrator-specific state or UI
}



==============================================
FILE: ./src/vscode-extension/src/saas/saas-integration.ts
==============================================




==============================================
FILE: ./src/vscode-extension/src/saas/saas-integration.tsx
==============================================

import * as vscode from 'vscode';

export class SaasIntegration {
    private context: vscode.ExtensionContext;
    private webviewPanel: vscode.WebviewPanel | undefined;

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
    }

    public async createDashboard(): Promise<vscode.WebviewPanel> {
        if (this.webviewPanel) {
            this.webviewPanel.reveal();
            return this.webviewPanel;
        }

        this.webviewPanel = vscode.window.createWebviewPanel(
            'thefuseDashboard',
            'The New Fuse Dashboard',
            vscode.ViewColumn.One,
            {
                enableScripts: true,
                retainContextWhenHidden: true,
                localResourceRoots: [
                    vscode.Uri.joinPath(this.context.extensionUri, 'resources')
                ]
            }
        );

        this.webviewPanel.iconPath = {
            light: vscode.Uri.joinPath(this.context.extensionUri, 'resources', 'fusion-icon.svg'),
            dark: vscode.Uri.joinPath(this.context.extensionUri, 'resources', 'fusion-icon.svg')
        };

        const config = vscode.workspace.getConfiguration('theFuse');
        const serverUrl = config.get('agentServerUrl');

        this.webviewPanel.webview.html = this.getDashboardHtml(serverUrl as string);

        // Handle messages from the webview
        this.webviewPanel.webview.onDidReceiveMessage(
            async message => {
                switch (message.command) {
                    case 'connectToSaas':
                        await this.handleSaasConnection(message.token);
                        return;
                    case 'executeAction':
                        await this.executeAction(message.action, message.params);
                        return;
                }
            },
            undefined,
            this.context.subscriptions
        );

        this.webviewPanel.onDidDispose(
            () => {
                this.webviewPanel = undefined;
            },
            null,
            this.context.subscriptions
        );

        return this.webviewPanel;
    }

    private getDashboardHtml(serverUrl: string): string {
        return `<!DOCTYPE html>
        <html>
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>The New Fuse Dashboard</title>
                <style>
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                        padding: 1rem;
                        color: var(--vscode-foreground);
                        background-color: var(--vscode-editor-background);
                    }
                    .connection-status {
                        display: flex;
                        align-items: center;
                        margin-bottom: 1rem;
                        padding: 0.5rem;
                        border-radius: 4px;
                        background: var(--vscode-toolbar-hoverBackground);
                    }
                    .status-icon {
                        width: 10px;
                        height: 10px;
                        border-radius: 50%;
                        margin-right: 0.5rem;
                    }
                    .connected { background: #4CAF50; }
                    .disconnected { background: #F44336; }
                    button {
                        background: var(--vscode-button-background);
                        color: var(--vscode-button-foreground);
                        border: none;
                        padding: 0.5rem 1rem;
                        border-radius: 2px;
                        cursor: pointer;
                    }
                    button:hover {
                        background: var(--vscode-button-hoverBackground);
                    }
                </style>
            </head>
            <body>
                <div class="connection-status">
                    <div class="status-icon disconnected" id="statusIcon"></div>
                    <span id="statusText">Disconnected</span>
                </div>
                <button id="connectBtn">Connect to The New Fuse Platform</button>
                <div id="dashboard" style="display: none;">
                    <h2>Available Tools</h2>
                    <div id="toolsList"></div>
                </div>
                <script>
                    const vscode = acquireVsCodeApi();
                    const connectBtn = document.getElementById('connectBtn');
                    const statusIcon = document.getElementById('statusIcon');
                    const statusText = document.getElementById('statusText');
                    const dashboard = document.getElementById('dashboard');

                    connectBtn.addEventListener('click', () => {
                        vscode.postMessage({
                            command: 'connectToSaas'
                        });
                    });

                    window.addEventListener('message', event => {
                        const message = event.data;
                        switch (message.type) {
                            case 'connectionStatus':
                                updateConnectionStatus(message.connected);
                                break;
                            case 'updateTools':
                                updateToolsList(message.tools);
                                break;
                        }
                    });

                    function updateConnectionStatus(connected): any {
                        statusIcon.className = 'status-icon ' + (connected ? 'connected' : 'disconnected');
                        statusText.textContent = connected ? 'Connected' : 'Disconnected';
                        dashboard.style.display = connected ? 'block' : 'none';
                        connectBtn.style.display = connected ? 'none' : 'block';
                    }

                    function updateToolsList(tools): any {
                        const toolsList = document.getElementById('toolsList');
                        toolsList.innerHTML = tools.map(tool => `
                            <div class="tool-item">
                                <h3>${tool.name}</h3>
                                <p>${tool.description}</p>
                                <button onclick="activateTool('${tool.id}')">Activate</button>
                            </div>
                        `).join('');
                    }

                    function activateTool(toolId): any {
                        vscode.postMessage({
                            command: 'executeAction',
                            action: 'activateTool',
                            params: { toolId }
                        });
                    }
                </script>
            </body>
        </html>`;
    }

    private async handleSaasConnection(token?: string) {
        try {
            const config = vscode.workspace.getConfiguration('theFuse');
            const serverUrl = config.get('agentServerUrl');
            
            // Implement connection logic here
            // This would typically involve authenticating with the SAAS platform
            
            if (this.webviewPanel) {
                this.webviewPanel.webview.postMessage({ 
                    type: 'connectionStatus', 
                    connected: true 
                });
            }
        } catch (error) {
            vscode.window.showErrorMessage('Failed to connect to The New Fuse platform: ' + error.message);
            if (this.webviewPanel) {
                this.webviewPanel.webview.postMessage({ 
                    type: 'connectionStatus', 
                    connected: false 
                });
            }
        }
    }

    private async executeAction(action: string, params: any) {
        // Implement action handling here
        switch (action) {
            case 'activateTool':
                // Handle tool activation
                break;
            // Add more actions as needed
        }
    }
}


==============================================
FILE: ./src/vscode-extension/src/utils/logging.ts
==============================================

/**
 * Logging utilities for The New Fuse extension
 */

import * as vscode from 'vscode';

// Output channel for logging
let outputChannel: vscode.OutputChannel | null = null;

/**
 * Initialize the logging system
 */
export function initializeLogging(): vscode.OutputChannel {
  if (!outputChannel) {
    outputChannel = vscode.window.createOutputChannel('The New Fuse');
  }
  return outputChannel;
}

/**
 * Log a message to the output channel
 * @param message Message to log
 */
export function log(message: string): void {
  if (!outputChannel) {
    initializeLogging();
  }
  
  const timestamp = new Date().toISOString();
  outputChannel!.appendLine(`[${timestamp}] ${message}`);
}

/**
 * Log an error to the output channel
 * @param message Error message
 * @param error Error object
 */
export function logError(message: string, error?: any): void {
  if (!outputChannel) {
    initializeLogging();
  }
  
  const timestamp = new Date().toISOString();
  const errorMessage = error instanceof Error ? error.message : error ? String(error) : 'Unknown error';
  const stackTrace = error instanceof Error && error.stack ? `\n${error.stack}` : '';
  
  outputChannel!.appendLine(`[${timestamp}] ERROR: ${message} - ${errorMessage}${stackTrace}`);
}

/**
 * Log a warning to the output channel
 * @param message Warning message
 */
export function logWarning(message: string): void {
  if (!outputChannel) {
    initializeLogging();
  }
  
  const timestamp = new Date().toISOString();
  outputChannel!.appendLine(`[${timestamp}] WARNING: ${message}`);
}

/**
 * Show an error message to the user and log it
 * @param message Error message
 * @param error Error object
 */
export function showError(message: string, error?: any): void {
  logError(message, error);
  
  const errorMessage = error instanceof Error ? error.message : error ? String(error) : 'Unknown error';
  vscode.window.showErrorMessage(`${message}: ${errorMessage}`);
}

/**
 * Show an information message to the user and log it
 * @param message Information message
 */
export function showInfo(message: string): void {
  log(message);
  vscode.window.showInformationMessage(message);
}



==============================================
FILE: ./src/vscode-extension/src/views/ArchitectViewProvider.ts
==============================================

import * as vscode from 'vscode';

/**
 * Provider for the Architect view
 */
export class ArchitectViewProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = 'thefuse.architectView';
  private _view?: vscode.WebviewView;

  constructor(
    private readonly _extensionUri: vscode.Uri,
    private readonly _extensionContext: vscode.ExtensionContext
  ) {}

  resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken,
  ) {
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    // Handle messages from the webview
    webviewView.webview.onDidReceiveMessage(message => {
      switch (message.command) {
        case 'analyzeProject':
          vscode.window.showInformationMessage('Analyzing project architecture...');
          break;
        case 'generateDiagram':
          vscode.window.showInformationMessage(`Generating ${message.diagramType} diagram...`);
          break;
      }
    });
  }

  private _getHtmlForWebview(webview: vscode.Webview): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Architect</title>
        <style>
          body {
            padding: 10px;
            color: var(--vscode-foreground);
            font-family: var(--vscode-font-family);
          }
          .container {
            display: flex;
            flex-direction: column;
            gap: 10px;
          }
          button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 2px;
          }
          button:hover {
            background-color: var(--vscode-button-hoverBackground);
          }
          .diagram-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
          }
          .diagram-type {
            display: flex;
            align-items: center;
            gap: 10px;
          }
          .diagram-preview {
            background-color: var(--vscode-editor-background);
            border: 1px solid var(--vscode-panel-border);
            padding: 10px;
            border-radius: 4px;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
          }
          .section {
            margin-top: 15px;
          }
          h3 {
            margin-top: 0;
            margin-bottom: 10px;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <h2>System Architecture</h2>
          <p>Design and visualize your system architecture.</p>
          
          <button id="analyzeProjectBtn">Analyze Project Structure</button>
          
          <div class="section">
            <h3>Generate Diagrams</h3>
            <div class="diagram-options">
              <div class="diagram-type">
                <button data-type="component" class="diagram-btn">Component Diagram</button>
                <span>Visualize component relationships</span>
              </div>
              <div class="diagram-type">
                <button data-type="sequence" class="diagram-btn">Sequence Diagram</button>
                <span>Show interaction sequences</span>
              </div>
              <div class="diagram-type">
                <button data-type="class" class="diagram-btn">Class Diagram</button>
                <span>Display class relationships</span>
              </div>
              <div class="diagram-type">
                <button data-type="er" class="diagram-btn">ER Diagram</button>
                <span>Show data model</span>
              </div>
            </div>
          </div>
          
          <div class="section">
            <h3>Preview</h3>
            <div class="diagram-preview" id="diagramPreview">
              <p>Select a diagram type to generate</p>
            </div>
          </div>
          
          <div class="section">
            <h3>Architecture Recommendations</h3>
            <ul id="recommendations">
              <li>Consider implementing the Repository pattern for data access</li>
              <li>Separate business logic from UI components</li>
              <li>Add proper error handling middleware</li>
            </ul>
          </div>
        </div>
        
        <script>
          const vscode = acquireVsCodeApi();
          
          document.getElementById('analyzeProjectBtn').addEventListener('click', () => {
            vscode.postMessage({
              command: 'analyzeProject'
            });
          });
          
          document.querySelectorAll('.diagram-btn').forEach(button => {
            button.addEventListener('click', () => {
              const diagramType = button.getAttribute('data-type');
              vscode.postMessage({
                command: 'generateDiagram',
                diagramType: diagramType
              });
              
              // Update preview (in a real implementation, this would be updated with actual diagram)
              document.getElementById('diagramPreview').innerHTML = 
                \`<p>Generating \${diagramType} diagram...</p>\`;
            });
          });
        </script>
      </body>
      </html>
    `;
  }
}



==============================================
FILE: ./src/vscode-extension/src/views/AskViewProvider.ts
==============================================

import * as vscode from 'vscode';

/**
 * Provider for the Ask view
 */
export class AskViewProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = 'thefuse.askView';
  private _view?: vscode.WebviewView;

  constructor(
    private readonly _extensionUri: vscode.Uri,
    private readonly _extensionContext: vscode.ExtensionContext
  ) {}

  resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken,
  ) {
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    // Handle messages from the webview
    webviewView.webview.onDidReceiveMessage(message => {
      switch (message.command) {
        case 'askQuestion':
          vscode.window.showInformationMessage(`Asking: ${message.text}`);
          // Here you would actually process the question
          this._sendResponse('I\'m processing your question about ' + message.text);
          break;
        case 'indexWorkspace':
          vscode.commands.executeCommand('thefuse.indexWorkspace');
          break;
        case 'searchCode':
          vscode.commands.executeCommand('thefuse.searchCode');
          break;
        case 'enqueueTask':
          vscode.commands.executeCommand('thefuse.enqueueTask');
          break;
      }
    });
  }

  private _sendResponse(text: string): void {
    if (this._view) {
      this._view.webview.postMessage({ 
        command: 'response', 
        text 
      });
    }
  }

  private _getHtmlForWebview(webview: vscode.Webview): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Ask</title>
        <style>
          body {
            padding: 10px;
            color: var(--vscode-foreground);
            font-family: var(--vscode-font-family);
          }
          .container {
            display: flex;
            flex-direction: column;
            gap: 10px;
          }
          .input-container {
            display: flex;
            gap: 5px;
          }
          input {
            flex-grow: 1;
            padding: 8px;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            border-radius: 2px;
          }
          button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 2px;
          }
          button:hover {
            background-color: var(--vscode-button-hoverBackground);
          }
          .chat-container {
            background-color: var(--vscode-editor-background);
            border: 1px solid var(--vscode-panel-border);
            padding: 10px;
            border-radius: 4px;
            height: 300px;
            overflow-y: auto;
          }
          .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
          }
          .user-message {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            align-self: flex-end;
            margin-left: 20%;
          }
          .agent-message {
            background-color: var(--vscode-editor-inactiveSelectionBackground);
            margin-right: 20%;
          }
          .agent-selector {
            margin-bottom: 10px;
          }
          select {
            padding: 8px;
            background-color: var(--vscode-dropdown-background);
            color: var(--vscode-dropdown-foreground);
            border: 1px solid var(--vscode-dropdown-border);
            border-radius: 2px;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <h2>Ask an Agent</h2>
          <p>Direct questions to specific AI agents.</p>
          <div class="view-buttons">
            <button id="indexWorkspaceBtn">Index Workspace</button>
            <button id="searchCodeBtn">Search Code</button>
            <button id="enqueueTaskBtn">Enqueue Task</button>
          </div>
          <div class="agent-selector">
            <label for="agentSelect">Select Agent:</label>
            <select id="agentSelect">
              <option value="general">General Assistant</option>
              <option value="code">Code Expert</option>
              <option value="docs">Documentation Specialist</option>
              <option value="architect">System Architect</option>
            </select>
          </div>
          
          <div class="chat-container" id="chatContainer">
            <div class="message agent-message">
              Hello! I'm your AI assistant. How can I help you today?
            </div>
          </div>
          
          <div class="input-container">
            <input type="text" id="questionInput" placeholder="Type your question here..." />
            <button id="askButton">Ask</button>
          </div>
        </div>
        
        <script>
          const vscode = acquireVsCodeApi();
          const chatContainer = document.getElementById('chatContainer');
          const questionInput = document.getElementById('questionInput');
          const askButton = document.getElementById('askButton');
          
          // Handle sending questions
          function askQuestion() {
            const text = questionInput.value.trim();
            if (text) {
              // Add user message to chat
              const userMessage = document.createElement('div');
              userMessage.className = 'message user-message';
              userMessage.textContent = text;
              chatContainer.appendChild(userMessage);
              
              // Scroll to bottom
              chatContainer.scrollTop = chatContainer.scrollHeight;
              
              // Send to extension
              vscode.postMessage({
                command: 'askQuestion',
                text: text,
                agent: document.getElementById('agentSelect').value
              });
              
              // Clear input
              questionInput.value = '';
            }
          }
          
          askButton.addEventListener('click', askQuestion);
          questionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              askQuestion();
            }
          });
          document.getElementById('indexWorkspaceBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'indexWorkspace' });
          });
          document.getElementById('searchCodeBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'searchCode' });
          });
          document.getElementById('enqueueTaskBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'enqueueTask' });
          });
          
          // Handle responses from extension
          window.addEventListener('message', event => {
            const message = event.data;
            
            if (message.command === 'response') {
              // Add agent message to chat
              const agentMessage = document.createElement('div');
              agentMessage.className = 'message agent-message';
              agentMessage.textContent = message.text;
              chatContainer.appendChild(agentMessage);
              
              // Scroll to bottom
              chatContainer.scrollTop = chatContainer.scrollHeight;
            }
          });
        </script>
      </body>
      </html>
    `;
  }
}



==============================================
FILE: ./src/vscode-extension/src/views/CodeViewProvider.ts
==============================================

import * as vscode from 'vscode';

/**
 * Provider for the Code view
 */
export class CodeViewProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = 'thefuse.codeView';
  private _view?: vscode.WebviewView;

  constructor(
    private readonly _extensionUri: vscode.Uri,
    private readonly _extensionContext: vscode.ExtensionContext
  ) {}

  resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken,
  ) {
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    // Handle messages from the webview
    webviewView.webview.onDidReceiveMessage(message => {
      switch (message.command) {
        case 'generateCode':
          vscode.window.showInformationMessage(`Generating ${message.language} code...`);
          break;
        case 'refactorCode':
          vscode.window.showInformationMessage('Refactoring selected code...');
          break;
        case 'explainCode':
          vscode.window.showInformationMessage('Explaining selected code...');
          break;
      }
    });
  }

  private _getHtmlForWebview(webview: vscode.Webview): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Code</title>
        <style>
          body {
            padding: 10px;
            color: var(--vscode-foreground);
            font-family: var(--vscode-font-family);
          }
          .container {
            display: flex;
            flex-direction: column;
            gap: 10px;
          }
          button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 2px;
          }
          button:hover {
            background-color: var(--vscode-button-hoverBackground);
          }
          .code-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
          }
          .language-selector {
            margin-top: 10px;
            margin-bottom: 10px;
          }
          select {
            padding: 8px;
            background-color: var(--vscode-dropdown-background);
            color: var(--vscode-dropdown-foreground);
            border: 1px solid var(--vscode-dropdown-border);
            border-radius: 2px;
            width: 100%;
          }
          textarea {
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            padding: 8px;
            border-radius: 2px;
            min-height: 100px;
            font-family: monospace;
          }
          .section {
            margin-top: 15px;
          }
          h3 {
            margin-top: 0;
            margin-bottom: 10px;
          }
          .action-row {
            display: flex;
            gap: 8px;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <h2>Code Assistant</h2>
          <p>Generate, refactor, and explain code.</p>
          
          <div class="section">
            <h3>Generate Code</h3>
            <div class="language-selector">
              <select id="languageSelect">
                <option value="javascript">JavaScript</option>
                <option value="typescript">TypeScript</option>
                <option value="python">Python</option>
                <option value="java">Java</option>
                <option value="csharp">C#</option>
                <option value="go">Go</option>
                <option value="rust">Rust</option>
              </select>
            </div>
            <textarea id="codePrompt" placeholder="Describe the code you want to generate..."></textarea>
            <button id="generateBtn" style="margin-top: 8px;">Generate Code</button>
          </div>
          
          <div class="section">
            <h3>Code Actions</h3>
            <div class="code-actions">
              <p>Actions for selected code in editor:</p>
              <div class="action-row">
                <button id="refactorBtn">Refactor</button>
                <button id="explainBtn">Explain</button>
                <button id="optimizeBtn">Optimize</button>
              </div>
              <div class="action-row">
                <button id="documentBtn">Document</button>
                <button id="testBtn">Generate Tests</button>
                <button id="fixBtn">Fix Issues</button>
              </div>
            </div>
          </div>
          
          <div class="section">
            <h3>Recent Generations</h3>
            <ul id="recentGenerations">
              <li>JavaScript function to sort an array</li>
              <li>TypeScript interface for user data</li>
              <li>Python class for data processing</li>
            </ul>
          </div>
        </div>
        
        <script>
          const vscode = acquireVsCodeApi();
          
          document.getElementById('generateBtn').addEventListener('click', () => {
            const language = document.getElementById('languageSelect').value;
            const prompt = document.getElementById('codePrompt').value;
            
            if (prompt.trim()) {
              vscode.postMessage({
                command: 'generateCode',
                language: language,
                prompt: prompt
              });
            }
          });
          
          document.getElementById('refactorBtn').addEventListener('click', () => {
            vscode.postMessage({
              command: 'refactorCode'
            });
          });
          
          document.getElementById('explainBtn').addEventListener('click', () => {
            vscode.postMessage({
              command: 'explainCode'
            });
          });
          
          document.getElementById('optimizeBtn').addEventListener('click', () => {
            vscode.postMessage({
              command: 'optimizeCode'
            });
          });
          
          document.getElementById('documentBtn').addEventListener('click', () => {
            vscode.postMessage({
              command: 'documentCode'
            });
          });
          
          document.getElementById('testBtn').addEventListener('click', () => {
            vscode.postMessage({
              command: 'generateTests'
            });
          });
          
          document.getElementById('fixBtn').addEventListener('click', () => {
            vscode.postMessage({
              command: 'fixIssues'
            });
          });
        </script>
      </body>
      </html>
    `;
  }
}



==============================================
FILE: ./src/vscode-extension/src/views/DebugViewProvider.ts
==============================================

import * as vscode from 'vscode';

/**
 * Provider for the Debug view
 */
export class DebugViewProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = 'thefuse.debugView';
  private _view?: vscode.WebviewView;

  constructor(
    private readonly _extensionUri: vscode.Uri,
    private readonly _extensionContext: vscode.ExtensionContext
  ) {}

  resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken,
  ) {
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    webviewView.webview.onDidReceiveMessage(message => {
      switch (message.command) {
        case 'refreshDebugLogs':
          vscode.window.showInformationMessage('Refreshing debug logs...');
          break;
        case 'indexWorkspace':
          vscode.commands.executeCommand('thefuse.indexWorkspace');
          break;
        case 'searchCode':
          vscode.commands.executeCommand('thefuse.searchCode');
          break;
        case 'enqueueTask':
          vscode.commands.executeCommand('thefuse.enqueueTask');
          break;
      }
    });
  }

  private _getHtmlForWebview(webview: vscode.Webview): string {
    return `
      <!DOCTYPE html>
      <html>
      <body>
        <button id="refreshDebugLogs">Refresh Logs</button>
        <button id="indexWorkspaceBtn">Index Workspace</button>
        <button id="searchCodeBtn">Search Code</button>
        <button id="enqueueTaskBtn">Enqueue Task</button>
        <h2>Agent Debug Console</h2>
        <p>Monitor and debug agent-to-agent communication and tool execution.</p>
        
        <div class="controls">
          <button id="clearLogsBtn">Clear Logs</button>
          <button id="exportLogsBtn">Export Logs</button>
        </div>
        
        <h3>Message Traffic</h3>
        <div class="log-container" id="messageLog">
          <div class="log-entry">
            <div class="log-time">10:15:32</div>
            <div class="log-message">Agent 'CodeAssistant' initialized</div>
          </div>
          <div class="log-entry">
            <div class="log-time">10:15:35</div>
            <div class="log-message">Tool 'file-search' executed by 'CodeAssistant'</div>
          </div>
          <div class="log-entry">
            <div class="log-time">10:15:40</div>
            <div class="log-message">Message from 'CodeAssistant' to 'TestingAgent': Request code review</div>
          </div>
        </div>
        
        <h3>Tool Executions</h3>
        <div class="log-container" id="toolLog">
          <div class="log-entry">
            <div class="log-time">10:15:35</div>
            <div class="log-message">Tool: file-search</div>
            <div class="log-message">Args: {"pattern": "*.ts", "directory": "/src"}</div>
            <div class="log-message">Duration: 120ms</div>
          </div>
        </div>

        <script>
          const vscode = acquireVsCodeApi();
          document.getElementById('refreshDebugLogs').addEventListener('click', () => vscode.postMessage({ command: 'refreshDebugLogs' }));
          document.getElementById('indexWorkspaceBtn').addEventListener('click', () => vscode.postMessage({ command: 'indexWorkspace' }));
          document.getElementById('searchCodeBtn').addEventListener('click', () => vscode.postMessage({ command: 'searchCode' }));
          document.getElementById('enqueueTaskBtn').addEventListener('click', () => vscode.postMessage({ command: 'enqueueTask' }));
          
          document.getElementById('clearLogsBtn').addEventListener('click', () => {
            vscode.postMessage({
              command: 'clearLogs'
            });
            document.getElementById('messageLog').innerHTML = '';
            document.getElementById('toolLog').innerHTML = '';
          });
          
          document.getElementById('exportLogsBtn').addEventListener('click', () => {
            vscode.postMessage({
              command: 'exportLogs'
            });
          });
        </script>
      </body>
      </html>
    `;
  }
}



==============================================
FILE: ./src/vscode-extension/src/views/OrchestratorViewProvider.ts
==============================================

import * as vscode from 'vscode';

/**
 * Provider for the Orchestrator view
 */
export class OrchestratorViewProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = 'thefuse.orchestratorView';
  private _view?: vscode.WebviewView;

  constructor(
    private readonly _extensionUri: vscode.Uri,
    private readonly _extensionContext: vscode.ExtensionContext
  ) {}

  resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken,
  ) {
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    // Handle messages from the webview
    webviewView.webview.onDidReceiveMessage(message => {
      switch (message.command) {
        case 'startOrchestration':
          vscode.window.showInformationMessage('Starting agent orchestration...');
          // TODO: trigger orchestration logic
          break;
        case 'indexWorkspace':
          vscode.commands.executeCommand('thefuse.indexWorkspace');
          break;
        case 'searchCode':
          vscode.commands.executeCommand('thefuse.searchCode');
          break;
        case 'enqueueTask':
          vscode.commands.executeCommand('thefuse.enqueueTask');
          break;
      }
    });
  }

  private _getHtmlForWebview(webview: vscode.Webview): string {
    return `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Orchestrator</title>
        <style>
          body {
            padding: 10px;
            color: var(--vscode-foreground);
            font-family: var(--vscode-font-family);
          }
          .container {
            display: flex;
            flex-direction: column;
            gap: 10px;
          }
          button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 2px;
          }
          button:hover {
            background-color: var(--vscode-button-hoverBackground);
          }
          .agent-list {
            margin-top: 10px;
          }
          .agent-item {
            padding: 8px;
            border: 1px solid var(--vscode-panel-border);
            margin-bottom: 8px;
            border-radius: 4px;
          }
          h3 {
            margin-top: 0;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <h2>Agent Orchestration</h2>
          <p>Coordinate multiple AI agents to work together on complex tasks.</p>
          
          <button id="startOrchestrateBtn">Start New Orchestration</button>
          <button id="indexWorkspaceBtn">Index Workspace</button>
          <button id="searchCodeBtn">Search Code</button>
          <button id="enqueueTaskBtn">Enqueue Task</button>
          
          <h3>Available Agents</h3>
          <div class="agent-list">
            <div class="agent-item">
              <h4>Code Assistant</h4>
              <p>Specialized in code generation and refactoring</p>
            </div>
            <div class="agent-item">
              <h4>Documentation Agent</h4>
              <p>Creates and updates documentation</p>
            </div>
            <div class="agent-item">
              <h4>Testing Agent</h4>
              <p>Generates test cases and validates code</p>
            </div>
          </div>
          
          <h3>Active Orchestrations</h3>
          <div id="activeOrchestrations">
            <p>No active orchestrations</p>
          </div>
        </div>
        
        <script>
          const vscode = acquireVsCodeApi();
          
          document.getElementById('startOrchestrateBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'startOrchestration' });
          });
          document.getElementById('indexWorkspaceBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'indexWorkspace' });
          });
          document.getElementById('searchCodeBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'searchCode' });
          });
          document.getElementById('enqueueTaskBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'enqueueTask' });
          });
        </script>
      </body>
      </html>
    `;
  }
}



==============================================
FILE: ./src/vscode-extension/src/views/settings-view-provider.ts
==============================================

// Settings view provider for The New Fuse extension
import * as vscode from 'vscode';
import { LLMProvider } from '../../lm-api-bridge';

/**
 * Provider for the settings webview
 */
export class SettingsViewProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = 'thefuse.settingsView';
  private _view?: vscode.WebviewView;

  constructor(
    private readonly _extensionUri: vscode.Uri,
    private readonly _extensionContext: vscode.ExtensionContext
  ) {}

  resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken,
  ) {
    this._view = webviewView;

    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    // Handle messages from the webview
    webviewView.webview.onDidReceiveMessage(message => {
      switch (message.command) {
        case 'saveSettings':
          this._saveSettings(message.settings);
          break;
      }
    });

    // Update webview when configuration changes
    vscode.workspace.onDidChangeConfiguration(e => {
      if (e.affectsConfiguration('theFuse')) {
        this._updateWebview();
      }
    });
  }

  /**
   * Save settings to VS Code configuration
   */
  private _saveSettings(settings: any): void {
    const config = vscode.workspace.getConfiguration('theFuse');
    
    // Update settings
    for (const [key, value] of Object.entries(settings)) {
      config.update(key, value, vscode.ConfigurationTarget.Global);
    }

    vscode.window.showInformationMessage('The New Fuse settings saved successfully!');
  }

  /**
   * Update the webview content
   */
  private _updateWebview(): void {
    if (this._view) {
      this._view.webview.html = this._getHtmlForWebview(this._view.webview);
    }
  }

  /**
   * Get the current settings
   */
  private _getCurrentSettings(): any {
    const config = vscode.workspace.getConfiguration('theFuse');
    return {
      // LLM settings
      llmProvider: config.get('llmProvider', 'vscode'),
      vscodeModel: config.get('vscodeModel', 'copilot-chat.completion-gpt-4'),
      openAIModel: config.get('openAIModel', 'gpt-4'),
      anthropicModel: config.get('anthropicModel', 'claude-3-opus'),
      ollamaModel: config.get('ollamaModel', 'codellama'),
      customModelEndpoint: config.get('customModelEndpoint', ''),
      customModelAPIKey: config.get('customModelAPIKey', ''),
      
      // Chat settings
      enableChat: config.get('enableChat', true),
      defaultChatView: config.get('defaultChatView', 'panel'),
      chatPanelPosition: config.get('chatPanelPosition', 'smart'),
      chatFontSize: config.get('chatFontSize', 13),
      saveChatHistory: config.get('saveChatHistory', true),
      maxChatHistoryLength: config.get('maxChatHistoryLength', 50),
      
      // MCP settings
      mcpConfigPath: config.get('mcpConfigPath', ''),
      autoInitializeMcp: config.get('autoInitializeMcp', true),
      agentServerUrl: config.get('agentServerUrl', 'http://localhost:3000')
    };
  }

  /**
   * Generate the HTML for the webview
   */
  private _getHtmlForWebview(webview: vscode.Webview): string {
    // Get current settings
    const settings = this._getCurrentSettings();
    
    return `<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>The New Fuse Settings</title>
        <style>
            body {
                font-family: var(--vscode-font-family);
                font-size: var(--vscode-font-size);
                color: var(--vscode-foreground);
                padding: 20px;
                background-color: var(--vscode-editor-background);
            }
            h1 {
                font-size: 24px;
                margin-bottom: 20px;
                font-weight: 400;
                color: var(--vscode-settings-headerForeground);
                border-bottom: 1px solid var(--vscode-panel-border);
                padding-bottom: 10px;
            }
            h2 {
                font-size: 18px;
                margin-top: 30px;
                margin-bottom: 15px;
                font-weight: 400;
                color: var(--vscode-settings-headerForeground);
            }
            .section {
                margin-bottom: 30px;
            }
            .setting-group {
                margin-bottom: 20px;
                padding: 15px;
                background-color: var(--vscode-settings-rowHoverBackground);
                border-radius: 5px;
            }
            .form-row {
                margin-bottom: 15px;
            }
            label {
                display: block;
                margin-bottom: 6px;
                font-weight: 500;
            }
            select, input[type="text"], input[type="number"], input[type="password"] {
                width: 100%;
                padding: 8px;
                background-color: var(--vscode-input-background);
                color: var(--vscode-input-foreground);
                border: 1px solid var(--vscode-input-border);
                border-radius: 3px;
            }
            input[type="checkbox"] {
                margin-right: 8px;
            }
            button {
                background-color: var(--vscode-button-background);
                color: var(--vscode-button-foreground);
                border: none;
                padding: 8px 16px;
                border-radius: 3px;
                cursor: pointer;
                font-weight: 500;
                margin-top: 15px;
            }
            button:hover {
                background-color: var(--vscode-button-hoverBackground);
            }
            .provider-settings {
                padding: 10px;
                margin-top: 10px;
                border-left: 3px solid var(--vscode-activityBar-activeBorder);
                background-color: var(--vscode-editor-background);
            }
            .checkbox-setting {
                display: flex;
                align-items: center;
            }
            .checkbox-setting label {
                margin-bottom: 0;
                display: inline;
            }
            .description {
                font-size: 12px;
                color: var(--vscode-descriptionForeground);
                margin-top: 4px;
                margin-bottom: 8px;
            }
            .hidden {
                display: none;
            }
        </style>
    </head>
    <body>
        <h1>The New Fuse Settings</h1>
        
        <div class="section">
            <h2>🤖 Language Model Settings</h2>
            <div class="setting-group">
                <div class="form-row">
                    <label for="llmProvider">LLM Provider</label>
                    <div class="description">Select the AI provider for chat and code assistance</div>
                    <select id="llmProvider">
                        <option value="vscode" ${settings.llmProvider === 'vscode' ? 'selected' : ''}>VS Code LM API (GitHub Copilot)</option>
                        <option value="openai" ${settings.llmProvider === 'openai' ? 'selected' : ''}>OpenAI</option>
                        <option value="anthropic" ${settings.llmProvider === 'anthropic' ? 'selected' : ''}>Anthropic</option>
                        <option value="ollama" ${settings.llmProvider === 'ollama' ? 'selected' : ''}>Ollama (Local)</option>
                        <option value="custom" ${settings.llmProvider === 'custom' ? 'selected' : ''}>Custom</option>
                    </select>
                </div>
                
                <!-- VS Code LM API settings -->
                <div id="vscode-settings" class="provider-settings ${settings.llmProvider !== 'vscode' ? 'hidden' : ''}">
                    <div class="form-row">
                        <label for="vscodeModel">VS Code LM API Model</label>
                        <div class="description">Select which VS Code Language Model to use</div>
                        <select id="vscodeModel">
                            <option value="copilot-chat.completion-gpt-4" ${settings.vscodeModel === 'copilot-chat.completion-gpt-4' ? 'selected' : ''}>GPT-4 (Default)</option>
                            <option value="copilot-chat.completion-gpt-3.5-turbo" ${settings.vscodeModel === 'copilot-chat.completion-gpt-3.5-turbo' ? 'selected' : ''}>GPT-3.5 Turbo</option>
                            <option value="copilot-chat.generation" ${settings.vscodeModel === 'copilot-chat.generation' ? 'selected' : ''}>Copilot Code Generation</option>
                        </select>
                    </div>
                </div>
                
                <!-- OpenAI settings -->
                <div id="openai-settings" class="provider-settings ${settings.llmProvider !== 'openai' ? 'hidden' : ''}">
                    <div class="form-row">
                        <label for="openAIModel">OpenAI Model</label>
                        <select id="openAIModel">
                            <option value="gpt-4" ${settings.openAIModel === 'gpt-4' ? 'selected' : ''}>GPT-4</option>
                            <option value="gpt-4-turbo" ${settings.openAIModel === 'gpt-4-turbo' ? 'selected' : ''}>GPT-4 Turbo</option>
                            <option value="gpt-3.5-turbo" ${settings.openAIModel === 'gpt-3.5-turbo' ? 'selected' : ''}>GPT-3.5 Turbo</option>
                        </select>
                    </div>
                    <!-- API key would be added here in a full implementation -->
                </div>
                
                <!-- Anthropic settings -->
                <div id="anthropic-settings" class="provider-settings ${settings.llmProvider !== 'anthropic' ? 'hidden' : ''}">
                    <div class="form-row">
                        <label for="anthropicModel">Anthropic Model</label>
                        <select id="anthropicModel">
                            <option value="claude-3-opus" ${settings.anthropicModel === 'claude-3-opus' ? 'selected' : ''}>Claude 3 Opus</option>
                            <option value="claude-3-sonnet" ${settings.anthropicModel === 'claude-3-sonnet' ? 'selected' : ''}>Claude 3 Sonnet</option>
                            <option value="claude-3-haiku" ${settings.anthropicModel === 'claude-3-haiku' ? 'selected' : ''}>Claude 3 Haiku</option>
                        </select>
                    </div>
                    <!-- API key would be added here in a full implementation -->
                </div>
                
                <!-- Ollama settings -->
                <div id="ollama-settings" class="provider-settings ${settings.llmProvider !== 'ollama' ? 'hidden' : ''}">
                    <div class="form-row">
                        <label for="ollamaModel">Ollama Model</label>
                        <select id="ollamaModel">
                            <option value="codellama" ${settings.ollamaModel === 'codellama' ? 'selected' : ''}>CodeLlama</option>
                            <option value="llama3" ${settings.ollamaModel === 'llama3' ? 'selected' : ''}>Llama 3</option>
                            <option value="mistral" ${settings.ollamaModel === 'mistral' ? 'selected' : ''}>Mistral</option>
                            <option value="phi" ${settings.ollamaModel === 'phi' ? 'selected' : ''}>Phi</option>
                            <option value="gemma" ${settings.ollamaModel === 'gemma' ? 'selected' : ''}>Gemma</option>
                        </select>
                    </div>
                </div>
                
                <!-- Custom settings -->
                <div id="custom-settings" class="provider-settings ${settings.llmProvider !== 'custom' ? 'hidden' : ''}">
                    <div class="form-row">
                        <label for="customModelEndpoint">Custom Model Endpoint</label>
                        <input type="text" id="customModelEndpoint" value="${settings.customModelEndpoint}" placeholder="https://api.example.com/v1/chat/completions">
                    </div>
                    <div class="form-row">
                        <label for="customModelAPIKey">API Key</label>
                        <input type="password" id="customModelAPIKey" value="${settings.customModelAPIKey}" placeholder="Your API key">
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>💬 Chat Interface Settings</h2>
            <div class="setting-group">
                <div class="form-row checkbox-setting">
                    <input type="checkbox" id="enableChat" ${settings.enableChat ? 'checked' : ''}>
                    <label for="enableChat">Enable Chat Interface</label>
                </div>
                <div class="description">Show or hide the chat interface in The New Fuse</div>
                
                <div class="form-row">
                    <label for="defaultChatView">Default Chat View</label>
                    <select id="defaultChatView">
                        <option value="panel" ${settings.defaultChatView === 'panel' ? 'selected' : ''}>Panel (Copilot-like)</option>
                        <option value="sidebar" ${settings.defaultChatView === 'sidebar' ? 'selected' : ''}>Sidebar</option>
                    </select>
                </div>
                
                <div class="form-row">
                    <label for="chatPanelPosition">Chat Panel Position</label>
                    <select id="chatPanelPosition">
                        <option value="smart" ${settings.chatPanelPosition === 'smart' ? 'selected' : ''}>Smart (Auto-position)</option>
                        <option value="beside" ${settings.chatPanelPosition === 'beside' ? 'selected' : ''}>Beside Editor</option>
                        <option value="active" ${settings.chatPanelPosition === 'active' ? 'selected' : ''}>Replace Editor</option>
                    </select>
                </div>
                
                <div class="form-row">
                    <label for="chatFontSize">Chat Font Size (px)</label>
                    <input type="number" id="chatFontSize" value="${settings.chatFontSize}" min="10" max="24">
                </div>
                
                <div class="form-row checkbox-setting">
                    <input type="checkbox" id="saveChatHistory" ${settings.saveChatHistory ? 'checked' : ''}>
                    <label for="saveChatHistory">Save Chat History</label>
                </div>
                
                <div class="form-row">
                    <label for="maxChatHistoryLength">Max Chat History Length</label>
                    <input type="number" id="maxChatHistoryLength" value="${settings.maxChatHistoryLength}" min="10" max="1000">
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>🔧 MCP Integration Settings</h2>
            <div class="setting-group">
                <div class="form-row">
                    <label for="mcpConfigPath">MCP Configuration Path</label>
                    <input type="text" id="mcpConfigPath" value="${settings.mcpConfigPath}" placeholder="Path to MCP config file">
                </div>
                
                <div class="form-row checkbox-setting">
                    <input type="checkbox" id="autoInitializeMcp" ${settings.autoInitializeMcp ? 'checked' : ''}>
                    <label for="autoInitializeMcp">Auto-initialize MCP</label>
                </div>
                
                <div class="form-row">
                    <label for="agentServerUrl">Agent Server URL</label>
                    <input type="text" id="agentServerUrl" value="${settings.agentServerUrl}" placeholder="http://localhost:3000">
                </div>
            </div>
        </div>
        
        <button id="saveBtn">Save Settings</button>
        
        <script>
            (function() {
                const vscode = acquireVsCodeApi();
                
                // Elements
                const llmProviderSelect = document.getElementById('llmProvider');
                const vscodeSettings = document.getElementById('vscode-settings');
                const openaiSettings = document.getElementById('openai-settings');
                const anthropicSettings = document.getElementById('anthropic-settings');
                const ollamaSettings = document.getElementById('ollama-settings');
                const customSettings = document.getElementById('custom-settings');
                const saveBtn = document.getElementById('saveBtn');
                
                // Show/hide provider settings based on selection
                llmProviderSelect.addEventListener('change', () => {
                    const provider = llmProviderSelect.value;
                    
                    vscodeSettings.classList.toggle('hidden', provider !== 'vscode');
                    openaiSettings.classList.toggle('hidden', provider !== 'openai');
                    anthropicSettings.classList.toggle('hidden', provider !== 'anthropic');
                    ollamaSettings.classList.toggle('hidden', provider !== 'ollama');
                    customSettings.classList.toggle('hidden', provider !== 'custom');
                });
                
                // Save settings
                saveBtn.addEventListener('click', () => {
                    const settings = {
                        // LLM settings
                        llmProvider: document.getElementById('llmProvider').value,
                        vscodeModel: document.getElementById('vscodeModel').value,
                        openAIModel: document.getElementById('openAIModel').value,
                        anthropicModel: document.getElementById('anthropicModel').value,
                        ollamaModel: document.getElementById('ollamaModel').value,
                        customModelEndpoint: document.getElementById('customModelEndpoint').value,
                        customModelAPIKey: document.getElementById('customModelAPIKey').value,
                        
                        // Chat settings
                        enableChat: document.getElementById('enableChat').checked,
                        defaultChatView: document.getElementById('defaultChatView').value,
                        chatPanelPosition: document.getElementById('chatPanelPosition').value,
                        chatFontSize: parseInt(document.getElementById('chatFontSize').value, 10),
                        saveChatHistory: document.getElementById('saveChatHistory').checked,
                        maxChatHistoryLength: parseInt(document.getElementById('maxChatHistoryLength').value, 10),
                        
                        // MCP settings
                        mcpConfigPath: document.getElementById('mcpConfigPath').value,
                        autoInitializeMcp: document.getElementById('autoInitializeMcp').checked,
                        agentServerUrl: document.getElementById('agentServerUrl').value
                    };
                    
                    vscode.postMessage({
                        command: 'saveSettings',
                        settings
                    });
                });
            }());
        </script>
    </body>
    </html>`;
  }

  /**
   * Public method to open settings
   */
  public openSettings() {
    if (this._view) {
      this._view.show(true);
    }
  }
}


==============================================
FILE: ./src/vscode-extension/start-communication-hub.sh
==============================================

#!/bin/bash

# Create necessary directories
mkdir -p out
mkdir -p web-ui
mkdir -p ai-communication

echo "Copying core modules to make them available..."
cp web-ui/communication-panel.ts web-ui/ 2>/dev/null || echo "WARNING: No communication panel found - creating skeleton"
cp mcp-protocol.ts . 2>/dev/null || echo "WARNING: No MCP protocol found - creating skeleton"

# Creating necessary stub files if they don't exist
if [ ! -f "web-ui/communication-panel.ts" ]; then
  echo "Creating basic communication panel module"
  cat > web-ui/communication-panel.ts << EOF
import * as vscode from 'vscode';

export class CommunicationPanel {
  public static createOrShow(extensionUri: vscode.Uri) {
    const panel = vscode.window.createWebviewPanel(
      'aiCommunicationHub',
      'AI Communication Hub',
      vscode.ViewColumn.One,
      { enableScripts: true }
    );
    panel.webview.html = '<h1>AI Communication Hub</h1><p>This is a placeholder for the AI Communication Hub</p>';
  }
}
EOF
fi

# Ensure the out directory exists and contains a compiled version
echo "Compiling TypeScript files..."
npm run compile

echo "Starting the AI Communication Hub..."
code --extensionDevelopmentPath="$(pwd)" --args --debugPluginHost



==============================================
FILE: ./src/vscode-extension/start-here.sh
==============================================

#!/bin/bash

echo "======================================================"
echo "  The New Fuse - Quick Extension Setup"
echo "======================================================"
echo ""

# Create necessary directory structure
mkdir -p out
mkdir -p test
mkdir -p web-ui
mkdir -p .vscode
mkdir -p ai-communication # For file-based inter-extension communication

# Create a minimal basic extension.js if it doesn't exist
if [ ! -f "out/extension.js" ]; then
  echo "Creating minimal extension..."
  cat > out/extension.js << 'EOF'
const vscode = require('vscode');

function activate(context) {
  console.log('The New Fuse extension is active!');
  
  // Register a simple command to test
  const helloCommand = vscode.commands.registerCommand('thefuse.helloWorld', () => {
    vscode.window.showInformationMessage('Hello from The New Fuse!');
  });
  
  const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 0);
  statusBarItem.text = "$(rocket) The New Fuse";
  statusBarItem.tooltip = "The New Fuse AI Tools";
  statusBarItem.command = 'thefuse.helloWorld';
  statusBarItem.show();
  
  context.subscriptions.push(helloCommand, statusBarItem);
}

function deactivate() {}

module.exports = { activate, deactivate };
EOF
fi

# Create package.json if it doesn't exist
if [ ! -f "package.json" ]; then
  echo "Creating package.json..."
  cat > package.json << 'EOF'
{
  "name": "the-new-fuse-vscode",
  "displayName": "The New Fuse",
  "description": "AI agent coordination and workflow automation for VS Code",
  "version": "0.1.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "main": "./out/extension.js",
  "activationEvents": ["onStartupFinished"],
  "contributes": {
    "commands": [
      {
        "command": "thefuse.helloWorld",
        "title": "Hello from The New Fuse"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "lint": "eslint src --ext ts"
  },
  "dependencies": {
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.2.5",
    "@types/uuid": "^9.0.1",
    "@types/vscode": "^1.80.0",
    "typescript": "^5.1.3"
  }
}
EOF
fi

# Launch VS Code with the extension
echo "Ready to run the extension in VS Code!"
echo "Choose an option:"
echo "1) Launch VS Code with the extension"
echo "2) Just install dependencies (no launch)"
read -p "Enter choice (1/2): " choice

case $choice in
  1)
    # Launch VS Code with the extension
    echo "Launching VS Code with the extension..."
    code --extensionDevelopmentPath="$(pwd)"
    ;;
  2)
    echo "Installing dependencies only..."
    npm install
    ;;
  *)
    echo "Invalid choice! Run one of these commands manually:"
    echo "- code --extensionDevelopmentPath=\"$(pwd)\""
    echo "- npm install"
    ;;
esac



==============================================
FILE: ./src/vscode-extension/startup.tsx
==============================================

/**
 * Startup module for The New Fuse extension
 * 
 * This file provides quick-start functionality to make the extension
 * easily accessible for immediate testing.
 */

import * as vscode from 'vscode';

/**
 * Show quick-start welcome and feature suggestions
 */
export function showWelcomeMessage(context: vscode.ExtensionContext): any {
  // Check if we've shown the welcome message before
  const hasShownWelcome = context.globalState.get('thefuse.hasShownWelcome', false);
  
  if (!hasShownWelcome) {
    // Show welcome message with quick actions
    vscode.window.showInformationMessage(
      'The New Fuse is now active! Try out the AI collaboration features.', 
      'Show AI Agents', 
      'Start Collaboration',
      'Read Quick Start'
    ).then(selection => {
      if (selection === 'Show AI Agents') {
        vscode.commands.executeCommand('llm-orchestrator.showAgents');
      } else if (selection === 'Start Collaboration') {
        vscode.commands.executeCommand('thefuse.startAICollab');
      } else if (selection === 'Read Quick Start') {
        // Open the quick start guide
        vscode.workspace.openTextDocument(
          vscode.Uri.file(context.extensionPath + '/QUICK-START.md')
        ).then(doc => {
          vscode.window.showTextDocument(doc);
        });
      }
    });
    
    // Mark that we've shown the welcome message
    context.globalState.update('thefuse.hasShownWelcome', true);
  }
  
  // Create and show an interactive walkthrough for first-time users
  const walkthrough = vscode.window.createWebviewPanel(
    'fuseWalkthrough',
    'The New Fuse - Interactive Walkthrough',
    vscode.ViewColumn.Active,
    {
      enableScripts: true,
      retainContextWhenHidden: true
    }
  );
  
  walkthrough.webview.html = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; padding: 20px; }
        .step { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        button { background: #007acc; color: white; border: none; padding: 8px 12px; border-radius: 3px; cursor: pointer; }
        button:hover { background: #005999; }
        .completed { background-color: #e6ffed; border-color: #b4ecb4; }
        .reload-notice { background-color: #fffbe6; border: 1px solid #fff5c2; padding: 10px; margin-bottom: 20px; border-radius: 5px; }
      </style>
    </head>
    <body>
      <div class="reload-notice">
        <h3>📣 Extension Activation</h3>
        <p>If you don't see the extension icons in the status bar, reload your window:</p>
        <button onclick="runCommand('workbench.action.reloadWindow')">Reload Window</button>
      </div>
      
      <h1>Get Started with The New Fuse</h1>
      <p>Follow these steps to try out the inter-extension communication features:</p>
      
      <div class="step" id="step1">
        <h3>Step 1: Discover AI Agents</h3>
        <p>First, let's discover which AI extensions are available in your VS Code.</p>
        <button onclick="runCommand('llm-orchestrator.discoverAgents')">Discover AI Agents</button>
      </div>
      
      <div class="step" id="step2">
        <h3>Step 2: View Available Agents</h3>
        <p>Now, let's see which agents were discovered.</p>
        <button onclick="runCommand('llm-orchestrator.showAgents')">Show AI Agents</button>
      </div>
      
      <div class="step" id="step3">
        <h3>Step 3: Try Collaborative Completion</h3>
        <p>Enable collaborative completion to see multiple AI agents work together on suggestions.</p>
        <button onclick="runCommand('thefuse.toggleCollaborativeCompletion')">Toggle Collaborative Completion</button>
      </div>
      
      <div class="step" id="step4">
        <h3>Step 4: Start AI Collaboration</h3>
        <p>Try a full AI collaboration workflow with multiple specialized agents.</p>
        <button onclick="runCommand('thefuse.startAICollab')">Start AI Collaboration</button>
      </div>
      
      <div class="step" id="step5">
        <h3>Step 5: Open the Example Code</h3>
        <p>Open our example code to try optimization and analysis features.</p>
        <button onclick="openExampleCode()">Open Example Code</button>
      </div>
      
      <script>
        const vscode = acquireVsCodeApi();
        
        function runCommand(command): any {
          vscode.postMessage({
            command: 'executeCommand',
            value: command
          });
          
          document.getElementById(getStepId(command)).classList.add('completed');
        }
        
        function openExampleCode(): any {
          vscode.postMessage({
            command: 'openFile',
            value: 'test/example-code.ts'
          });
          
          document.getElementById('step5').classList.add('completed');
        }
        
        function getStepId(command): any {
          const commandToStepMap = {
            'llm-orchestrator.discoverAgents': 'step1',
            'llm-orchestrator.showAgents': 'step2',
            'thefuse.toggleCollaborativeCompletion': 'step3',
            'thefuse.startAICollab': 'step4'
          };
          return commandToStepMap[command] || '';
        }
      </script>
    </body>
    </html>
  `;
  
  // Handle messages from the webview
  walkthrough.webview.onDidReceiveMessage(
    message => {
      switch (message.command) {
        case 'executeCommand':
          vscode.commands.executeCommand(message.value);
          break;
          
        case 'openFile':
          const filePath = vscode.Uri.file(context.extensionPath + '/' + message.value);
          vscode.workspace.openTextDocument(filePath)
            .then(doc => vscode.window.showTextDocument(doc));
          break;
      }
    },
    undefined,
    context.subscriptions
  );
}



==============================================
FILE: ./src/vscode-extension/test/example-code.ts
==============================================

/**
 * Example code file for testing AI collaboration features
 */

// A simple function with some performance issues to optimize
function findDuplicates(array: number[]): number[] {
  const duplicates: number[] = [];
  
  // Inefficient algorithm - O(n²) complexity
  for (let i = 0; i < array.length; i++) {
    for (let j = i + 1; j < array.length; j++) {
      if (array[i] === array[j] && !duplicates.includes(array[i])) {
        duplicates.push(array[i]);
      }
    }
  }
  
  return duplicates;
}

// Poorly documented class that needs improvement
class DataProcessor {
  private data: any[];
  
  constructor(initialData: any[]) {
    this.data = initialData;
  }
  
  process() {
    let result = [];
    for (let i = 0; i < this.data.length; i++) {
      let item = this.data[i];
      if (item && typeof item === 'object') {
        result.push({
          id: item.id || Math.random().toString(36).substr(2, 9),
          value: item.value,
          processed: true,
          timestamp: Date.now()
        });
      }
    }
    return result;
  }
  
  filter(predicate: (item: any) => boolean) {
    return this.data.filter(predicate);
  }
  
  transform(transformer: (item: any) => any) {
    return this.data.map(transformer);
  }
}

// Export the components
export { findDuplicates, DataProcessor };



==============================================
FILE: ./src/vscode-extension/transports/file-transport.tsx
==============================================

import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs/promises';
import { MessageTransport } from '../interfaces/message-transport';
import { AgentMessage } from '../agent-communication';

export class FileTransport implements MessageTransport {
    private readonly communicationDir: string;
    private fileWatcher: vscode.FileSystemWatcher | null = null;
    private handlers: ((message: AgentMessage) => Promise<void>)[] = [];

    constructor(workspaceRoot: string) {
        this.communicationDir = path.join(workspaceRoot, '.thefuse', 'communication');
    }

    async initialize(): Promise<void> {
        await fs.mkdir(this.communicationDir, { recursive: true });
        this.setupFileWatcher();
    }

    async sendMessage(message: AgentMessage): Promise<boolean> {
        try {
            const fileName = `${Date.now()}-${message.id}.json`;
            const filePath = path.join(this.communicationDir, fileName);
            await fs.writeFile(filePath, JSON.stringify(message, null, 2));
            return true;
        } catch (error) {
            console.error('Failed to send message via file:', error);
            return false;
        }
    }

    subscribeToMessages(callback: (message: AgentMessage) => Promise<void>): vscode.Disposable {
        this.handlers.push(callback);
        return new vscode.Disposable(() => {
            this.handlers = this.handlers.filter(h => h !== callback);
        });
    }

    private setupFileWatcher() {
        const pattern = new vscode.RelativePattern(this.communicationDir, '*.json');
        this.fileWatcher = vscode.workspace.createFileSystemWatcher(pattern);

        this.fileWatcher.onDidCreate(async (uri) => {
            await this.handleMessageFile(uri);
        });
    }

    private async handleMessageFile(uri: vscode.Uri) {
        try {
            const content = await fs.readFile(uri.fsPath, 'utf-8');
            const message: AgentMessage = JSON.parse(content);

            for (const handler of this.handlers) {
                await handler(message);
            }

            // Archive processed message
            const archivePath = path.join(this.communicationDir, 'archived');
            await fs.mkdir(archivePath, { recursive: true });
            await fs.rename(uri.fsPath, path.join(archivePath, path.basename(uri.fsPath)));
        } catch (error) {
            console.error('Error handling message file:', error);
        }
    }

    dispose(): void {
        if (this.fileWatcher) {
            this.fileWatcher.dispose();
            this.fileWatcher = null;
        }
    }
}


==============================================
FILE: ./src/vscode-extension/transports/workspace-state-transport.tsx
==============================================

import * as vscode from 'vscode';
import { MessageTransport } from '../interfaces/message-transport';
import { AgentMessage } from '../agent-communication';

// Define an interface for AgentMessage with the processed property
interface ProcessedAgentMessage extends AgentMessage {
    processed?: boolean;
}

export class WorkspaceStateTransport implements MessageTransport {
    private readonly context: vscode.ExtensionContext;
    private readonly messageKey = 'thefuse.messages';
    private pollInterval: ReturnType<typeof setInterval> | null = null;

    constructor(context: vscode.ExtensionContext) {
        this.context = context;
    }

    async initialize(): Promise<void> {
        this.startPolling();
    }

    async sendMessage(message: AgentMessage): Promise<boolean> {
        try {
            const messages = this.context.workspaceState.get<AgentMessage[]>(this.messageKey, []);
            messages.push(message);
            await this.context.workspaceState.update(this.messageKey, messages);
            return true;
        } catch (error) {
            console.error('Failed to send message via workspace state:', error);
            return false;
        }
    }

    subscribeToMessages(callback: (message: AgentMessage) => Promise<void>): vscode.Disposable {
        const handler = async () => {
            const messages = this.context.workspaceState.get<ProcessedAgentMessage[]>(this.messageKey, []);
            const unprocessedMessages = messages.filter(m => !m.processed);
            
            for (const message of unprocessedMessages) {
                await callback(message);
                message.processed = true;
            }
            
            await this.context.workspaceState.update(this.messageKey, messages);
        };

        this.startPolling(handler);

        return new vscode.Disposable(() => {
            if (this.pollInterval) {
                clearInterval(this.pollInterval);
                this.pollInterval = null;
            }
        });
    }

    private startPolling(handler?: () => Promise<void>) {
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
        }

        if (handler) {
            this.pollInterval = setInterval(handler, 1000);
        }
    }

    dispose(): void {
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
            this.pollInterval = null;
        }
    }
}


==============================================
FILE: ./src/vscode-extension/tsconfig.json
==============================================

{
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2020",
    "outDir": "out",
    "lib": ["ES2020", "DOM"],
    "sourceMap": true,
    "rootDir": ".",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "jsx": "react-jsx"
  },
  "include": ["src/**/*", "*.ts", "*.tsx"],
  "exclude": ["node_modules", ".vscode-test", "web-ui"]
}



==============================================
FILE: ./src/vscode-extension/utilities.ts
==============================================

/**
 * Utility functions for The New Fuse VSCode Extension
 */

/**
 * Safely get error message from any error object
 * This handles the TypeScript 'unknown' type for errors in catch blocks
 * 
 * @param error Any error object (including unknown type)
 * @returns A string message for the error
 */
export function getErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  }
  return String(error);
}

/**
 * Safely get error name and message
 * 
 * @param error Any error object (including unknown type)
 * @returns An object containing name and message properties
 */
export function getErrorDetails(error: unknown): { name: string; message: string } {
  if (error instanceof Error) {
    return {
      name: error.name,
      message: error.message
    };
  }
  return {
    name: 'Unknown Error',
    message: String(error)
  };
}


==============================================
FILE: ./src/vscode-extension/web-ui/chat-ui.css
==============================================

/* Modern Chat UI Styles */
:root {
    --fuse-primary: var(--vscode-button-background);
    --fuse-secondary: var(--vscode-button-hoverBackground);
    --fuse-accent: var(--vscode-activityBarBadge-background);
    --fuse-border: var(--vscode-panel-border, var(--vscode-divider-background));
    --fuse-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    --fuse-radius: 8px;
    --fuse-transition: all 0.2s ease;
}

/* General styles */
body {
    padding: 0;
    margin: 0;
    font-family: var(--vscode-font-family);
    font-size: var(--vscode-font-size);
    color: var(--vscode-foreground);
    background-color: var(--vscode-sideBar-background, var(--vscode-editor-background));
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
}

.chat-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    position: relative;
}

/* Header styles */
.chat-header {
    display: flex;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid var(--fuse-border);
    background-color: var(--vscode-sideBar-background, var(--vscode-editor-background));
    gap: 10px;
    z-index: 10;
}

.session-dropdown {
    flex-grow: 1;
    min-width: 150px;
    border-radius: var(--fuse-radius);
}

.header-button {
    transition: var(--fuse-transition);
    border-radius: var(--fuse-radius);
}

.header-button:hover {
    transform: translateY(-2px);
}

/* Message list styles */
.message-list {
    flex-grow: 1;
    overflow-y: auto;
    padding: 16px;
    background-color: var(--vscode-editor-background);
    scroll-behavior: smooth;
}

.message-container {
    margin-bottom: 20px;
    max-width: 85%;
    word-wrap: break-word;
    position: relative;
    animation: message-fade-in 0.3s ease-out;
    transition: var(--fuse-transition);
}

@keyframes message-fade-in {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.message-user {
    background-color: var(--fuse-primary);
    color: var(--vscode-button-foreground);
    margin-left: auto;
    border-radius: var(--fuse-radius) 0 var(--fuse-radius) var(--fuse-radius);
    padding: 12px 16px;
    box-shadow: var(--fuse-shadow);
}

.message-assistant {
    background-color: var(--vscode-editorWidget-background, var(--vscode-textCodeBlock-background));
    border: 1px solid var(--fuse-border);
    margin-right: auto;
    border-radius: 0 var(--fuse-radius) var(--fuse-radius) var(--fuse-radius);
    padding: 12px 16px;
    box-shadow: var(--fuse-shadow);
}

.message-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-size: 0.85em;
    color: var(--vscode-descriptionForeground);
}

.message-header .role {
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 6px;
}

.role-icon {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
}

.user-icon {
    background-color: var(--fuse-primary);
    color: var(--vscode-button-foreground);
}

.assistant-icon {
    background-color: var(--fuse-accent);
    color: var(--vscode-activityBarBadge-foreground);
}

.message-timestamp {
    font-size: 0.8em;
    opacity: 0.7;
}

.message-content {
    white-space: pre-wrap;
    line-height: 1.5;
}

/* Message actions */
.message-actions {
    position: absolute;
    top: 8px;
    right: 8px;
    display: none;
    gap: 4px;
    background-color: var(--vscode-editor-background);
    border-radius: 4px;
    padding: 2px;
    box-shadow: var(--fuse-shadow);
}

.message-container:hover .message-actions {
    display: flex;
}

.action-button {
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    color: var(--vscode-foreground);
    opacity: 0.7;
    transition: var(--fuse-transition);
}

.action-button:hover {
    opacity: 1;
    background-color: var(--vscode-list-hoverBackground);
}

/* Code formatting */
.message-content code {
    font-family: var(--vscode-editor-font-family);
    background: var(--vscode-textCodeBlock-background);
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-size: 0.9em;
}

.message-content pre {
    background: var(--vscode-textCodeBlock-background);
    padding: 16px;
    border-radius: var(--fuse-radius);
    overflow-x: auto;
    margin: 12px 0;
    font-family: var(--vscode-editor-font-family);
    font-size: 0.9em;
    position: relative;
}

.message-content pre code {
    padding: 0;
    background: none;
    border-radius: 0;
}

.copy-code-button {
    position: absolute;
    top: 8px;
    right: 8px;
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    opacity: 0;
    transition: var(--fuse-transition);
}

.message-content pre:hover .copy-code-button {
    opacity: 1;
}

.message-content strong {
    font-weight: bold;
}

.message-content em {
    font-style: italic;
}

/* Loading indicator */
.loading-indicator {
    display: flex;
    justify-content: center;
    padding: 16px;
}

.typing-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 12px 16px;
    background-color: var(--vscode-editorWidget-background);
    border-radius: var(--fuse-radius);
    margin-bottom: 16px;
    max-width: 100px;
}

.typing-dot {
    width: 8px;
    height: 8px;
    background-color: var(--vscode-foreground);
    border-radius: 50%;
    opacity: 0.6;
    animation: typing-animation 1.4s infinite ease-in-out;
}

.typing-dot:nth-child(1) { animation-delay: 0s; }
.typing-dot:nth-child(2) { animation-delay: 0.2s; }
.typing-dot:nth-child(3) { animation-delay: 0.4s; }

@keyframes typing-animation {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-6px); }
}

/* Welcome message */
.welcome-message {
    text-align: center;
    padding: 40px 20px;
    color: var(--vscode-descriptionForeground);
    display: flex;
    flex-direction: column;
    align-items: center;
    animation: fade-in 0.5s ease-out;
}

@keyframes fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
}

.welcome-message h2 {
    margin-bottom: 16px;
    font-size: 1.4em;
    font-weight: 500;
}

.welcome-logo {
    font-size: 48px;
    margin-bottom: 20px;
    background-color: var(--fuse-primary);
    color: var(--vscode-button-foreground);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: var(--fuse-shadow);
}

.welcome-suggestions {
    margin-top: 30px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    max-width: 500px;
}

.suggestion-button {
    background-color: var(--vscode-editorWidget-background);
    border: 1px solid var(--fuse-border);
    border-radius: var(--fuse-radius);
    padding: 10px 16px;
    text-align: left;
    cursor: pointer;
    transition: var(--fuse-transition);
}

.suggestion-button:hover {
    background-color: var(--vscode-list-hoverBackground);
    transform: translateY(-2px);
}

.message-content em {
    font-style: italic;
}

/* Loading indicator */
.loading-indicator {
    display: flex;
    justify-content: center;
    padding: 10px;
}

/* Welcome message */
.welcome-message {
    text-align: center;
    padding: 40px 20px;
    color: var(--vscode-descriptionForeground);
}

.welcome-message h2 {
    margin-bottom: 10px;
    font-size: 1.2em;
}

/* Input area styles */
.input-area {
    display: flex;
    flex-direction: column;
    padding: 16px;
    border-top: 1px solid var(--fuse-border);
    background-color: var(--vscode-sideBar-background, var(--vscode-editor-background));
    z-index: 10;
}

.input-container {
    position: relative;
    display: flex;
    flex-direction: column;
}

.message-input {
    flex-grow: 1;
    border-radius: var(--fuse-radius);
    resize: none;
    padding: 12px;
    padding-right: 40px;
    min-height: 24px;
    max-height: 200px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    font-family: var(--vscode-font-family);
    font-size: var(--vscode-font-size);
    line-height: 1.5;
    transition: var(--fuse-transition);
}

.message-input:focus {
    outline: none;
    border-color: var(--fuse-primary);
    box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.2);
}

.send-button {
    position: absolute;
    bottom: 8px;
    right: 8px;
    background-color: var(--fuse-primary);
    color: var(--vscode-button-foreground);
    border: none;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: var(--fuse-transition);
}

.send-button:hover {
    background-color: var(--fuse-secondary);
    transform: scale(1.05);
}

.send-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.input-actions {
    display: flex;
    justify-content: space-between;
    margin-top: 8px;
}

.input-options {
    display: flex;
    gap: 8px;
}

.option-button {
    background: transparent;
    border: none;
    color: var(--vscode-foreground);
    opacity: 0.7;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    transition: var(--fuse-transition);
}

.option-button:hover {
    opacity: 1;
    background-color: var(--vscode-list-hoverBackground);
}

.model-selector {
    font-size: 12px;
    color: var(--vscode-descriptionForeground);
}

/* Responsive adjustments */
@media (max-width: 480px) {
    .message-container {
        max-width: 95%;
    }

    .welcome-suggestions {
        max-width: 100%;
    }
}


==============================================
FILE: ./src/vscode-extension/web-ui/chat-ui.js
==============================================

// @ts-check

(function () {
    // @ts-ignore
    const vscode = acquireVsCodeApi();

    // Get references to elements
    const messageList = document.getElementById('message-list');
    const messageInput = document.getElementById('message-input'); // vscode-text-area
    const sendButton = document.getElementById('send-button'); // vscode-button
    const sessionSelect = document.getElementById('session-select'); // vscode-dropdown
    const newChatButton = document.getElementById('new-chat-button'); // vscode-button
    const clearChatButton = document.getElementById('clear-chat-button'); // vscode-button
    const loadingIndicator = document.getElementById('loading-indicator');

    // --- State --- 
    let isSending = false;

    // --- Functions --- 

    /**
     * Scrolls the message list to the bottom.
     */
    function scrollToBottom() {
        if (messageList) {
            messageList.scrollTop = messageList.scrollHeight;
        }
    }

    /**
     * Sends the message from the input field.
     */
    function sendMessage() {
        if (!messageInput || !sendButton || isSending) return;

        // @ts-ignore
        const text = messageInput.value.trim();
        if (text) {
            isSending = true;
            updateSendButtonState();
            vscode.postMessage({
                command: 'sendMessage',
                text: text
            });
            // @ts-ignore
            messageInput.value = ''; // Clear the input field
        }
    }

    /**
     * Updates the enabled/disabled state of the send button.
     */
    function updateSendButtonState() {
        if (!messageInput || !sendButton) return;
        // @ts-ignore
        const text = messageInput.value.trim();
        // @ts-ignore
        sendButton.disabled = text === '' || isSending;
    }

    /**
     * Shows or hides the loading indicator.
     * @param {boolean} show 
     */
    function setLoading(show) {
        if (loadingIndicator) {
            loadingIndicator.style.display = show ? 'flex' : 'none';
            if (show) {
                scrollToBottom(); // Scroll down when loading starts
            }
        }
        isSending = show; // Update sending state based on loading indicator
        updateSendButtonState();
    }

    // --- Event Listeners --- 

    // Send button click
    if (sendButton) {
        sendButton.addEventListener('click', sendMessage);
    }

    // Message input events
    if (messageInput) {
        // @ts-ignore
        messageInput.addEventListener('input', updateSendButtonState);
        // @ts-ignore
        messageInput.addEventListener('keydown', (e) => {
            // Send on Enter (but not Shift+Enter)
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent newline
                sendMessage();
            }
        });
    }

    // New chat button click
    if (newChatButton) {
        newChatButton.addEventListener('click', () => {
            vscode.postMessage({ command: 'newChat' });
        });
    }

    // Clear chat button click
    if (clearChatButton) {
        clearChatButton.addEventListener('click', () => {
            // Optional: Add a confirmation dialog here
            vscode.postMessage({ command: 'clearChat' });
        });
    }

    // Session select change
    if (sessionSelect) {
        // @ts-ignore
        sessionSelect.addEventListener('change', (event) => {
            // @ts-ignore
            const selectedValue = event.target.value;
            if (selectedValue) {
                vscode.postMessage({
                    command: 'selectSession',
                    sessionId: selectedValue
                });
            }
        });
    }

    // Handle messages from the extension
    window.addEventListener('message', event => {
        const message = event.data; // The JSON data our extension sent
        switch (message.command) {
            case 'showLoading':
                setLoading(true);
                break;
            case 'hideLoading':
                setLoading(false);
                // The webview should be updated by the extension sending new HTML
                // But we ensure scroll happens after potential DOM updates
                setTimeout(scrollToBottom, 50); 
                break;
            // Add other cases as needed, e.g., 'updateMessages', 'updateSessions'
            // if not relying solely on full HTML updates.
        }
    });

    // --- Initialization --- 

    // Initial scroll to bottom
    scrollToBottom();

    // Initial button state
    updateSendButtonState();

    // Set focus to the input field on load
    if (messageInput) {
        // @ts-ignore
        messageInput.focus();
    }

}());


==============================================
FILE: ./src/vscode-extension/web-ui/communication-panel.css
==============================================

:root {
    --fuse-primary: var(--vscode-button-background);
    --fuse-secondary: var(--vscode-button-hoverBackground);
    --fuse-accent: var(--vscode-activityBarBadge-background);
    --fuse-border: var(--vscode-panel-border, var(--vscode-divider-background));
    --fuse-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    --fuse-radius: 8px;
    --fuse-transition: all 0.2s ease;
}

body {
    font-family: var(--vscode-font-family);
    margin: 0;
    padding: 0;
    color: var(--vscode-foreground);
    background-color: var(--vscode-editor-background);
    height: 100vh;
    overflow: hidden;
}

/* App Container */
.app-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
}

/* Header */
.app-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background-color: var(--vscode-sideBar-background, var(--vscode-editor-background));
    border-bottom: 1px solid var(--fuse-border);
    z-index: 10;
}

.logo-container {
    display: flex;
    align-items: center;
    gap: 12px;
}

.app-logo {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background-color: var(--fuse-primary);
    color: var(--vscode-button-foreground);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
}

.app-header h1 {
    margin: 0;
    font-size: 18px;
    font-weight: 500;
}

.header-actions {
    display: flex;
    gap: 8px;
}

.header-button {
    background: transparent;
    border: none;
    color: var(--vscode-foreground);
    width: 32px;
    height: 32px;
    border-radius: var(--fuse-radius);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: var(--fuse-transition);
}

.header-button:hover {
    background-color: var(--vscode-list-hoverBackground);
    transform: translateY(-2px);
}

/* Main Content */
.main-content {
    display: flex;
    flex: 1;
    overflow: hidden;
}

/* Sidebar */
.sidebar {
    width: 250px;
    background-color: var(--vscode-sideBar-background);
    border-right: 1px solid var(--fuse-border);
    overflow-y: auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 24px;
}

.sidebar-section {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.sidebar-section h3 {
    margin: 0;
    font-size: 14px;
    font-weight: 500;
    color: var(--vscode-descriptionForeground);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.action-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.action-button {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border-radius: var(--fuse-radius);
    background-color: transparent;
    border: 1px solid var(--fuse-border);
    color: var(--vscode-foreground);
    cursor: pointer;
    transition: var(--fuse-transition);
}

.action-button:hover {
    background-color: var(--vscode-list-hoverBackground);
    transform: translateY(-2px);
}

.action-icon {
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.agent-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.empty-state {
    padding: 16px;
    text-align: center;
    color: var(--vscode-descriptionForeground);
    border: 1px dashed var(--fuse-border);
    border-radius: var(--fuse-radius);
}

.empty-state p {
    margin: 0 0 12px 0;
}

.secondary-button {
    background-color: transparent;
    border: 1px solid var(--fuse-primary);
    color: var(--fuse-primary);
    padding: 6px 12px;
    border-radius: var(--fuse-radius);
    cursor: pointer;
    transition: var(--fuse-transition);
}

.secondary-button:hover {
    background-color: rgba(0, 122, 255, 0.1);
}

/* Content Area */
.content-area {
    flex: 1;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

/* Tabs */
.tabs-container {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.tabs-header {
    display: flex;
    border-bottom: 1px solid var(--fuse-border);
    background-color: var(--vscode-sideBar-background, var(--vscode-editor-background));
}

.tab-button {
    padding: 12px 16px;
    background: transparent;
    border: none;
    border-bottom: 2px solid transparent;
    color: var(--vscode-foreground);
    cursor: pointer;
    transition: var(--fuse-transition);
}

.tab-button:hover {
    background-color: var(--vscode-list-hoverBackground);
}

.tab-button.active {
    border-bottom-color: var(--fuse-primary);
    font-weight: 500;
}

.tab-content {
    display: none;
    flex: 1;
    overflow: hidden;
}

.tab-content.active {
    display: flex;
    flex-direction: column;
}

/* Dashboard Styles */
.agents-dashboard, .workflows-dashboard, .logs-dashboard {
    padding: 20px;
    overflow-y: auto;
    height: 100%;
}

.agents-dashboard h2, .workflows-dashboard h2, .logs-dashboard h2 {
    margin: 0 0 8px 0;
    font-size: 20px;
    font-weight: 500;
}

.agents-dashboard p, .workflows-dashboard p, .logs-dashboard p {
    margin: 0 0 20px 0;
    color: var(--vscode-descriptionForeground);
}

.agent-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 16px;
    margin-top: 20px;
}

.agent-card {
    background-color: var(--vscode-editorWidget-background);
    border-radius: var(--fuse-radius);
    border: 1px solid var(--fuse-border);
    padding: 16px;
    transition: var(--fuse-transition);
}

.agent-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--fuse-shadow);
}

.agent-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
}

.agent-card-title {
    font-weight: 500;
    font-size: 16px;
}

.agent-card-status {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
}

.status-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.status-active {
    background-color: var(--vscode-testing-runAction);
}

.status-inactive {
    background-color: var(--vscode-errorForeground);
}

.agent-card-capabilities {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 12px;
}

.capability-tag {
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 12px;
    background-color: var(--vscode-badge-background);
    color: var(--vscode-badge-foreground);
}

/* Workflow Styles */
.workflow-actions {
    display: flex;
    gap: 12px;
    margin-bottom: 20px;
}

.primary-button {
    background-color: var(--fuse-primary);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 8px 16px;
    border-radius: var(--fuse-radius);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: var(--fuse-transition);
}

.primary-button:hover {
    background-color: var(--fuse-secondary);
    transform: translateY(-2px);
}

.workflow-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* Log Styles */
.log-filters {
    display: flex;
    gap: 12px;
    margin-bottom: 16px;
    align-items: center;
}

.log-filter {
    padding: 6px 12px;
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border: 1px solid var(--vscode-input-border);
    border-radius: var(--fuse-radius);
}

.log-entries {
    background-color: var(--vscode-editorWidget-background);
    border: 1px solid var(--fuse-border);
    border-radius: var(--fuse-radius);
    height: calc(100% - 100px);
    overflow-y: auto;
}

.log-entry {
    padding: 8px 12px;
    border-bottom: 1px solid var(--fuse-border);
    font-family: var(--vscode-editor-font-family);
    font-size: 13px;
}

.log-timestamp {
    color: var(--vscode-descriptionForeground);
    margin-right: 8px;
}

.log-level {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 4px;
    margin-right: 8px;
    font-size: 11px;
}

.log-level-info {
    background-color: var(--vscode-debugIcon-startForeground);
    color: var(--vscode-editor-background);
}

.log-level-warning {
    background-color: var(--vscode-editorWarning-foreground);
    color: var(--vscode-editor-background);
}

.log-level-error {
    background-color: var(--vscode-editorError-foreground);
    color: var(--vscode-editor-background);
}

.log-source {
    color: var(--vscode-textLink-foreground);
    margin-right: 8px;
}

.log-message {
    margin-top: 4px;
}

/* Responsive Adjustments */
@media (max-width: 768px) {
    .main-content {
        flex-direction: column;
    }

    .sidebar {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid var(--fuse-border);
        max-height: 200px;
    }

    .agent-cards {
        grid-template-columns: 1fr;
    }
}

/* Import chat UI styles */
@import url('./chat-ui.css');



==============================================
FILE: ./src/vscode-extension/web-ui/communication-panel.d.ts
==============================================

// Type declarations for communication-panel.js
declare function acquireVsCodeApi(): any;
declare function logMessage(message: string, type?: string): any void;
declare function updateAgentsList(agents: any[]): any void;



==============================================
FILE: ./src/vscode-extension/web-ui/communication-panel.html
==============================================

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}';">
    <title>The New Fuse - Communication Hub</title>
    <link rel="stylesheet" href="${styleUri}">
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <div class="logo-container">
                <div class="app-logo">🔄</div>
                <h1>The New Fuse</h1>
            </div>
            <div class="header-actions">
                <button class="header-button" id="btn-settings" title="Settings">
                    <span class="icon">⚙️</span>
                </button>
                <button class="header-button" id="btn-help" title="Help">
                    <span class="icon">❓</span>
                </button>
            </div>
        </header>

        <div class="main-content">
            <div class="sidebar">
                <div class="sidebar-section">
                    <h3>Quick Actions</h3>
                    <div class="action-list">
                        <button class="action-button" id="btn-discover">
                            <div class="action-icon">🔍</div>
                            <span>Discover AI Agents</span>
                        </button>
                        <button class="action-button" id="btn-collaboration">
                            <div class="action-icon">🤝</div>
                            <span>Start AI Collaboration</span>
                        </button>
                        <button class="action-button" id="btn-coding">
                            <div class="action-icon">💻</div>
                            <span>Collaborative Coding</span>
                        </button>
                        <button class="action-button" id="btn-analyze">
                            <div class="action-icon">🔬</div>
                            <span>Analyze Code</span>
                        </button>
                        <button class="action-button" id="btn-completion">
                            <div class="action-icon">✨</div>
                            <span>Toggle Completions</span>
                        </button>
                        <button class="action-button" id="btn-mcp">
                            <div class="action-icon">📡</div>
                            <span>MCP Settings</span>
                        </button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>Active Agents</h3>
                    <div class="agent-list" id="agent-list">
                        <!-- Agent list will be populated dynamically -->
                        <div class="empty-state">
                            <p>No agents discovered yet</p>
                            <button class="secondary-button" id="btn-discover-agents">Discover Agents</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="content-area">
                <div class="tabs-container">
                    <div class="tabs-header">
                        <button class="tab-button active" data-tab="communication">Communication</button>
                        <button class="tab-button" data-tab="agents">Agents</button>
                        <button class="tab-button" data-tab="workflows">Workflows</button>
                        <button class="tab-button" data-tab="logs">Logs</button>
                    </div>

                    <div class="tab-content active" id="communication-tab">
                        <div class="chat-container">
                            <div class="chat-header">
                                <select class="session-dropdown" id="session-dropdown">
                                    <option value="new">New Conversation</option>
                                </select>
                                <button class="header-button" id="btn-clear-chat" title="Clear Chat">
                                    <span class="icon">🗑️</span>
                                </button>
                                <button class="header-button" id="btn-export-chat" title="Export Chat">
                                    <span class="icon">📤</span>
                                </button>
                            </div>

                            <div class="message-list" id="message-list">
                                <div class="welcome-message">
                                    <div class="welcome-logo">🔄</div>
                                    <h2>Welcome to The New Fuse Communication Hub</h2>
                                    <p>Coordinate AI extensions and manage inter-agent communication</p>

                                    <div class="welcome-suggestions">
                                        <button class="suggestion-button" id="btn-suggest-discover">
                                            Discover available AI agents in your workspace
                                        </button>
                                        <button class="suggestion-button" id="btn-suggest-collab">
                                            Start a collaborative AI session for your current task
                                        </button>
                                        <button class="suggestion-button" id="btn-suggest-coding">
                                            Get multiple AI perspectives on your code
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div class="input-area">
                                <div class="input-container">
                                    <textarea class="message-input" id="message-input" placeholder="Type a message to communicate with AI agents..."></textarea>
                                    <button class="send-button" id="send-button" title="Send Message">
                                        <span class="icon">➤</span>
                                    </button>
                                </div>

                                <div class="input-actions">
                                    <div class="input-options">
                                        <button class="option-button" id="btn-attach" title="Attach File">
                                            <span class="icon">📎</span>
                                        </button>
                                        <button class="option-button" id="btn-code" title="Insert Code Block">
                                            <span class="icon">📝</span>
                                        </button>
                                    </div>

                                    <div class="model-selector">
                                        <span id="active-model">Using: Default AI Model</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="tab-content" id="agents-tab">
                        <!-- Agents tab content will be inserted here -->
                        <div class="agents-dashboard">
                            <h2>AI Agent Dashboard</h2>
                            <p>Manage and monitor AI agents in your workspace</p>

                            <div class="agent-cards" id="agent-cards">
                                <!-- Agent cards will be populated dynamically -->
                            </div>
                        </div>
                    </div>

                    <div class="tab-content" id="workflows-tab">
                        <!-- Workflows tab content will be inserted here -->
                        <div class="workflows-dashboard">
                            <h2>AI Workflows</h2>
                            <p>Create and manage AI collaboration workflows</p>

                            <div class="workflow-actions">
                                <button class="primary-button" id="btn-new-workflow">
                                    <span class="icon">➕</span> New Workflow
                                </button>
                                <button class="secondary-button" id="btn-import-workflow">
                                    <span class="icon">📥</span> Import
                                </button>
                            </div>

                            <div class="workflow-list" id="workflow-list">
                                <!-- Workflow list will be populated dynamically -->
                            </div>
                        </div>
                    </div>

                    <div class="tab-content" id="logs-tab">
                        <!-- Logs tab content will be inserted here -->
                        <div class="logs-dashboard">
                            <h2>Communication Logs</h2>
                            <p>View logs of AI agent communications</p>

                            <div class="log-filters">
                                <select class="log-filter" id="log-level-filter">
                                    <option value="all">All Levels</option>
                                    <option value="info">Info</option>
                                    <option value="warning">Warning</option>
                                    <option value="error">Error</option>
                                </select>

                                <select class="log-filter" id="log-source-filter">
                                    <option value="all">All Sources</option>
                                    <option value="agent">Agent</option>
                                    <option value="mcp">MCP</option>
                                    <option value="system">System</option>
                                </select>

                                <button class="secondary-button" id="btn-clear-logs">
                                    <span class="icon">🗑️</span> Clear Logs
                                </button>
                            </div>

                            <div class="log-entries" id="log-entries">
                                <!-- Log entries will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script nonce="${nonce}" src="${scriptUri}"></script>
</body>
</html>



==============================================
FILE: ./src/vscode-extension/web-ui/communication-panel.tsx
==============================================

import * as vscode from 'vscode';

/**
 * Communication Panel for agent-to-agent communication
 */
export class CommunicationPanel {
  public static currentPanel: CommunicationPanel | undefined;
  private readonly _panel: vscode.WebviewPanel;
  private readonly _extensionUri: vscode.Uri;
  private _disposables: vscode.Disposable[] = [];

  public static createOrShow(extensionUri: vscode.Uri) {
    const column = vscode.window.activeTextEditor
      ? vscode.window.activeTextEditor.viewColumn
      : undefined;

    // If we already have a panel, show it
    if (CommunicationPanel.currentPanel) {
      CommunicationPanel.currentPanel._panel.reveal(column);
      return;
    }

    // Otherwise, create a new panel
    const panel = vscode.window.createWebviewPanel(
      'communicationPanel',
      'Agent Communication',
      column || vscode.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          vscode.Uri.joinPath(extensionUri, 'media')
        ]
      }
    );

    CommunicationPanel.currentPanel = new CommunicationPanel(panel, extensionUri);
  }

  private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {
    this._panel = panel;
    this._extensionUri = extensionUri;

    // Set the webview's initial html content
    this._update();

    // Listen for when the panel is disposed
    // This happens when the user closes the panel or when the panel is closed programmatically
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);

    // Update the content based on view changes
    this._panel.onDidChangeViewState(
      e => {
        if (this._panel.visible) {
          this._update();
        }
      },
      null,
      this._disposables
    );

    // Handle messages from the webview
    this._panel.webview.onDidReceiveMessage(
      async message => {
        switch (message.command) {
          case 'discoverAgents':
            await this._discoverAgents();
            break;
          case 'sendMessage':
            await this._sendMessage(message.recipient, message.action, message.payload);
            break;
          case 'registerMcpHandler':
            await this._registerMcpHandler(message.namespace, message.handler);
            break;
        }
      },
      null,
      this._disposables
    );
  }

  private async _discoverAgents() {
    try {
      // This would be replaced with actual agent discovery
      const agents = await this._fetchAgents();
      
      this._panel.webview.postMessage({
        command: 'updateAgents',
        agents
      });
    } catch (error) {
      this._panel.webview.postMessage({
        command: 'logMessage',
        text: `Error discovering agents: ${error instanceof Error ? error.message : String(error)}`,
        type: 'error'
      });
    }
  }

  private async _sendMessage(recipient: string, action: string, payload: any) {
    try {
      // This would be replaced with actual message sending
      console.log(`Sending message to ${recipient}: ${action}`, payload);
      
      // Simulate message sending
      await new Promise(resolve => setTimeout(resolve, 500));
      
      this._panel.webview.postMessage({
        command: 'logMessage',
        text: `Message sent to ${recipient}: ${action}`,
        type: 'info'
      });
    } catch (error) {
      this._panel.webview.postMessage({
        command: 'logMessage',
        text: `Error sending message: ${error instanceof Error ? error.message : String(error)}`,
        type: 'error'
      });
    }
  }

  private async _registerMcpHandler(namespace: string, handler: string) {
    try {
      // This would be replaced with actual MCP handler registration
      console.log(`Registering MCP handler for ${namespace}: ${handler}`);
      
      // Simulate registration
      await new Promise(resolve => setTimeout(resolve, 300));
      
      this._panel.webview.postMessage({
        command: 'logMessage',
        text: `Registered MCP handler for ${namespace}`,
        type: 'info'
      });
    } catch (error) {
      this._panel.webview.postMessage({
        command: 'logMessage',
        text: `Error registering handler: ${error instanceof Error ? error.message : String(error)}`,
        type: 'error'
      });
    }
  }

  private async _fetchAgents(): Promise<any[]> {
    // This would be replaced with actual agent discovery
    return [
      {
        id: 'agent-1',
        name: 'Code Assistant',
        capabilities: ['code-generation', 'code-review', 'refactoring']
      },
      {
        id: 'agent-2',
        name: 'Data Analyst',
        capabilities: ['data-processing', 'visualization', 'statistics']
      },
      {
        id: 'agent-3',
        name: 'Documentation Helper',
        capabilities: ['documentation', 'explanation', 'summarization']
      }
    ];
  }

  private _update() {
    const webview = this._panel.webview;
    this._panel.title = "Agent Communication";
    this._panel.webview.html = this._getHtmlForWebview(webview);
  }

  private _getHtmlForWebview(webview: vscode.Webview) {
    const nonce = getNonce();

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}';">
    <title>Agent Communication</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            color: var(--vscode-foreground);
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .header {
            margin-bottom: 20px;
        }
        .main-content {
            display: flex;
            flex: 1;
            gap: 20px;
            margin-bottom: 20px;
        }
        .agents-panel {
            flex: 1;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
        }
        .communication-panel {
            flex: 2;
            display: flex;
            flex-direction: column;
        }
        .message-form {
            border: 1px solid var(--vscode-panel-border);
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .mcp-form {
            border: 1px solid var(--vscode-panel-border);
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .log-panel {
            flex: 1;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
            background-color: var(--vscode-editor-background);
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            background-color: var(--vscode-input-background);
            color: var(--vscode-input-foreground);
            border: 1px solid var(--vscode-input-border);
            border-radius: 2px;
        }
        textarea {
            min-height: 100px;
            font-family: monospace;
        }
        button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 2px;
        }
        button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }
        .agent-item {
            border: 1px solid var(--vscode-panel-border);
            border-radius: 3px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        .agent-name {
            font-weight: bold;
        }
        .agent-capabilities {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .capability-tag {
            background-color: var(--vscode-badge-background);
            color: var(--vscode-badge-foreground);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 12px;
        }
        .log-entry {
            display: flex;
            margin-bottom: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        .log-timestamp {
            color: var(--vscode-descriptionForeground);
            margin-right: 10px;
            white-space: nowrap;
        }
        .log-message {
            word-break: break-word;
        }
        h2 {
            margin-top: 0;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Agent Communication Panel</h1>
            <button id="discover-agents">Discover AI Agents</button>
        </div>
        
        <div class="main-content">
            <div class="agents-panel">
                <h2>Available Agents</h2>
                <div id="agents-container">
                    <p>No agents discovered yet. Click "Discover AI Agents" to find available AI extensions.</p>
                </div>
            </div>
            
            <div class="communication-panel">
                <div class="message-form">
                    <h2>Send Message</h2>
                    <div class="form-group">
                        <label for="recipient">Recipient:</label>
                        <select id="recipient">
                            <option value="">Select an agent</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="action">Action:</label>
                        <input type="text" id="action" placeholder="e.g., generate-code, analyze-data">
                    </div>
                    
                    <div class="form-group">
                        <label for="payload">Payload (JSON):</label>
                        <textarea id="payload" placeholder='{"prompt": "Generate a function that..."}'></textarea>
                    </div>
                    
                    <button id="send-message">Send Message</button>
                </div>
                
                <div class="mcp-form">
                    <h2>Register MCP Handler</h2>
                    <div class="form-group">
                        <label for="mcp-namespace">Namespace:</label>
                        <input type="text" id="mcp-namespace" placeholder="e.g., code">
                    </div>
                    
                    <div class="form-group">
                        <label for="mcp-command">Command:</label>
                        <input type="text" id="mcp-command" placeholder="e.g., generate">
                    </div>
                    
                    <div class="form-group">
                        <label for="mcp-handler">Handler:</label>
                        <input type="text" id="mcp-handler" placeholder="e.g., generateCode">
                    </div>
                    
                    <button id="register-mcp">Register Handler</button>
                </div>
                
                <div class="log-panel">
                    <h2>Communication Log</h2>
                    <div id="comms-log"></div>
                </div>
            </div>
        </div>
    </div>

    <script nonce="${nonce}">
        const vscode = acquireVsCodeApi();
        
        document.addEventListener('DOMContentLoaded', () => {
            // Set up event listeners
            document.getElementById('discover-agents').addEventListener('click', () => {
                vscode.postMessage({ command: 'discoverAgents' });
                logMessage('Discovering AI agents...');
            });
            
            document.getElementById('send-message').addEventListener('click', () => {
                const recipient = document.getElementById('recipient').value;
                const action = document.getElementById('action').value;
                const payload = document.getElementById('payload').value;
                
                if (!recipient || !action) {
                    logMessage('Error: Recipient and action are required', 'error');
                    return;
                }
                
                try {
                    const parsedPayload = JSON.parse(payload);
                    vscode.postMessage({
                        command: 'sendMessage',
                        recipient,
                        action,
                        payload: parsedPayload
                    });
                    logMessage(\`Sent message to \${recipient}: \${action}\`);
                } catch (e) {
                    logMessage('Error: Invalid JSON payload', 'error');
                }
            });

            document.getElementById('register-mcp').addEventListener('click', () => {
                const namespace = document.getElementById('mcp-namespace').value;
                const command = document.getElementById('mcp-command').value;
                const handler = document.getElementById('mcp-handler').value;

                if (!namespace || !command || !handler) {
                    logMessage('Error: All MCP fields are required', 'error');
                    return;
                }

                vscode.postMessage({
                    command: 'registerMcpHandler',
                    namespace: namespace + '.' + command,
                    handler
                });
                logMessage(\`Registered MCP handler for \${namespace}.\${command}\`);
            });
        });

        // Handle messages from the extension
        window.addEventListener('message', event => {
            const message = event.data;

            switch (message.command) {
                case 'updateAgents':
                    updateAgentsList(message.agents);
                    break;

                case 'logMessage':
                    logMessage(message.text, message.type);
                    break;
            }
        });

        // Update the agents list
        function updateAgentsList(agents) {
            const container = document.getElementById('agents-container');
            const recipientSelect = document.getElementById('recipient');

            // Clear existing content
            container.innerHTML = '';
            recipientSelect.innerHTML = '';

            if (!agents || agents.length === 0) {
                container.innerHTML = '<p>No agents discovered. Click "Discover AI Agents" to find available AI extensions.</p>';
                return;
            }

            agents.forEach(agent => {
                // Add to the detailed view
                const agentEl = document.createElement('div');
                agentEl.className = 'agent-item';

                const header = document.createElement('div');
                header.className = 'agent-header';

                const name = document.createElement('div');
                name.className = 'agent-name';
                name.textContent = agent.name || agent.id;

                header.appendChild(name);
                agentEl.appendChild(header);

                if (agent.capabilities && agent.capabilities.length) {
                    const capsContainer = document.createElement('div');
                    capsContainer.className = 'agent-capabilities';

                    agent.capabilities.forEach(cap => {
                        const capTag = document.createElement('span');
                        capTag.className = 'capability-tag';
                        capTag.textContent = cap;
                        capsContainer.appendChild(capTag);
                    });

                    agentEl.appendChild(capsContainer);
                }

                container.appendChild(agentEl);

                // Add to the recipient dropdown
                const option = document.createElement('option');
                option.value = agent.id;
                option.textContent = agent.name || agent.id;
                recipientSelect.appendChild(option);
            });

            logMessage(\`Found \${agents.length} AI agents\`);
        }

        // Add a message to the log
        function logMessage(message, type = 'info') {
            const log = document.getElementById('comms-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const timestamp = document.createElement('div');
            timestamp.className = 'log-timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();

            const messageEl = document.createElement('div');
            messageEl.className = 'log-message';
            if (type === 'error') {
                messageEl.style.color = 'var(--vscode-errorForeground)';
            }
            messageEl.textContent = message;

            entry.appendChild(timestamp);
            entry.appendChild(messageEl);

            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // Request initial agents list
        vscode.postMessage({ command: 'discoverAgents' });
    </script>
</body>
</html>`;
  }

  public dispose() {
    CommunicationPanel.currentPanel = undefined;

    // Clean up our resources
    this._panel.dispose();

    while (this._disposables.length) {
      const x = this._disposables.pop();
      if (x) {
        x.dispose();
      }
    }
  }
}

function getNonce() {
  let text = '';
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}



==============================================
FILE: ./src/vscode-extension/web-ui/master-command-center.html
==============================================

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}'; font-src ${webview.cspSource};">
    <title>The New Fuse - Master Command Center</title>
    <style>
        /* Base theme variables - will adjust for dark/light themes */
        :root {
            --primary-color: var(--vscode-button-background);
            --secondary-color: var(--vscode-button-hoverBackground);
            --accent-color: var(--vscode-activityBarBadge-background);
            --background-color: var(--vscode-editor-background);
            --card-background: var(--vscode-editorWidget-background);
            --text-color: var(--vscode-editor-foreground);
            --border-color: var(--vscode-panel-border);
            --hover-color: var(--vscode-list-hoverBackground);
        }
        
        body {
            font-family: var(--vscode-font-family);
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: var(--primary-color);
            color: var(--vscode-button-foreground);
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        header h1 {
            margin: 0;
            font-size: 28px;
        }
        
        header p {
            margin: 10px 0 0;
            opacity: 0.8;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .card {
            background-color: var(--card-background);
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .card h2 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            font-size: 20px;
        }
        
        .command-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .command-item {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .command-item:hover {
            background-color: var(--hover-color);
        }
        
        .command-name {
            font-weight: bold;
        }
        
        .command-id {
            font-family: var(--vscode-editor-font-family);
            font-size: 12px;
            color: var(--vscode-descriptionForeground);
        }
        
        .quick-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
        }
        
        .quick-action-btn {
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: var(--vscode-button-foreground);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s;
        }
        
        .quick-action-btn:hover {
            background-color: var(--secondary-color);
        }
        
        .icon {
            font-size: 20px;
        }
        
        .protocol-section {
            background-color: var(--card-background);
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .protocol-section h2 {
            margin-top: 0;
            color: var(--primary-color);
        }
        
        .protocol-options {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        
        .protocol-option {
            flex: 1;
            min-width: 200px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .protocol-option:hover {
            background-color: var(--hover-color);
        }
        
        .protocol-option .icon {
            font-size: 24px;
            margin-bottom: 10px;
            display: block;
        }
        
        .admin-panel {
            background-color: var(--card-background);
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .admin-panel h2 {
            margin-top: 0;
            color: var(--primary-color);
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .status-active {
            background-color: var(--vscode-testing-runAction);
        }
        
        .status-inactive {
            background-color: var(--vscode-errorForeground);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        th, td {
            text-align: left;
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        th {
            background-color: var(--hover-color);
            font-weight: bold;
        }
        
        tr:hover {
            background-color: var(--hover-color);
        }
        
        .shortcuts-list {
            margin-top: 20px;
        }
        
        .keyboard-shortcut {
            display: inline-block;
            background-color: var(--vscode-keybindingLabel-background);
            border: 1px solid var(--vscode-keybindingLabel-border);
            color: var(--vscode-keybindingLabel-foreground);
            border-radius: 3px;
            padding: 2px 6px;
            font-family: var(--vscode-editor-font-family);
            font-size: 12px;
            margin-left: 10px;
        }
        
        .tab-container {
            margin-top: 20px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            border-bottom-color: var(--primary-color);
            font-weight: bold;
        }
        
        .tab-content {
            display: none;
            padding: 20px 0;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Graph visualization area */
        .graph-container {
            width: 100%;
            height: 300px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .graph-node {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: var(--vscode-button-foreground);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 2;
        }
        
        .graph-edge {
            position: absolute;
            background-color: var(--border-color);
            z-index: 1;
            transform-origin: 0 0;
        }
        
        /* Media query for better mobile display */
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .quick-actions {
                flex-direction: column;
            }
            
            .protocol-options {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>The New Fuse - Master Command Center</h1>
            <p>Complete map of all available commands and options for inter-AI communication</p>
        </div>
    </header>
    
    <div class="container">
        <section class="quick-actions">
            <button class="quick-action-btn" onclick="commandClick('thefuse.openCommunicationPanel')">
                <span class="icon">📡</span> Open Communication Hub
            </button>
            <button class="quick-action-btn" onclick="commandClick('thefuse.startAICollab')">
                <span class="icon">🤝</span> Start AI Collaboration
            </button>
            <button class="quick-action-btn" onclick="commandClick('thefuse.startCollaborativeCoding')">
                <span class="icon">👥</span> Start Collaborative Coding
            </button>
            <button class="quick-action-btn" onclick="commandClick('thefuse.analyzeCodeProblem')">
                <span class="icon">🔍</span> Analyze Code Problem
            </button>
            <button class="quick-action-btn" onclick="commandClick('llm-orchestrator.discoverAgents')">
                <span class="icon">🔎</span> Discover AI Agents
            </button>
        </section>
        
        <div class="tab-container">
            <div class="tabs">
                <div class="tab active" data-tab="commands-tab">Commands</div>
                <div class="tab" data-tab="protocols-tab">Communication Protocols</div>
                <div class="tab" data-tab="agents-tab">AI Agents</div>
                <div class="tab" data-tab="viz-tab">Visualization</div>
            </div>
            
            <div class="tab-content active" id="commands-tab">
                <section class="dashboard">
                    <div class="card">
                        <h2>🔄 Core Commands</h2>
                        <ul class="command-list">
                            <li class="command-item" onclick="commandClick('thefuse.openWebUI')">
                                <span class="command-name">Open The New Fuse UI</span>
                                <span class="command-id">thefuse.openWebUI</span>
                            </li>
                            <li class="command-item" onclick="commandClick('thefuse.openCommunicationPanel')">
                                <span class="command-name">Open Communication Hub</span>
                                <span class="command-id">thefuse.openCommunicationPanel</span>
                            </li>
                            <li class="command-item" onclick="commandClick('thefuse.startAICollab')">
                                <span class="command-name">Start AI Collaboration</span>
                                <span class="command-id">thefuse.startAICollab</span>
                            </li>
                            <li class="command-item" onclick="commandClick('thefuse.toggleCollaborativeCompletion')">
                                <span class="command-name">Toggle Collaborative Completion</span>
                                <span class="command-id">thefuse.toggleCollaborativeCompletion</span>
                            </li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h2>🧠 LLM Orchestrator</h2>
                        <ul class="command-list">
                            <li class="command-item" onclick="commandClick('llm-orchestrator.showAgents')">
                                <span class="command-name">Show AI Agents</span>
                                <span class="command-id">llm-orchestrator.showAgents</span>
                            </li>
                            <li class="command-item" onclick="commandClick('llm-orchestrator.discoverAgents')">
                                <span class="command-name">Discover AI Agents</span>
                                <span class="command-id">llm-orchestrator.discoverAgents</span>
                            </li>
                            <li class="command-item" onclick="commandClick('llm-orchestrator.createCollaborativeTask')">
                                <span class="command-name">Create Collaborative Task</span>
                                <span class="command-id">llm-orchestrator.createCollaborativeTask</span>
                            </li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h2>👨‍💻 AI Coding Team</h2>
                        <ul class="command-list">
                            <li class="command-item" onclick="commandClick('thefuse.startCollaborativeCoding')">
                                <span class="command-name">Start Collaborative Coding</span>
                                <span class="command-id">thefuse.startCollaborativeCoding</span>
                            </li>
                            <li class="command-item" onclick="commandClick('thefuse.analyzeCodeProblem')">
                                <span class="command-name">Analyze Code Problem</span>
                                <span class="command-id">thefuse.analyzeCodeProblem</span>
                            </li>
                            <li class="command-item" onclick="commandClick('thefuse.ai.consultCoder')">
                                <span class="command-name">Consult Specific AI Coder</span>
                                <span class="command-id">thefuse.ai.consultCoder</span>
                            </li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h2>📨 Message-Based Communication</h2>
                        <ul class="command-list">
                            <li class="command-item" onclick="commandClick('thefuse.sendFileMessage')">
                                <span class="command-name">Send Message via File Protocol</span>
                                <span class="command-id">thefuse.sendFileMessage</span>
                            </li>
                            <li class="command-item" onclick="commandClick('thefuse.mcp.sendMessage')">
                                <span class="command-name">Send MCP Message</span>
                                <span class="command-id">thefuse.mcp.sendMessage</span>
                            </li>
                            <li class="command-item" onclick="commandClick('thefuse.mcp.registerHandler')">
                                <span class="command-name">Register MCP Handler</span>
                                <span class="command-id">thefuse.mcp.registerHandler</span>
                            </li>
                            <li class="command-item" onclick="commandClick('thefuse.mcp.startAutoDiscovery')">
                                <span class="command-name">Start MCP Auto-Discovery</span>
                                <span class="command-id">thefuse.mcp.startAutoDiscovery</span>
                            </li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h2>🔄 Workflow Engine</h2>
                        <ul class="command-list">
                            <li class="command-item" onclick="commandClick('thefuse.ai.startCollaboration')">
                                <span class="command-name">Start AI Collaboration Workflow</span>
                                <span class="command-id">thefuse.ai.startCollaboration</span>
                            </li>
                            <li class="command-item" onclick="commandClick('thefuse.ai.executeTask')">
                                <span class="command-name">Execute AI Task</span>
                                <span class="command-id">thefuse.ai.executeTask</span>
                            </li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h2>💬 Language Model</h2>
                        <ul class="command-list">
                            <li class="command-item" onclick="commandClick('thefuse.lm.generate')">
                                <span class="command-name">Generate Text with LM</span>
                                <span class="command-id">thefuse.lm.generate</span>
                            </li>
                        </ul>
                    </div>
                </section>
            </div>
            
            <div class="tab-content" id="protocols-tab">
                <section class="protocol-section">
                    <h2>Communication Protocols</h2>
                    <p>Choose one of the available inter-extension communication protocols:</p>
                    
                    <div class="protocol-options">
                        <div class="protocol-option" onclick="selectProtocol('workspaceState')">
                            <span class="icon">📊</span>
                            <h3>Workspace State</h3>
                            <p>Uses VS Code's workspace state storage for asynchronous messaging</p>
                            <ul>
                                <li>Persists across sessions</li>
                                <li>Good for extension-to-extension communication</li>
                                <li>Limited storage space</li>
                            </ul>
                        </div>
                        <div class="protocol-option" onclick="selectProtocol('fileProtocol')">
                            <span class="icon">📁</span>
                            <h3>File Protocol</h3>
                            <p>Uses shared files for communication between extensions</p>
                            <ul>
                                <li>Works across VS Code instances</li>
                                <li>Supports large payloads</li>
                                <li>Visible to the user</li>
                            </ul>
                        </div>
                        <div class="protocol-option" onclick="selectProtocol('commands')">
                            <span class="icon">⚡</span>
                            <h3>Commands API</h3>
                            <p>Uses VS Code commands for direct extension-to-extension calls</p>
                            <ul>
                                <li>Immediate execution</li>
                                <li>Synchronous communication</li>
                                <li>Limited to current VS Code window</li>
                            </ul>
                        </div>
                        <div class="protocol-option" onclick="selectProtocol('mcp')">
                            <span class="icon">🌐</span>
                            <h3>MCP Protocol</h3>
                            <p>Message Control Protocol for standardized communication</p>
                            <ul>
                                <li>Advanced protocol for AI-to-AI communication</li>
                                <li>Auto-discovery of capabilities</li>
                                <li>Structured message format</li>
                            </ul>
                        </div>
                    </div>
                </section>
            </div>
            
            <div class="tab-content" id="agents-tab">
                <section class="admin-panel">
                    <h2>AI Agent Administration</h2>
                    
                    <button class="quick-action-btn" style="margin-bottom: 20px;" onclick="commandClick('llm-orchestrator.discoverAgents')">
                        <span class="icon">🔎</span> Refresh AI Agents
                    </button>
                    
                    <h3>Active AI Extensions</h3>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>Agent ID</th>
                                <th>Name</th>
            
            if (body.classList.contains('dark-mode')) {
                document.documentElement.style.setProperty('--primary-color', '#4f8cc9');
                document.documentElement.style.setProperty('--secondary-color', '#3a6ea5');
                document.documentElement.style.setProperty('--accent-color', '#4CAF50');
                document.documentElement.style.setProperty('--background-color', '#202124');
                document.documentElement.style.setProperty('--card-background', '#292a2d');
                document.documentElement.style.setProperty('--text-color', '#e8eaed');
                document.documentElement.style.setProperty('--border-color', '#444446');
                document.documentElement.style.setProperty('--hover-color', '#35363a');
            } else {
                document.documentElement.style.setProperty('--primary-color', '#2c7ad6');
                document.documentElement.style.setProperty('--secondary-color', '#5294e2');
                document.documentElement.style.setProperty('--accent-color', '#4CAF50');
                document.documentElement.style.setProperty('--background-color', '#f5f5f5');
                document.documentElement.style.setProperty('--card-background', '#ffffff');
                document.documentElement.style.setProperty('--text-color', '#333333');
                document.documentElement.style.setProperty('--border-color', '#dddddd');
                document.documentElement.style.setProperty('--hover-color', '#e7f1fd');
            }
        }
        
        // Support for VS Code's color theme
        try {
            if (typeof acquireVsCodeApi === 'function') {
                // We're in a VS Code webview - update based on VS Code theme
                document.body.classList.add('vscode-theme');
            }
        } catch (e) {
            // Not in VS Code webview context
        }
    </script>
</body>
</html>



==============================================
FILE: ./src/vscode-extension/workflow-engine.tsx
==============================================

/**
 * Workflow Engine for AI Agent Coordination
 * 
 * This module provides a workflow engine for coordinating multiple AI agents
 * in The New Fuse platform within VS Code.
 */

import * as vscode from 'vscode';
import { AgentClient, AgentMessage } from './agent-communication';
import { getErrorMessage } from './utilities';
import * as crypto from 'crypto';

export interface WorkflowStep {
  id: string;
  agent: string;
  action: string;
  input: Record<string, any>;
  condition?: string;
  timeout?: number;
}

export interface Workflow {
  id: string;
  name: string;
  description?: string;
  steps: WorkflowStep[];
}

export interface WorkflowExecutionContext {
  workflowId: string;
  executionId: string;
  variables: Record<string, any>;
  stepResults: Record<string, any>;
  status: 'running' | 'completed' | 'failed';
}

export interface WorkflowExecutionOptions {
  debugMode?: boolean;
  timeout?: number;
  customInput?: Record<string, any>;
}

export class WorkflowEngine {
  private context: vscode.ExtensionContext;
  private agentClient: AgentClient;
  private runningWorkflows: Map<string, WorkflowExecutionContext> = new Map();
  
  constructor(context: vscode.ExtensionContext, agentClient: AgentClient) {
    this.context = context;
    this.agentClient = agentClient;
  }
  
  // Execute a workflow
  async executeWorkflow(
    workflow: Workflow,
    options: WorkflowExecutionOptions = {}
  ): Promise<WorkflowExecutionContext> {
    const executionId = crypto.randomUUID();
    const context: WorkflowExecutionContext = {
      workflowId: workflow.id,
      executionId,
      variables: options.customInput || {},
      stepResults: {},
      status: 'running'
    };
    
    this.runningWorkflows.set(executionId, context);
    
    try {
      for (const step of workflow.steps) {
        const input = this.resolveTemplateStrings(step.input, context);
        const result = await this.executeStep(step, input, context);
        context.stepResults[step.id] = result;
      }
      
      context.status = 'completed';
    } catch (error) {
      context.status = 'failed';
      throw error;
    } finally {
      this.runningWorkflows.delete(executionId);
    }
    
    return context;
  }
  
  // Execute a single workflow step
  private async executeStep(
    step: WorkflowStep,
    input: Record<string, any>,
    context: WorkflowExecutionContext
  ): Promise<any> {
    // Check step condition if present
    if (step.condition) {
      const conditionResult = this.evaluateCondition(step.condition, context);
      if (!conditionResult) {
        // Skip this step
        return null;
      }
    }
    
    // Set up timeout handler
    let timeoutId: NodeJS.Timeout | undefined;
    const timeoutPromise = new Promise((_, reject) => {
      if (step.timeout) {
        timeoutId = setTimeout(() => {
          reject(new Error(`Step ${step.id} timed out after ${step.timeout}ms`));
        }, step.timeout);
      }
    });
    
    try {
      // Execute the step with the agent
      const executePromise = vscode.commands.executeCommand(
        `thefuse.agent.${step.agent}.execute`,
        {
          action: step.action,
          input,
          context: {
            workflowId: context.workflowId,
            executionId: context.executionId,
            stepId: step.id
          }
        }
      );
      
      // Race the execution against the timeout
      const result = step.timeout
        ? await Promise.race([executePromise, timeoutPromise])
        : await executePromise;
      
      return result;
    } catch (error) {
      throw error;
    } finally {
      // Clear timeout if it was set
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    }
  }
  
  // Evaluate a condition against the current context
  private evaluateCondition(condition: string, context: WorkflowExecutionContext): boolean {
    try {
      // Create a safe evaluation context with access to specific variables
      const evalContext = {
        variables: context.variables,
        results: context.stepResults,
        context: {
          workflowId: context.workflowId,
          executionId: context.executionId,
          status: context.status
        }
      };
      
      // Simple expression evaluation - in a real implementation, use a proper
      // expression evaluator with sandboxing for security
      const evalFunction = new Function('context', `
        with(context) {
          return (${condition});
        }
      `);
      
      return Boolean(evalFunction(evalContext));
    } catch (error) {
      console.error(`Error evaluating condition: ${getErrorMessage(error)}`);
      return false;
    }
  }
  
  // Resolve template strings in an object
  private resolveTemplateStrings(obj: any, context: WorkflowExecutionContext): any {
    if (typeof obj === 'string') {
      return this.resolveTemplateString(obj, context);
    }
    
    if (Array.isArray(obj)) {
      return obj.map(item => this.resolveTemplateStrings(item, context));
    }
    
    if (obj !== null && typeof obj === 'object') {
      const result: Record<string, any> = {};
      for (const [key, value] of Object.entries(obj)) {
        result[key] = this.resolveTemplateStrings(value, context);
      }
      return result;
    }
    
    return obj;
  }
  
  // Resolve a single template string
  private resolveTemplateString(template: string, context: WorkflowExecutionContext): any {
    return template.replace(/\{\{(.*?)\}\}/g, (match, path) => {
      try {
        path = path.trim();
        
        // Handle special variables
        if (path.startsWith('workflow.')) {
          const workflowProp = path.substring('workflow.'.length);
          if (workflowProp === 'id') return context.workflowId;
          if (workflowProp === 'executionId') return context.executionId;
        }
        
        if (path.startsWith('variables.')) {
          const varPath = path.substring('variables.'.length);
          return this.getValueByPath(context.variables, varPath);
        }
        
        if (path.startsWith('steps.')) {
          const stepPath = path.substring('steps.'.length);
          const [stepId, resultPath] = stepPath.split('.output.');
          if (resultPath) {
            const stepResult = context.stepResults[stepId];
            return this.getValueByPath(stepResult, resultPath);
          }
          return context.stepResults[stepId];
        }
        
        // Direct property access
        return this.getValueByPath(context, path) || match;
      } catch (error) {
        console.error(`Error resolving template: ${getErrorMessage(error)}`);
        return match;
      }
    });
  }
  
  // Get a value from an object by path
  private getValueByPath(obj: any, path: string): any {
    const parts = path.split('.');
    let current = obj;
    
    for (const part of parts) {
      if (current === undefined || current === null) return undefined;
      
      // Handle array indexing
      if (part.includes('[') && part.includes(']')) {
        const arrayName = part.substring(0, part.indexOf('['));
        const indexStr = part.substring(part.indexOf('[') + 1, part.indexOf(']'));
        const index = parseInt(indexStr, 10);
        
        current = current[arrayName] ? current[arrayName][index] : undefined;
      } else {
        current = current[part];
      }
    }
    
    return current;
  }
}